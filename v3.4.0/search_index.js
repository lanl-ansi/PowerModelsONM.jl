var documenterSearchIndex = {"docs":
[{"location":"schemas/output.schema.html#Output-Schema","page":"output.schema","title":"Output Schema","text":"","category":"section"},{"location":"schemas/output.schema.html","page":"output.schema","title":"output.schema","text":"If this page exists in final documentation, automatic conversion of schema to documentation failed.","category":"page"},{"location":"reference/data.html#DataAPI","page":"Data Handling","title":"Data","text":"","category":"section"},{"location":"reference/data.html#Data-Handling","page":"Data Handling","title":"Data Handling","text":"","category":"section"},{"location":"reference/data.html","page":"Data Handling","title":"Data Handling","text":"Modules = [PowerModelsONM]\nPrivate = false\nOrder = [:function]\nPages = [\"data.jl\"]","category":"page"},{"location":"reference/data.html","page":"Data Handling","title":"Data Handling","text":"count_faults","category":"page"},{"location":"reference/data.html#PowerModelsONM.count_faults","page":"Data Handling","title":"PowerModelsONM.count_faults","text":"count_faults(faults::Dict{String,<:Any})::Int\n\nHelper function to count the total number of faults.\n\n\n\n\n\n","category":"function"},{"location":"reference/data.html#Solution-Handling","page":"Data Handling","title":"Solution Handling","text":"","category":"section"},{"location":"reference/data.html","page":"Data Handling","title":"Data Handling","text":"Modules = [PowerModelsONM]\nPrivate = false\nOrder = [:function]\nPages = [\"solution.jl\"]","category":"page"},{"location":"reference/data.html#PowerModelsONM.apply_switch_solutions!-Tuple{Dict{String}, Dict{String}}","page":"Data Handling","title":"PowerModelsONM.apply_switch_solutions!","text":"apply_switch_solutions!(network::Dict{String,<:Any}, optimal_switching_results::Dict{String,<:Any})::Dict{String,Any}\n\nUpdates a multinetwork network in-place with the results from optimal switching optimal_switching_results.\n\nUsed when not using the in-place version of optimize_switches!.\n\n\n\n\n\n","category":"method"},{"location":"reference/data.html#PowerModelsONM.apply_switch_solutions-Tuple{Dict{String}, Dict{String}}","page":"Data Handling","title":"PowerModelsONM.apply_switch_solutions","text":"apply_switch_solutions(network::Dict{String,<:Any}, optimal_switching_results::Dict{String,<:Any})::Dict{String,Any}\n\nCreates a copy of the network with the solution copied in from optimal_switching_results.\n\n\n\n\n\n","category":"method"},{"location":"reference/data.html#PowerModelsONM.solution_blocks!-Tuple{AbstractUnbalancedPowerModel, Dict{String, Any}}","page":"Data Handling","title":"PowerModelsONM.solution_blocks!","text":"solution_blocks!(pm::AbstractUnbalancedPowerModel, sol::Dict{String,Any})\n\nAdds block ids (as generated in the ref), and microgrid_ids to the solution\n\n\n\n\n\n","category":"method"},{"location":"reference/data.html#PowerModelsONM.solution_inverter!-Tuple{AbstractUnbalancedPowerModel, Dict{String, Any}}","page":"Data Handling","title":"PowerModelsONM.solution_inverter!","text":"solution_inverter!(pm::AbstractUnbalancedPowerModel, sol::Dict{String,Any})\n\nConverts inverter to Inverter enum, across all time steps.\n\n\n\n\n\n","category":"method"},{"location":"reference/data.html#PowerModelsONM.solution_reference_buses!-Tuple{AbstractUnbalancedPowerModel, Dict{String, Any}}","page":"Data Handling","title":"PowerModelsONM.solution_reference_buses!","text":"solution_reference_buses!(pm::AbstractUnbalancedPowerModel, sol::Dict{String,Any})\n\nRaises bus_type from math model up to solution for reporting, across all time steps.\n\n\n\n\n\n","category":"method"},{"location":"reference/data.html#PowerModelsONM.solution_statuses!-Tuple{AbstractUnbalancedPowerModel, Dict{String, Any}}","page":"Data Handling","title":"PowerModelsONM.solution_statuses!","text":"solution_statuses!(pm::AbstractUnbalancedPowerModel, sol::Dict{String,Any})\n\nConverts all status fields in a solution sol from Float64 to Status enum, for all time steps.\n\n\n\n\n\n","category":"method"},{"location":"developer/roadmap.html#PowerModelsONM-Roadmap","page":"Roadmap","title":"PowerModelsONM Roadmap","text":"","category":"section"},{"location":"developer/roadmap.html","page":"Roadmap","title":"Roadmap","text":"This is a working document that contains an ongoing list of upcoming features and bug fixes that are anticipated to be added into PowerModelsONM","category":"page"},{"location":"developer/roadmap.html#Desired-Features","page":"Roadmap","title":"Desired Features","text":"","category":"section"},{"location":"developer/roadmap.html","page":"Roadmap","title":"Roadmap","text":"This section contains a list of desired upcoming features, in no particular order:","category":"page"},{"location":"developer/roadmap.html","page":"Roadmap","title":"Roadmap","text":"SOC relaxation for MLD\nUser-friendly settings solve fidelity settings\nMINLP MLD examples\nIntegration of protection optimizer\nIndividually controllable / continuously sheddable loads","category":"page"},{"location":"schemas/input-inverters.schema.html#Inverters-Schema","page":"Inverters Schema","title":"Inverters Schema","text":"","category":"section"},{"location":"schemas/input-inverters.schema.html","page":"Inverters Schema","title":"Inverters Schema","text":"If this page exists in final documentation, automatic conversion of schema to documentation failed.","category":"page"},{"location":"manual/graphml_export.html#GraphML-Export","page":"Exporting with GraphML","title":"GraphML Export","text":"","category":"section"},{"location":"manual/graphml_export.html","page":"Exporting with GraphML","title":"Exporting with GraphML","text":"In PowerModelsONM we include a capability to export a network data structure as a graph, either nested, i.e., consisting of subgraphs of load blocks or unnested in the GraphML format, which is an XML format.","category":"page"},{"location":"manual/graphml_export.html","page":"Exporting with GraphML","title":"Exporting with GraphML","text":"We also include in the examples/data folder a suggested \"Configuration\" for use in the yEd Properties Manager. This configuration was used to construct the examples below.","category":"page"},{"location":"manual/graphml_export.html#Unnested-Graph","page":"Exporting with GraphML","title":"Unnested Graph","text":"","category":"section"},{"location":"manual/graphml_export.html","page":"Exporting with GraphML","title":"Exporting with GraphML","text":"To export an unnested graph","category":"page"},{"location":"manual/graphml_export.html","page":"Exporting with GraphML","title":"Exporting with GraphML","text":"import PowerModelsONM as ONM\nonm_path = joinpath(dirname(pathof(ONM)), \"../examples/data\")\neng = ONM.PMD.parse_file(joinpath(onm_path, \"network.ieee13.dss\"))\nsave_graphml(\"unnested_ieee13.graphml\", eng; type=\"unnested\")","category":"page"},{"location":"manual/graphml_export.html","page":"Exporting with GraphML","title":"Exporting with GraphML","text":"Below is what this exported graphml looks like after being loaded in yEd, the ONM recommended properaties applied, and the Orthogonal - Classic layout applied.","category":"page"},{"location":"manual/graphml_export.html","page":"Exporting with GraphML","title":"Exporting with GraphML","text":"(Image: Unnested IEEE13 Graph)","category":"page"},{"location":"manual/graphml_export.html#Nested-Graph","page":"Exporting with GraphML","title":"Nested Graph","text":"","category":"section"},{"location":"manual/graphml_export.html","page":"Exporting with GraphML","title":"Exporting with GraphML","text":"To export an nested graph","category":"page"},{"location":"manual/graphml_export.html","page":"Exporting with GraphML","title":"Exporting with GraphML","text":"import PowerModelsONM as ONM\nonm_path = joinpath(dirname(pathof(ONM)), \"../examples/data\")\neng = ONM.PMD.parse_file(joinpath(onm_path, \"network.ieee13.dss\"))\nsave_graphml(\"nested_ieee13.graphml\", eng; type=\"nested\")","category":"page"},{"location":"manual/graphml_export.html","page":"Exporting with GraphML","title":"Exporting with GraphML","text":"Below is what this exported graphml looks like after being loaded in yEd, the ONM recommended properaties applied, and the Orthogonal - Classic layout applied.","category":"page"},{"location":"manual/graphml_export.html","page":"Exporting with GraphML","title":"Exporting with GraphML","text":"(Image: Nested IEEE13 Graph)","category":"page"},{"location":"reference/variable_constraint.html#VarConAPI","page":"Variables and Constraints","title":"Variables and Constraints","text":"","category":"section"},{"location":"reference/variable_constraint.html#Variables","page":"Variables and Constraints","title":"Variables","text":"","category":"section"},{"location":"reference/variable_constraint.html","page":"Variables and Constraints","title":"Variables and Constraints","text":"Modules = [PowerModelsONM]\nPrivate = false\nOrder = [:function]\nPages = [\"variable.jl\", \"form/acp.jl\", \"form/acr.jl\", \"form/apo.jl\", \"form/lindistflow.jl\", \"form/shared.jl\"]\nFilter = t -> startswith(string(t), \"variable_\")","category":"page"},{"location":"reference/variable_constraint.html#PowerModelsONM.variable_block_indicator-Tuple{AbstractUnbalancedPowerModel}","page":"Variables and Constraints","title":"PowerModelsONM.variable_block_indicator","text":"variable_block_indicator(\n    pm::AbstractUnbalancedPowerModel;\n    nw::Int=nw_id_default,\n    relax::Bool=false,\n    report::Bool=true\n)\n\nCreate variables for block status by load block, z^bl_iin01forall i in B, binary if relax=false. Variables will appear in solution if report=true.\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.variable_bus_voltage_indicator-Tuple{AbstractUnbalancedPowerModel}","page":"Variables and Constraints","title":"PowerModelsONM.variable_bus_voltage_indicator","text":"variable_bus_voltage_indicator(\n    pm::AbstractUnbalancedPowerModel;\n    nw::Int=nw_id_default,\n    relax::Bool=false,\n    report::Bool=true\n)\n\nVariables for switching buses on/off z^bus_iforall i in N, binary if relax=false. Variables will appear in solution if report=true.\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.variable_generator_indicator-Tuple{AbstractUnbalancedPowerModel}","page":"Variables and Constraints","title":"PowerModelsONM.variable_generator_indicator","text":"variable_generator_indicator(pm::AbstractUnbalancedPowerModel; nw::Int=nw_id_default, relax::Bool=false, report::Bool=true)\n\nVariables for switching generators on/off z^gen_iforall i in G, binary if relax=false. Variables will appear in solution if report=true.\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.variable_inverter_indicator-Tuple{AbstractUnbalancedPowerModel}","page":"Variables and Constraints","title":"PowerModelsONM.variable_inverter_indicator","text":"variable_inverter_indicator(pm::AbstractUnbalancedPowerModel; nw::Int=nw_id_default, relax::Bool=false, report::Bool=true)\n\nVariables for indicating whether a DER (storage or gen) is in grid-forming mode (1) or grid-following mode (0), binary is relax=false. Variables will appear in solution if report=true. If \"inverter\"==GRID_FOLLOWING on the device, the inverter variable will be a constant.\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.variable_load_indicator-Tuple{AbstractUnbalancedPowerModel}","page":"Variables and Constraints","title":"PowerModelsONM.variable_load_indicator","text":"variable_load_indicator(pm::AbstractUnbalancedPowerModel; nw::Int=nw_id_default, relax::Bool=false, report::Bool=true)\n\nVariables for switching loads on/off z^d_iforall i in L, binary if relax=false. Variables will appear in solution if report=true.\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.variable_mc_load_power_block_scenario-Tuple{PowerModelsDistribution.AbstractUBFModels, Int64}","page":"Variables and Constraints","title":"PowerModelsONM.variable_mc_load_power_block_scenario","text":"variable_mc_load_power(pm::PMD.AbstractUBFModels, scen::Int; nw=nw_id_default, report::Bool=false)\n\nLoad variables creation for robust mld problem. The bounds are different for each scenario.\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.variable_mc_storage_power_mi_on_off-Tuple{AbstractUnbalancedPowerModel}","page":"Variables and Constraints","title":"PowerModelsONM.variable_mc_storage_power_mi_on_off","text":"variable_mc_storage_power_mi_on_off(\n    pm::AbstractUnbalancedPowerModel;\n    nw::Int=nw_id_default,\n    relax::Bool=false,\n    bounded::Bool=true,\n    report::Bool=true\n)\n\nVariables for storage, omitting the storage indicator z^strg_i variable:\n\nbeginalign\np^strg_iforall i in S \nq^strg_iforall i in S \nq^sc_iforall i in S \nepsilon_iforall i in S \nc^strg_iforall i in S \nc^on_i in 01forall i in S \nd^on_i in 01forall i in S \nendalign\n\nc^on_i\n\n, d^on_i will be binary if relax=false. Variables will appear in solution if report=true.\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.variable_robust_inverter_indicator-Tuple{AbstractUnbalancedPowerModel}","page":"Variables and Constraints","title":"PowerModelsONM.variable_robust_inverter_indicator","text":"variable_robust_inverter_indicator(pm::AbstractUnbalancedPowerModel; nw::Int=nw_id_default, report::Bool=true)\n\nRobust mld (outer) problem solution for indicating whether a DER (storage or gen) is in grid-forming mode (1) or grid-following mode (0).\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.variable_robust_switch_state-Tuple{AbstractUnbalancedPowerModel}","page":"Variables and Constraints","title":"PowerModelsONM.variable_robust_switch_state","text":"variable_robust_switch_state(pm::AbstractUnbalancedPowerModel; nw::Int=nw_id_default, report::Bool=true)\n\nRobust mld (outer) problem solution for switch state (open/close) variables\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.variable_storage_indicator-Tuple{AbstractUnbalancedPowerModel}","page":"Variables and Constraints","title":"PowerModelsONM.variable_storage_indicator","text":"variable_storage_indicator(pm::AbstractUnbalancedPowerModel; nw::Int=nw_id_default, relax::Bool=false, report::Bool=true)\n\nVariables for switching storage on/off z^strg_iforall i in E, binary if relax=false. Variables will appear in solution if report=true.\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.variable_switch_state-Tuple{AbstractUnbalancedPowerModel}","page":"Variables and Constraints","title":"PowerModelsONM.variable_switch_state","text":"variable_switch_state(\n    pm::AbstractUnbalancedPowerModel;\n    nw::Int=nw_id_default,\n    report::Bool=true,\n    relax::Bool=false\n)\n\nCreate variables for switch state (open/close) variables, gamma_iin01forall i in S, binary if relax=false. Variables for non-dispatchable switches will be constants, rather than VariableRef. Variables will appear in solution if report=true.\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#Constraints","page":"Variables and Constraints","title":"Constraints","text":"","category":"section"},{"location":"reference/variable_constraint.html","page":"Variables and Constraints","title":"Variables and Constraints","text":"Modules = [PowerModelsONM]\nPrivate = false\nOrder = [:function]\nPages = [\"constraint_template.jl\", \"constraint.jl\", \"form/acp.jl\", \"form/acr.jl\", \"form/apo.jl\", \"form/lindistflow.jl\", \"form/shared.jl\"]\nFilter = t -> startswith(string(t), \"constraint_\")","category":"page"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_disable_networking-Tuple{AbstractUnbalancedPowerModel}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_disable_networking","text":"constraint_disable_networking(pm::AbstractUnbalancedPowerModel; nw::Int=nw_id_default, relax::Bool=false)\n\nTemplate function for constraint to disable microgrid networking.\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_grid_forming_inverter_per_cc_block-Tuple{AbstractUnbalancedPowerModel}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_grid_forming_inverter_per_cc_block","text":"constraint_grid_forming_inverter_per_cc_block(pm::AbstractUnbalancedPowerModel; nw::Int=nw_id_default, relax::Bool=false)\n\nTemplate function for constraining the number of grid-forming inverters per connected component in the block mld problem\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_grid_forming_inverter_per_cc_traditional-Tuple{AbstractUnbalancedPowerModel}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_grid_forming_inverter_per_cc_traditional","text":"constraint_grid_forming_inverter_per_cc_traditional(pm::AbstractUnbalancedPowerModel; nw::Int=nw_id_default, relax::Bool=false)\n\nTemplate function for constraining the number of grid-forming inverters per connected component in the block mld problem\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_isolate_block-Tuple{AbstractUnbalancedPowerModel}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_isolate_block","text":"constraint_isolate_block(pm::AbstractUnbalancedPowerModel; nw::Int=nw_id_default)\n\nTemplate function of constraint to ensure that blocks are properly isolated by open switches in block mld problem.\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_isolate_block_traditional-Tuple{AbstractUnbalancedPowerModel}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_isolate_block_traditional","text":"constraint_isolate_block_traditional(pm::AbstractUnbalancedPowerModel; nw::Int=nw_id_default)\n\nTemplate function for constraint to ensure that blocks are properly isolated by open switches in a traditional mld problem.\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_bus_voltage_block_on_off-Tuple{AbstractUnbalancedPowerModel}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_bus_voltage_block_on_off","text":"constraint_mc_bus_voltage_block_on_off(pm::AbstractUnbalancedPowerModel; nw::Int=nw_id_default)\n\nTemplate function for bus voltage block on/off constraint.\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_bus_voltage_traditional_on_off-Tuple{AbstractUnbalancedPowerModel}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_bus_voltage_traditional_on_off","text":"constraint_mc_bus_voltage_traditional_on_off(pm::AbstractUnbalancedPowerModel; nw::Int=nw_id_default)\n\nTemplate function for bus voltage traditional on/off constraint.\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_generator_power_block_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_generator_power_block_on_off","text":"constraint_mc_generator_power_block_on_off(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)\n\nTemplate function for generator power block on/off constraint.\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_generator_power_traditional_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_generator_power_traditional_on_off","text":"constraint_mc_generator_power_traditional_on_off(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)\n\nTemplate function for generator power traditional on/off constraint.\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_inverter_theta_ref-Tuple{AbstractUnbalancedPowerModel, Int64}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_inverter_theta_ref","text":"constraint_mc_inverter_theta_ref(pm::AbstractUnbalancedPowerModel; nw::Int=nw_id_default)\n\nTemplate function for setting the reference bus theta constraint to only the bus with a grid-forming inverter\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_power_balance_shed_block-Tuple{AbstractUnbalancedPowerModel, Int64}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_power_balance_shed_block","text":"constraint_mc_power_balance_shed_block(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)\n\nTemplate function for power balance constraints for block load shed.\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_power_balance_shed_traditional-Tuple{AbstractUnbalancedPowerModel, Int64}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_power_balance_shed_traditional","text":"constraint_mc_power_balance_shed_traditional(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)\n\nTemplate function for power balance constraints for traditional load shed.\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_storage_block_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_storage_block_on_off","text":"constraint_mc_storage_block_on_off(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)\n\nTemplate function for storage block on/off constraint\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_storage_losses_block_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_storage_losses_block_on_off","text":"constraint_mc_storage_losses_block_on_off(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)\n\nTemplate function for storage losses block on/off constraint.\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_storage_losses_traditional_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_storage_losses_traditional_on_off","text":"constraint_mc_storage_losses_traditional_on_off(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)\n\nTemplate function for storage losses traditional on/off constraint.\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_storage_phase_unbalance-Tuple{AbstractUnbalancedPowerModel, Int64}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_storage_phase_unbalance","text":"constraint_mc_storage_phase_unbalance(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)\n\nConstraint template for constraint to enforce balance between phases of ps/qs on storage.\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_storage_phase_unbalance_grid_following-Tuple{AbstractUnbalancedPowerModel, Int64}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_storage_phase_unbalance_grid_following","text":"constraint_mc_storage_phase_unbalance_grid_following(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)\n\nConstraint template for constraint to enforce balance between phases of ps/qs on storage for grid-following inverters only. Requires z_inverter variables to indicate if a DER is grid-forming or grid-following\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_storage_traditional_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_storage_traditional_on_off","text":"constraint_mc_storage_traditional_on_off(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)\n\nTemplate function for storage traditional on/off constraint.\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_switch_open_voltage_distance-Tuple{AbstractUnbalancedPowerModel, Int64}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_switch_open_voltage_distance","text":"constraint_mc_switch_open_voltage_distance(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)\n\nTemplate function for constraint to encourage voltage matching at partition boundaries\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_switch_state_open_close-Tuple{AbstractUnbalancedPowerModel, Int64}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_switch_state_open_close","text":"constraint_mc_switch_state_open_close(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)\n\nVoltage and power constraints for open/close switches\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_transformer_power_block_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_transformer_power_block_on_off","text":"constraint_mc_transformer_power_block_on_off(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default, fix_taps::Bool=true)\n\nTemplate function for transformer power constraints for block mld problem.\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_transformer_power_traditional_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_transformer_power_traditional_on_off","text":"constraint_mc_transformer_power_traditional_on_off(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default, fix_taps::Bool=true)\n\nTemplate function for transformer power constraints for traditional mld problem.\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_radial_topology-Tuple{AbstractUnbalancedPowerModel}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_radial_topology","text":"constraint_radial_topology(pm::AbstractUnbalancedPowerModel; nw::Int=nw_id_default, relax::Bool=false)\n\nTemplate function radial topology constraint.\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_storage_complementarity_mi_block_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_storage_complementarity_mi_block_on_off","text":"constraint_storage_complementarity_mi_block_on_off(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)\n\nTemplate function for mixed-integer storage complementarity constraints.\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_storage_complementarity_mi_traditional_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_storage_complementarity_mi_traditional_on_off","text":"constraint_storage_complementarity_mi_traditional_on_off(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)\n\nTemplate function for mixed-integer storage complementarity constraints.\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_switch_close_action_limit-Tuple{AbstractUnbalancedPowerModel}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_switch_close_action_limit","text":"constraint_switch_close_action_limit(pm::AbstractUnbalancedPowerModel; nw::Int=nw_id_default)\n\nTemplate function for constraint of maximum switch closes per timestep (allows unlimited switch opens).\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_disable_networking-Tuple{AbstractUnbalancedPowerModel, Int64}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_disable_networking","text":"constraint_disable_networking(pm::AbstractUnbalancedPowerModel, nw::Int; relax::Bool=false)\n\nConstrains each microgrid to not network with another microgrid, while still allowing them to expand.\n\nbeginalign\nsum_k in cal L y^k_ab = 1 forall ab in cal S\ny^k_ab - (1 - z_ab) le x_k^mg le  y^k_ab + (1 - z_ab) forall k in cal L\ny^k_dc - (1 - z_dc) - (1 - z_ab) le y^k_ab le  y^k_dc + (1 - z_dc) + (1 - z_ab) forall k in cal L forall ab in cal T_k forall dc in cal T_ksetminus ab\nendalign\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_energized_blocks_strictly_increasing-Tuple{AbstractUnbalancedPowerModel, Int64, Int64}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_energized_blocks_strictly_increasing","text":"constraint_energized_blocks_strictly_increasing(pm::AbstractUnbalancedPowerModel, n_1::Int, n_2::Int)\n\nConstraint to ensure that the number of energized load blocks from one timestep to another is strictly increasing and that once energized, a load block cannot be shed in a later timestep.\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_grid_forming_inverter_per_cc_block-Tuple{AbstractUnbalancedPowerModel, Int64}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_grid_forming_inverter_per_cc_block","text":"constraint_grid_forming_inverter_per_cc(pm::AbstractUnbalancedPowerModel, nw::Int; relax::Bool=false)\n\nConstrains each connected component of the load block graph to have only one grid-forming inverter, if the block is enabled\n\nbeginalign\n sum_k in cal B y^k_ab le z^sw_ab forall ab in cal E_sw \n sum_ab in cal T_k (1-z^sw_ab) - cal T_k + z^bl_k le sum_i in cal D_k z^inv_i le z^bl_k  forall k in cal B \n S^g_i le overlineS^g_i (sum_ab in cal T_k z^sw_ab + sum_j in cal D_k z^inv_j)  forall i in cal G \n S^g_i le overlineS^g_i (sum_ab in cal T_k sum_k in cal B y_ab^k + sum_j in cal D_k z^sw_j)  forall i in cal G \n S^g_i ge underlineS^g_i (sum_ab in cal T_k z^sw_ab + sum_j in cal D_k z^inv_j)  forall i in cal G \n S^g_i ge underlineS^g_i (sum_ab in cal T_k sum_k in cal B y_ab^k + sum_j in cal D_k z^sw_j)  forall i in cal G \n y^k_ab - (1 - z^sw_ab) le sum_i in cal D_k z^inv_i le  y^k_ab + (1 - z^sw_ab)  forall k in cal Bforall ab in cal E_sw \n y^k_dc - (1 - z^sw_dc) - (1 - z^sw_ab) le y^k_ab le  y^k_dc + (1 - z^sw_dc) + (1 - z^sw_ab) \n  forall k in cal Bforall k in cal Bkforall ab in cal E_swforall dc in cal E_swab nonumber \n y_ab^k le sum_i in cal D_k z^inv_i  forall k in cal Bforall ab in cal E_sw \n -z^sw_ab cal B le f_ab^k le z^sw_ab cal B  forall k in cal Bforall ab in cal E_sw \n 0 le xi_ab^k le 1  forall k in cal Bforall ab in cal E_sw \n sum_ab in cal T_k  a = k f_ab^k - sum_ab in cal T_k  b = k f_ab^k + sum_ab in cal E_v^k xi_ab^k = cal B - 1  forall k in cal B \n sum_ab in cal T_k  a = k f_ab^k - sum_ab in cal T_k  b = k f_ab^k  -  xi_kk^k = -1  forall k ne k  forall k in cal B \n y_ab^k le 1 - xi_kk^k  forall k ne k ab in cal T_k \n z^bl_k le sum_i in cal D_k z^inv_i + sum_ab in cal T_k  sum_k in cal B y^k_ab\nendalign\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_grid_forming_inverter_per_cc_traditional-Tuple{AbstractUnbalancedPowerModel, Int64}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_grid_forming_inverter_per_cc_traditional","text":"constraint_grid_forming_inverter_per_cc_traditional(pm::AbstractUnbalancedPowerModel, nw::Int; relax::Bool=false)\n\nConstrains each connected component of the graph to have only one grid-forming inverter, if the component is enabled\n\nbeginalign\n sum_k in cal B y^k_ab le z^sw_ab forall ab in cal E_sw \n sum_ab in cal T_k (1-z^sw_ab) - cal T_k + 1 le sum_i in cal D_k z^inv_i le 1  forall k in cal B \n S^g_i le overlineS^g_i (sum_ab in cal T_k z^sw_ab + sum_j in cal D_k z^inv_j)  forall i in cal G \n S^g_i le overlineS^g_i (sum_ab in cal T_k sum_k in cal B y_ab^k + sum_j in cal D_k z^sw_j)  forall i in cal G \n S^g_i ge underlineS^g_i (sum_ab in cal T_k z^sw_ab + sum_j in cal D_k z^inv_j)  forall i in cal G \n S^g_i ge underlineS^g_i (sum_ab in cal T_k sum_k in cal B y_ab^k + sum_j in cal D_k z^sw_j)  forall i in cal G \n y^k_ab - (1 - z^sw_ab) le sum_i in cal D_k z^inv_i le  y^k_ab + (1 - z^sw_ab)  forall k in cal Bforall ab in cal E_sw \n y^k_dc - (1 - z^sw_dc) - (1 - z^sw_ab) le y^k_ab le  y^k_dc + (1 - z^sw_dc) + (1 - z^sw_ab) \n  forall k in cal Bforall k in cal Bkforall ab in cal E_swforall dc in cal E_swab nonumber \n y_ab^k le sum_i in cal D_k z^inv_i  forall k in cal Bforall ab in cal E_sw \n -z^sw_ab cal B le f_ab^k le z^sw_ab cal B  forall k in cal Bforall ab in cal E_sw \n 0 le xi_ab^k le 1  forall k in cal Bforall ab in cal E_sw \n sum_ab in cal T_k  a = k f_ab^k - sum_ab in cal T_k  b = k f_ab^k + sum_ab in cal E_v^k xi_ab^k = cal B - 1  forall k in cal B \n sum_ab in cal T_k  a = k f_ab^k - sum_ab in cal T_k  b = k f_ab^k  -  xi_kk^k = -1  forall k ne k  forall k in cal B \n y_ab^k le 1 - xi_kk^k  forall k ne k ab in cal T_k \nendalign\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_isolate_block-Tuple{AbstractUnbalancedPowerModel, Int64}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_isolate_block","text":"constraint_isolate_block(pm::AbstractUnbalancedPowerModel, nw::Int)\n\nconstraint to ensure that blocks get properly isolated by open switches by comparing the states of two neighboring blocks. If the neighboring block indicators are not either both 0 or both 1, the switch between them should be OPEN (0)\n\nbeginalign*\n (z^bl_fr - z^bl_to) leq  gamma_i forall i in S \n (z^bl_fr - z^bl_fr) geq - gamma_i forall i in S \n z^bl_b leq N_gen + N_strg + N_neg load + sum_i in S in b gamma_i forall b in B\nendalign*\n\nwhere z^bl_fr and z^bl_to are the indicator variables for the blocks on either side of switch i.\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_isolate_block_traditional-Tuple{AbstractUnbalancedPowerModel, Int64}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_isolate_block_traditional","text":"constraint_isolate_block_traditional(pm::AbstractUnbalancedPowerModel, nw::Int)\n\nConstraint to simulate block isolation constraint in the traditional mld problem\n\nbeginalign\n z^bus_fr - z^bus_to leq  (1-gamma_i) forall i in S \n z^bus_fr - z^bus_to geq -(1-gamma_i) forall i in S \n z^d_i leq z^d_j forall (ij) in D in B \n z^d_i leq z^bus_j forall i in D in B i in j in V in B \n z^bus_i leq z^bus_j forall (ij) in V in B \n z^bl_b leq N_gen + N_strg + N_neg load + sum_i in S in b in B gamma_i forall b in B\nendalign\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_generator_power_block_on_off-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{<:Int64}, Vector{<:Real}, Vector{<:Real}, Vector{<:Real}, Vector{<:Real}}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_generator_power_block_on_off","text":"constraint_mc_generator_power_block_on_off(\n    pm::AbstractUnbalancedPowerModel,\n    nw::Int,\n    i::Int,\n    connections::Vector{Int},\n    pmin::Vector{<:Real},\n    pmax::Vector{<:Real},\n    qmin::Vector{<:Real},\n    qmax::Vector{<:Real}\n)\n\nGeneric block mld on/off constraint for generator power\n\nbeginalign\nS_i geq z^bl_b S^lb_i i in b in B \nS_i leq z^bl_b S^ub_i i in b in B\nendalign\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_generator_power_traditional_on_off-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{<:Int64}, Vector{<:Real}, Vector{<:Real}, Vector{<:Real}, Vector{<:Real}}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_generator_power_traditional_on_off","text":"constraint_mc_generator_power_traditional_on_off(pm::AbstractUnbalancedPowerModel, nw::Int, i::Int, connections::Vector{Int}, pmin::Vector{<:Real}, pmax::Vector{<:Real}, qmin::Vector{<:Real}, qmax::Vector{<:Real})\n\nGeneric traditional mld on/off constraint for generator power\n\nbeginalign\nS_i geq z^gen_i S^lb_i \nS_i leq z^gen_i S^ub_i\nendalign\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_storage_block_on_off-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{Int64}, Real, Real, Real, Real, Real, Real}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_storage_block_on_off","text":"constraint_mc_storage_block_on_off(\n    pm::AbstractUnbalancedPowerModel,\n    nw::Int,\n    i::Int,\n    connections::Vector{Int},\n    pmin::Real,\n    pmax::Real,\n    qmin::Real,\n    qmax::Real,\n    charge_ub::Real,\n    discharge_ub::Real\n)\n\nblock on/off constraint for storage\n\nbeginalign\nsum_substackc in Gamma S_ic geq z^bl_b S^lb_i i in b in B \nsum_substackc in Gamma S_ic leq z^bl_b S^ub_i i in b in B\nendalign\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_storage_phase_unbalance-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{Int64}, Real}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_storage_phase_unbalance","text":"constraint_mc_storage_phase_unbalance(\n    pm::AbstractUnbalancedPowerModel,\n    nw::Int,\n    i::Int,\n    connections::Vector{Int},\n    unbalance_factor::Real\n)\n\nEnforces that storage inputs/outputs are (approximately) balanced across each phase, by some unbalance_factor\n\nS^strg_ic geq S^strg_id - f^unbal left( -d^on_i S^strg_id + c^on_i S^strg_id right) forall cd in C\nS^strg_ic leq S^strg_id + f^unbal left( -d^on_i S^strg_id + c^on_i S^strg_id right) forall cd in C\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_storage_phase_unbalance_grid_following-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{Int64}, Real}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_storage_phase_unbalance_grid_following","text":"constraint_mc_storage_phase_unbalance_grid_following(\n    pm::AbstractUnbalancedPowerModel,\n    nw::Int,\n    i::Int,\n    connections::Vector{Int},\n    unbalance_factor::Real\n)\n\nEnforces that storage inputs/outputs are (approximately) balanced across each phase, by some unbalance_factor on grid-following inverters only. Requires z_inverter variable\n\nS^strg_ic geq S^strg_id - f^unbal left( -d^on_i S^strg_id + c^on_i S^strg_id right) forall cd in C\nS^strg_ic leq S^strg_id + f^unbal left( -d^on_i S^strg_id + c^on_i S^strg_id right) forall cd in C\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_storage_traditional_on_off-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{Int64}, Real, Real, Real, Real, Real, Real}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_storage_traditional_on_off","text":"constraint_mc_storage_traditional_on_off(\n    pm::AbstractUnbalancedPowerModel,\n    nw::Int,\n    i::Int,\n    connections::Vector{Int},\n    pmin::Real,\n    pmax::Real,\n    qmin::Real,\n    qmax::Real,\n    charge_ub::Real,\n    discharge_ub::Real\n)\n\nTraditional on/off constraint for storage\n\nbeginalign\nsum_substackc in Gamma S_ic geq z^strg_i S^lb_i \nsum_substackc in Gamma S_ic leq z^strg_i S^ub_i\nendalign\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_switch_power_open_close-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_switch_power_open_close","text":"constraint_mc_switch_power_open_close(\n    pm::AbstractUnbalancedPowerModel,\n    nw::Int,\n    i::Int,\n    f_bus::Int,\n    t_bus::Int,\n    f_connections::Vector{Int},\n    t_connections::Vector{Int}\n)\n\ngeneric switch power open/closed constraint\n\nbeginalign\n S^sw_ic leq S^swu_ic z^sw_i forall i in Sforall c in C \n S^sw_ic geq -S^swu_ic z^sw_i forall i in Sforall c in C\nendalign\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_radial_topology-Tuple{AbstractUnbalancedPowerModel, Int64}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_radial_topology","text":"constraint_radial_topology(pm::AbstractUnbalancedPowerModel, nw::Int; relax::Bool=false)\n\nConstraint to enforce a radial topology\n\nSee 10.1109/TSG.2020.2985087\n\nbeginalign\nmathbfbeta in mathbfOmega \nalpha_ij leq beta_ijforall(ij) in L \nsum_substack(ji_r)in Lf^k_ji_r - sum_substack(i_rj)in Lf^k_i_rj=-1forall k in Nsetminus i_r \nsum_substack(jk)in Lf^k_jk - sum_substack(kj)in Lf^k_kj = 1forall k in Nsetminus i_r \nsum_substack(ji)in Lf^k_ji-sum_substack(ij)in Lf^k_ij=0forall k in Nsetminus i_rforall i in Nsetminus i_rk \n0 leq f^k_ij leq lambda_ij0 leq f^k_ji leq lambda_jiforall k in Nsetminus i_rforall(ij)in L \nsum_substack(ij)in Lleft(lambda_ij + lambda_ji right ) = left  N right  - 1 \nlambda_ij + lambda_ji = beta_ijforall(ij)in L \nlambda_ijlambda_jiinleft  01 right forall(ij)in L\nendalign\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_storage_complementarity_mi_block_on_off-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Real, Real}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_storage_complementarity_mi_block_on_off","text":"constraint_storage_complementarity_mi_block_on_off(\n    pm::AbstractUnbalancedPowerModel,\n    n::Int,\n    i::Int,\n    charge_ub::Real,\n    discharge_ub::Real\n)\n\nNonlinear storage complementarity mi constraint for block mld problem.\n\nmath``` \\begin{align} c^{on}i * d^{on}i == z^{bl}b, i \\in {b \\in B} \\\nc^{on}i c^{ub}i \\geq ci \\\nd^{on}i d^{ub}i \\geq d_i \\end{align} ```\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_storage_complementarity_mi_traditional_on_off-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Real, Real}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_storage_complementarity_mi_traditional_on_off","text":"constraint_storage_complementarity_mi_traditional_on_off(\n    pm::AbstractUnbalancedPowerModel,\n    n::Int,\n    i::Int,\n    charge_ub::Real,\n    discharge_ub::Real\n)\n\nNonlinear storage complementarity mi constraint for traditional mld problem.\n\nmath``` \\begin{align} c^{on}i d^{on}i = z^{strg}i \\\nc^{on}i c^{ub}i \\geq ci \\\nd^{on}i d^{ub}i \\geq d_i \\end{align} ```\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_switch_close_action_limit-Tuple{AbstractUnbalancedPowerModel, Int64, Int64}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_switch_close_action_limit","text":"constraint_switch_close_action_limit(pm::AbstractUnbalancedPowerModel, nw_1::Int, nw_2::Int)\n\nConstraint for maximum allowed switch close actions between time steps, as defined by ref(pm, nw, :switch_close_actions_ub)\n\nbeginalign\nDelta^gamma_i forall i in S  \ngamma^t_i forall i in S forall t in T   \ngamma^t_1t_2_i forall i in S forall (t_1t_2) in T   \nst   \n gamma^t_1t_2_i geq 0 \n gamma^t_1t_2_i geq gamma^t_2_i + gamma^t_1_i - 1 \n gamma^t_1t_2_i leq gammat_1_i \n gamma^t_1t_2_i leq gammat_2_i \n Delta^gamma_i geq gamma^t_2+i - gamma^t_1t_2_i \n Delta^gamma_i geq gamma^t_2+i + gamma^t_1t_2_i \n sum_substacki in S Delta^gamma_i leq N_gamma=1^ub\nendalign\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_switch_close_action_limit-Tuple{AbstractUnbalancedPowerModel, Int64}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_switch_close_action_limit","text":"constraint_switch_close_action_limit(pm::AbstractUnbalancedPowerModel, nw::Int)\n\nConstraint for maximum allowed switch close actions in a single time step, as defined by ref(pm, nw, :switch_close_actions_ub)\n\nbeginalign\nDelta^gamma_iforall i in S  \nst  \n Delta^gamma_i geq gamma left( 1 - gamma_0 right) \n Delta^gamma_i geq -gamma left( 1 - gamma_0 right) \n sum_substacki in S Delta^gamma_i leq N_gamma=1^ub\nendalign\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_bus_voltage_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACPModel, Int64, Int64, Vector{<:Real}, Vector{<:Real}}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_bus_voltage_block_on_off","text":"\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_bus_voltage_magnitude_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACPModel, Int64, Int64, Vector{<:Real}, Vector{<:Real}}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_bus_voltage_magnitude_block_on_off","text":"constraint_mc_bus_voltage_magnitude_block_on_off(pm::PMD.AbstractUnbalancedACPModel, nw::Int, i::Int, vmin::Vector{<:Real}, vmax::Vector{<:Real})\n\non/off bus voltage magnitude block constraint for relaxed formulations\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_bus_voltage_magnitude_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACPModel, Int64, Int64, Vector{<:Real}, Vector{<:Real}}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_bus_voltage_magnitude_traditional_on_off","text":"constraint_mc_bus_voltage_magnitude_traditional_on_off(pm::PMD.AbstractUnbalancedACPModel, nw::Int, i::Int, vmin::Vector{<:Real}, vmax::Vector{<:Real})\n\non/off bus voltage magnitude traditional constraint for relaxed formulations\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_bus_voltage_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACPModel, Int64, Int64, Vector{<:Real}, Vector{<:Real}}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_bus_voltage_traditional_on_off","text":"\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_power_balance_shed_block-Tuple{PowerModelsDistribution.AbstractUnbalancedACPModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_power_balance_shed_block","text":"constraint_mc_power_balance_shed_block(pm::PMD.AbstractUnbalancedACPModel, nw::Int, i::Int,\n    terminals::Vector{Int}, grounded::Vector{Bool}, bus_arcs::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}},\n    bus_arcs_sw::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_trans::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}},\n    bus_gens::Vector{Tuple{Int,Vector{Int}}}, bus_storage::Vector{Tuple{Int,Vector{Int}}},\n    bus_loads::Vector{Tuple{Int,Vector{Int}}}, bus_shunts::Vector{Tuple{Int,Vector{Int}}}\n)\n\nKCL for block load shed problem with transformers (ACPU Form)\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_storage_losses_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACPModel, Int64, Int64, Int64, Vector{Int64}, Real, Real, Real, Real}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_storage_losses_block_on_off","text":"constraint_mc_storage_losses_block_on_off(pm::PMD.AbstractUnbalancedACPModel, nw::Int, i::Int, bus::Int, connections::Vector{Int}, r::Real, x::Real, p_loss::Real, q_loss::Real)\n\nNon-linear storage loss constraint\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_storage_losses_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACPModel, Int64, Int64, Int64, Vector{Int64}, Real, Real, Real, Real}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_storage_losses_traditional_on_off","text":"constraint_mc_storage_losses_traditional_on_off(pm::PMD.AbstractUnbalancedACPModel, nw::Int, i::Int, bus::Int, connections::Vector{Int}, r::Real, x::Real, p_loss::Real, q_loss::Real)\n\nNon-linear storage loss constraint\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_switch_voltage_open_close-Tuple{PowerModelsDistribution.AbstractUnbalancedACPModel, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_switch_voltage_open_close","text":"constraint_mc_switch_state_voltage_open_closed(pm::PMD.AbstractUnbalancedACPModel, nw::Int, i::Int, f_bus::Int, t_bus::Int, f_connections::Vector{Int}, t_connections::Vector{Int})\n\nLinear switch power on/off constraint for ACPU form.\n\nbeginalign\n V^fr_ic - V^to_ic leq left ( v^u_ic - v^l_ic right ) left ( 1 - z^sw_i right ) forall i in Sforall c in C \n V^fr_ic - V^to_ic geq -left ( v^u_ic - v^l_ic right ) left ( 1 - z^sw_i right ) forall i in Sforall c in C \n\nendalign\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_transformer_power_yy_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACPModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{<:Real}, Vector{Bool}, Real}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_transformer_power_yy_block_on_off","text":"constraint_mc_transformer_power_yy_on_off(\n    pm::PMD.AbstractUnbalancedACPModel,\n    nw::Int,\n    trans_id::Int,\n    f_bus::Int,\n    t_bus::Int,\n    f_idx::Tuple{Int,Int,Int},\n    t_idx::Tuple{Int,Int,Int},\n    f_connections::Vector{Int},\n    t_connections::Vector{Int},\n    pol::Int,\n    tm_set::Vector{<:Real},\n    tm_fixed::Vector{Bool},\n    tm_scale::Real\n)\n\nLinks to and from power and voltages in a wye-wye transformer, assumes tm_fixed is true\n\nw_fr_i=(pol_i*tm_scale*tm_i)^2w_to_i\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_bus_voltage_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACRModel, Int64, Int64, Vector{<:Real}, Vector{<:Real}}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_bus_voltage_block_on_off","text":"\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_bus_voltage_magnitude_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACRModel, Int64, Int64, Vector{<:Real}, Vector{<:Real}}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_bus_voltage_magnitude_block_on_off","text":"constraint_mc_bus_voltage_magnitude_block_on_off(pm::PMD.AbstractUnbalancedACRModel, nw::Int, i::Int, vmin::Vector{<:Real}, vmax::Vector{<:Real})\n\non/off block bus voltage magnitude squared constraint for ac-rect form\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_bus_voltage_magnitude_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACRModel, Int64, Int64, Vector{<:Real}, Vector{<:Real}}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_bus_voltage_magnitude_traditional_on_off","text":"constraint_mc_bus_voltage_magnitude_traditional_on_off(pm::PMD.AbstractUnbalancedACRModel, nw::Int, i::Int, vmin::Vector{<:Real}, vmax::Vector{<:Real})\n\non/off block bus voltage magnitude squared constraint for ac-rect form\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_bus_voltage_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACRModel, Int64, Int64, Vector{<:Real}, Vector{<:Real}}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_bus_voltage_traditional_on_off","text":"\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_inverter_theta_ref-Tuple{PowerModelsDistribution.AbstractUnbalancedACRModel, Int64, Int64, Vector{<:Real}}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_inverter_theta_ref","text":"constraint_mc_inverter_theta_ref(pm::PMD.AbstractUnbalancedACRModel, nw::Int, i::Int, va_ref::Vector{<:Real})\n\nCreates phase angle constraints at reference buses for the ACR formulation\n\nmath\\begin{align} \\Im(V) = \\tan(V_a^{ref}) \\Re(V) \\end{align}\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_power_balance_shed_block-Tuple{PowerModelsDistribution.AbstractUnbalancedACRModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_power_balance_shed_block","text":"constraint_mc_power_balance_shed_block(pm::PMD.AbstractUnbalancedACRModel, nw::Int, i::Int,\n    terminals::Vector{Int}, grounded::Vector{Bool}, bus_arcs::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}},\n    bus_arcs_sw::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_trans::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}},\n    bus_gens::Vector{Tuple{Int,Vector{Int}}}, bus_storage::Vector{Tuple{Int,Vector{Int}}},\n    bus_loads::Vector{Tuple{Int,Vector{Int}}}, bus_shunts::Vector{Tuple{Int,Vector{Int}}}\n)\n\nKCL for block load shed problem with transformers (ac-rect form)\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_storage_losses_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACRModel, Int64, Int64, Int64, Vector{Int64}, Real, Real, Real, Real}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_storage_losses_block_on_off","text":"constraint_mc_storage_losses_block_on_off(pm::PMD.AbstractUnbalancedACRModel, nw::Int, i::Int, bus::Int, connections::Vector{Int}, r::Real, x::Real, p_loss::Real, q_loss::Real)\n\nNonlinear storage losses constraint for ac-rect form.\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_storage_losses_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACRModel, Int64, Int64, Int64, Vector{Int64}, Real, Real, Real, Real}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_storage_losses_traditional_on_off","text":"constraint_mc_storage_losses_traditional_on_off(pm::PMD.AbstractUnbalancedACRModel, nw::Int, i::Int, bus::Int, connections::Vector{Int}, r::Real, x::Real, p_loss::Real, q_loss::Real)\n\nNonlinear storage losses constraint for ac-rect form.\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_switch_voltage_open_close-Tuple{PowerModelsDistribution.AbstractUnbalancedACRModel, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_switch_voltage_open_close","text":"constraint_mc_switch_voltage_open_close(pm::PMD.AbstractUnbalancedACRModel, nw::Int, i::Int, f_bus::Int, t_bus::Int, f_connections::Vector{Int}, t_connections::Vector{Int})\n\nnonlinear switch power on/off constraint for ac-rect form\n\nbeginalign\n \n\nendalign\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_transformer_power_yy_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{<:Real}, Vector{Bool}, Real}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_transformer_power_yy_block_on_off","text":"constraint_mc_transformer_power_yy_block_on_off(\n    pm::PMD.AbstractUnbalancedACRModel,\n    nw::Int,\n    trans_id::Int,\n    f_bus::Int,\n    t_bus::Int,\n    f_idx::Tuple{Int,Int,Int},\n    t_idx::Tuple{Int,Int,Int},\n    f_connections::Vector{Int},\n    t_connections::Vector{Int},\n    pol::Int,\n    tm_set::Vector{<:Real},\n    tm_fixed::Vector{Bool},\n    tm_scale::Real\n)\n\nLinks to and from power and voltages in a wye-wye transformer, assumes tm_fixed is true\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_bus_voltage_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Vector{<:Real}, Vector{<:Real}}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_bus_voltage_block_on_off","text":"do nothing, no voltage variables\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_bus_voltage_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Vector{<:Real}, Vector{<:Real}}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_bus_voltage_traditional_on_off","text":"do nothing, no voltage variables\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_generator_power_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Vector{<:Int64}, Vector{<:Real}, Vector{<:Real}, Vector{<:Real}, Vector{<:Real}}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_generator_power_block_on_off","text":"constraint_mc_generator_power_block_on_off(pm::PMD.AbstractUnbalancedNFAModel, nw::Int, i::Int, connections::Vector{Int}, pmin::Vector{<:Real}, pmax::Vector{<:Real}, ::Vector{<:Real}, ::Vector{<:Real})\n\non/off block constraint for generators for NFA model\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_generator_power_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Vector{<:Int64}, Vector{<:Real}, Vector{<:Real}, Vector{<:Real}, Vector{<:Real}}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_generator_power_traditional_on_off","text":"constraint_mc_generator_power_traditional_on_off(pm::PMD.AbstractUnbalancedNFAModel, nw::Int, i::Int, connections::Vector{Int}, pmin::Vector{<:Real}, pmax::Vector{<:Real}, ::Vector{<:Real}, ::Vector{<:Real})\n\non/off traditional constraint for generators for NFAU form\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_inverter_theta_ref-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_inverter_theta_ref","text":"nothing to do, no voltage angle variables\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_power_balance_shed_block-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_power_balance_shed_block","text":"constraint_mc_power_balance_shed_block(pm::PMD.AbstractUnbalancedNFAModel, nw::Int, i::Int,\n    terminals::Vector{Int}, grounded::Vector{Bool}, bus_arcs::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}},\n    bus_arcs_sw::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_trans::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}},\n    bus_gens::Vector{Tuple{Int,Vector{Int}}}, bus_storage::Vector{Tuple{Int,Vector{Int}}},\n    bus_loads::Vector{Tuple{Int,Vector{Int}}}, bus_shunts::Vector{Tuple{Int,Vector{Int}}}\n)\n\nKCL for block load shed problem with transformers (NFAU Form)\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_power_balance_shed_traditional-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_power_balance_shed_traditional","text":"constraint_mc_power_balance_shed_traditional(pm::PMD.AbstractUnbalancedNFAModel, nw::Int, i::Int,\n    terminals::Vector{Int}, grounded::Vector{Bool}, bus_arcs::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}},\n    bus_arcs_sw::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_trans::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}},\n    bus_gens::Vector{Tuple{Int,Vector{Int}}}, bus_storage::Vector{Tuple{Int,Vector{Int}}},\n    bus_loads::Vector{Tuple{Int,Vector{Int}}}, bus_shunts::Vector{Tuple{Int,Vector{Int}}}\n)\n\nKCL for traditional load shed problem with transformers (NFAU Form)\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_storage_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Vector{Int64}, Real, Real, Real, Real, Real, Real}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_storage_block_on_off","text":"constraint_mc_storage_block_on_off(pm::PMD.AbstractUnbalancedNFAModel, nw::Int, i::Int, connections::Vector{Int}, pmin::Real, pmax::Real, ::Real, ::Real, ::Real, ::Real)\n\nblock on/off constraint for storage in NFAU Form.\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_storage_losses_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Int64, Vector{Int64}, Real, Real, Real, Real}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_storage_losses_block_on_off","text":"constraint_mc_storage_losses_block_on_off(pm::PMD.AbstractUnbalancedNFAModel, nw::Int, i::Int, bus::Int, connections::Vector{Int}, ::Real, ::Real, ::Real, ::Real)\n\nNeglects all losses (lossless model), NFAU Form.\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_storage_losses_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Int64, Vector{Int64}, Real, Real, Real, Real}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_storage_losses_traditional_on_off","text":"constraint_mc_storage_losses_traditional_on_off(pm::PMD.AbstractUnbalancedNFAModel, nw::Int, i::Int, bus::Int, connections::Vector{Int}, ::Real, ::Real, ::Real, ::Real)\n\nNeglects all losses (lossless model), NFAU Form.\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_storage_phase_unbalance_grid_following-Tuple{PowerModelsDistribution.AbstractUnbalancedActivePowerModel, Int64, Int64, Vector{Int64}, Real}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_storage_phase_unbalance_grid_following","text":"constraint_mc_storage_phase_unbalance_grid_following(\n    pm::AbstractUnbalancedPowerModel,\n    nw::Int,\n    i::Int,\n    connections::Vector{Int},\n    unbalance_factor::Real\n)\n\nEnforces that storage inputs/outputs are (approximately) balanced across each phase, by some unbalance_factor on grid-following inverters only. Requires z_inverter variable. Variant for Active Power Only models.\n\nS^strg_ic geq S^strg_id - f^unbal left( -d^on_i S^strg_id + c^on_i S^strg_id right) forall cd in C\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_storage_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Vector{Int64}, Real, Real, Real, Real, Real, Real}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_storage_traditional_on_off","text":"constraint_mc_storage_traditional_on_off(pm::PMD.AbstractUnbalancedNFAModel, nw::Int, i::Int, connections::Vector{Int}, pmin::Real, pmax::Real, ::Real, ::Real, ::Real, ::Real)\n\ntraditional on/off constraint for storage in NFAU Form.\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_switch_open_voltage_distance-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}, Real, Real}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_switch_open_voltage_distance","text":"do nothing, no voltage variables\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_switch_power_open_close-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_switch_power_open_close","text":"constraint_mc_switch_power_open_close(pm::PMD.AbstractUnbalancedNFAModel, nw::Int, i::Int, f_bus::Int, t_bus::Int, f_connections::Vector{Int}, t_connections::Vector{Int})\n\nLinear switch power on/off constraint for Active Power Only Models. If relax, an indicator constraint is used.\n\nbeginalign\n P^sw_ic leq P^swu_ic z^sw_i forall i in Pforall c in C \n P^sw_ic geq -P^swu_ic z^sw_i forall i in Pforall c in C\nendalign\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_switch_voltage_open_close-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_switch_voltage_open_close","text":"constraint_mc_switch_voltage_open_close(pm::PMD.AbstractUnbalancedNFAModel, nw::Int, i::Int, f_bus::Int, t_bus::Int, f_connections::Vector{Int}, t_connections::Vector{Int})\n\nNo voltage variables, do nothing\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_transformer_power_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_transformer_power_block_on_off","text":"constraint_mc_transformer_power_block_on_off(pm::PMD.AbstractUnbalancedNFAModel, i::Int; nw::Int=nw_id_default, fix_taps::Bool=false)\n\ntransformer active power only constraint pf=-pt\n\np_ffc == -pttc\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_transformer_power_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_transformer_power_traditional_on_off","text":"\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_storage_complementarity_mi_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Real, Real}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_storage_complementarity_mi_block_on_off","text":"constraint_storage_complementarity_mi_block_on_off(pm::Union{PMD.LPUBFDiagModel,PMD.AbstractUnbalancedNFAModel}, n::Int, i::Int, charge_ub::Real, discharge_ub::Real)\n\nlinear storage complementarity mi constraint for block mld problem\n\nmathsc_{on} + sd_{on} == z_{block}\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_storage_complementarity_mi_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Real, Real}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_storage_complementarity_mi_traditional_on_off","text":"constraint_storage_complementarity_mi_traditional_on_off(\n    pm::Union{PMD.LPUBFDiagModel,PMD.AbstractUnbalancedNFAModel},\n    n::Int,\n    i::Int,\n    charge_ub::Real,\n    discharge_ub::Real\n)\n\nlinear storage complementarity mi constraint for traditional mld problem\n\nmathsc_{on} + sd_{on} == z_{block}\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_inverter_theta_ref-Tuple{PowerModelsDistribution.LPUBFDiagModel, Int64, Int64, Vector{<:Real}}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_inverter_theta_ref","text":"constraint_mc_inverter_theta_ref(pm::PMD.LPUBFDiagModel, nw::Int, i::Int, ::Vector{<:Real})\n\nConstrains a bus with a connected grid-forming inverter to have a reference bus constraint\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_load_power_block_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_load_power_block_on_off","text":"Default to PowerModelsDistribution.constraintmcload_power\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_load_power_block_on_off-Tuple{PowerModelsDistribution.LPUBFDiagModel, Int64}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_load_power_block_on_off","text":"constraint_mc_load_power(pm::LPUBFDiagModel, load_id::Int; nw::Int=nw_id_default, report::Bool=true)\n\nDelta/voltage-dependent load models for LPUBFDiagModel. Delta loads use the auxilary power variable (X). The constant current load model is derived by linearizing around the flat-start voltage solution.\n\nbeginalign\ntextConstant power Rightarrow P_i^d = P_i^d0Q_i^d = Q_i^d0 forall i in L \ntextConstant impedance (Wye) Rightarrow P_i^d = a_i cdot w_iQ_i^d = b_i cdot w_i forall i in L \ntextConstant impedance (Delta) Rightarrow P_i^d = 3cdot a_i cdot w_iQ_i^d = 3cdot b_i cdot w_i forall i in L \ntextConstant current (Wye) Rightarrow P_i^d = fraca_i2cdot left( 1+w_i right)Q_i^d = fracb_i2cdot left( 1+w_i right) forall i in L \ntextConstant current (Delta) Rightarrow P_i^d = fracsqrt3 cdot a_i2cdot left( 1+w_i right)Q_i^d = fracsqrt3 cdot b_i2cdot left( 1+w_i right) forall i in L\nendalign\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_load_power_block_scenario-Tuple{PowerModelsDistribution.LPUBFDiagModel, Int64, Int64}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_load_power_block_scenario","text":"constraint_mc_load_power(pm::PMD.LPUBFDiagModel, load_id::Int, scen::Int; nw::Int=nw_id_default, report::Bool=true)\n\nLoad models for LPUBFDiagModel (similar to PMD.constraintmcload_power) for robust mld problem. The constraints are different for each scenario.\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_load_power_traditional_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_load_power_traditional_on_off","text":"Default to PowerModelsDistribution.constraintmcload_power\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_load_power_traditional_on_off-Tuple{PowerModelsDistribution.LPUBFDiagModel, Int64}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_load_power_traditional_on_off","text":"constraint_mc_load_power(pm::LPUBFDiagModel, load_id::Int; nw::Int=nw_id_default, report::Bool=true)\n\nDelta/voltage-dependent load models for LPUBFDiagModel. Delta loads use the auxilary power variable (X). The constant current load model is derived by linearizing around the flat-start voltage solution.\n\nbeginalign\ntextConstant power Rightarrow P_i^d = P_i^d0Q_i^d = Q_i^d0 forall i in L \ntextConstant impedance (Wye) Rightarrow P_i^d = a_i cdot w_iQ_i^d = b_i cdot w_i forall i in L \ntextConstant impedance (Delta) Rightarrow P_i^d = 3cdot a_i cdot w_iQ_i^d = 3cdot b_i cdot w_i forall i in L \ntextConstant current (Wye) Rightarrow P_i^d = fraca_i2cdot left( 1+w_i right)Q_i^d = fracb_i2cdot left( 1+w_i right) forall i in L \ntextConstant current (Delta) Rightarrow P_i^d = fracsqrt3 cdot a_i2cdot left( 1+w_i right)Q_i^d = fracsqrt3 cdot b_i2cdot left( 1+w_i right) forall i in L\nendalign\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_power_balance_shed_block-Tuple{PowerModelsDistribution.LPUBFDiagModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_power_balance_shed_block","text":"constraint_mc_power_balance_shed_block(pm::PMD.LPUBFDiagModel, nw::Int, i::Int,\n    terminals::Vector{Int}, grounded::Vector{Bool}, bus_arcs::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}},\n    bus_arcs_sw::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_trans::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}},\n    bus_gens::Vector{Tuple{Int,Vector{Int}}}, bus_storage::Vector{Tuple{Int,Vector{Int}}},\n    bus_loads::Vector{Tuple{Int,Vector{Int}}}, bus_shunts::Vector{Tuple{Int,Vector{Int}}}\n)\n\nKCL for block load shed problem with transformers (LinDistFlow Form)\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_power_balance_shed_traditional-Tuple{PowerModelsDistribution.LPUBFDiagModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_power_balance_shed_traditional","text":"constraint_mc_power_balance_shed_traditional(pm::PMD.LPUBFDiagModel, nw::Int, i::Int, terminals::Vector{Int}, grounded::Vector{Bool}, bus_arcs::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_sw::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_trans::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_gens::Vector{Tuple{Int,Vector{Int}}}, bus_storage::Vector{Tuple{Int,Vector{Int}}}, bus_loads::Vector{Tuple{Int,Vector{Int}}}, bus_shunts::Vector{Tuple{Int,Vector{Int}}})\n\nKCL for traditional load shed problem with transformers (LinDistFlow Form)\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_storage_losses_block_on_off-Tuple{PowerModelsDistribution.LPUBFDiagModel, Int64, Int64, Int64, Vector{Int64}, Real, Real, Real, Real}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_storage_losses_block_on_off","text":"constraint_mc_storage_losses_block_on_off(pm::PMD.LPUBFDiagModel, nw::Int, i::Int, bus::Int, connections::Vector{Int}, r::Real, x::Real, p_loss::Real, q_loss::Real)\n\nNeglects the active and reactive loss terms associated with the squared current magnitude.\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_storage_losses_traditional_on_off-Tuple{PowerModelsDistribution.LPUBFDiagModel, Int64, Int64, Int64, Vector{Int64}, Real, Real, Real, Real}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_storage_losses_traditional_on_off","text":"constraint_mc_storage_losses_traditional_on_off(pm::PMD.LPUBFDiagModel, nw::Int, i::Int, bus::Int, connections::Vector{Int}, r::Real, x::Real, p_loss::Real, q_loss::Real)\n\nNeglects the active and reactive loss terms associated with the squared current magnitude.\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_switch_voltage_open_close-Tuple{PowerModelsDistribution.LPUBFDiagModel, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_switch_voltage_open_close","text":"constraint_mc_switch_voltage_open_close(pm::PMD.LPUBFDiagModel, nw::Int, i::Int, f_bus::Int, t_bus::Int, f_connections::Vector{Int}, t_connections::Vector{Int})\n\nLinear switch power on/off constraint for LPUBFDiagModel.\n\nbeginalign\n w^fr_ic - w^to_ic leq left ( v^u_ic right )^2 left ( 1 - z^sw_i right ) forall i in Sforall c in C \n w^fr_ic - w^to_ic geq -left ( v^u_icright )^2 left ( 1 - z^sw_i right ) forall i in Sforall c in C\nendalign\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_transformer_power_yy_block_on_off-Tuple{PowerModelsDistribution.LPUBFDiagModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{<:Real}, Vector{Bool}, Real}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_transformer_power_yy_block_on_off","text":"constraint_mc_transformer_power_yy_block_on_off(\n    pm::PMD.LPUBFDiagModel,\n    nw::Int,\n    trans_id::Int,\n    f_bus::Int,\n    t_bus::Int,\n    f_idx::Tuple{Int,Int,Int},\n    t_idx::Tuple{Int,Int,Int},\n    f_connections::Vector{Int},\n    t_connections::Vector{Int},\n    pol::Int,\n    tm_set::Vector{<:Real},\n    tm_fixed::Vector{Bool},\n    tm_scale::Real\n)\n\nLinks to and from power and voltages in a wye-wye transformer, assumes tm_fixed is true\n\nw_fr_i=(pol_i*tm_scale*tm_i)^2w_to_i\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_transformer_power_yy_traditional_on_off-Tuple{PowerModelsDistribution.LPUBFDiagModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{<:Real}, Vector{Bool}, Real}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_transformer_power_yy_traditional_on_off","text":"constraint_mc_transformer_power_yy_traditional_on_off(pm::PMD.LPUBFDiagModel, nw::Int, trans_id::Int, f_bus::Int, t_bus::Int, f_idx::Tuple{Int,Int,Int}, t_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, t_connections::Vector{Int}, pol::Int, tm_set::Vector{<:Real}, tm_fixed::Vector{Bool}, tm_scale::Real)\n\nLinks to and from power and voltages in a wye-wye transformer, assumes tm_fixed is true\n\nw_fr_i=(pol_i*tm_scale*tm_i)^2w_to_i\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_storage_complementarity_mi_block_on_off-Tuple{PowerModelsDistribution.LPUBFDiagModel, Int64, Int64, Real, Real}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_storage_complementarity_mi_block_on_off","text":"constraint_storage_complementarity_mi_block_on_off(pm::PMD.LPUBFDiagModel, n::Int, i::Int, charge_ub::Real, discharge_ub::Real)\n\nlinear storage complementarity mi constraint for block mld problem\n\nmathsc_{on} + sd_{on} == z_{block}\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_storage_complementarity_mi_traditional_on_off-Tuple{PowerModelsDistribution.LPUBFDiagModel, Int64, Int64, Real, Real}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_storage_complementarity_mi_traditional_on_off","text":"constraint_storage_complementarity_mi_traditional_on_off(pm::PMD.LPUBFDiagModel, n::Int, i::Int, charge_ub::Real, discharge_ub::Real)\n\nlinear storage complementarity mi constraint for traditional mld problem\n\nmathsc_{on} + sd_{on} == z_{block}\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_bus_voltage_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedWModels, Int64, Int64, Vector{<:Real}, Vector{<:Real}}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_bus_voltage_block_on_off","text":"constraint_mc_bus_voltage_block_on_off(pm::PMD.AbstractUnbalancedWModels, nw::Int, i::Int, vmin::Vector{<:Real}, vmax::Vector{<:Real})\n\nRedirects to constraint_mc_bus_voltage_magnitude_sqr_block_on_off for AbstractUnbalancedWModels\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_bus_voltage_magnitude_sqr_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedWModels, Int64, Int64, Vector{<:Real}, Vector{<:Real}}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_bus_voltage_magnitude_sqr_block_on_off","text":"constraint_mc_bus_voltage_magnitude_sqr_block_on_off(\n    pm::PMD.AbstractUnbalancedWModels,\n    nw::Int,\n    i::Int,\n    vmin::Vector{<:Real},\n    vmax::Vector{<:Real}\n)\n\non/off block bus voltage magnitude squared constraint for W models\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_bus_voltage_magnitude_sqr_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedWModels, Int64, Int64, Vector{<:Real}, Vector{<:Real}}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_bus_voltage_magnitude_sqr_traditional_on_off","text":"constraint_mc_bus_voltage_magnitude_sqr_traditional_on_off(\n    pm::PMD.AbstractUnbalancedWModels,\n    nw::Int,\n    i::Int,\n    vmin::Vector{<:Real},\n    vmax::Vector{<:Real}\n)\n\non/off traditional bus voltage magnitude squared constraint for W models\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_bus_voltage_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedWModels, Int64, Int64, Vector{<:Real}, Vector{<:Real}}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_bus_voltage_traditional_on_off","text":"constraint_mc_bus_voltage_traditional_on_off(pm::PMD.AbstractUnbalancedWModels, nw::Int, i::Int, vmin::Vector{<:Real}, vmax::Vector{<:Real})\n\nRedirects to constraint_mc_bus_voltage_magnitude_sqr_traditional_on_off for AbstractUnbalancedWModels\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_inverter_theta_ref-Tuple{PowerModelsDistribution.AbstractUnbalancedPolarModels, Int64, Int64, Vector{<:Real}}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_inverter_theta_ref","text":"constraint_mc_inverter_theta_ref(pm::PMD.AbstractUnbalancedPolarModels, nw::Int, i::Int, va_ref::Vector{<:Real})\n\nPhase angle constraints at reference buses for the Unbalanced Polar models\n\nmath\\begin{align*} V_a - V^{ref}_a \\leq 60^{\\circ} * (1-\\sum{z_{inv}}) V_a - V^{ref}_a \\geq -60^{\\circ} * (1-\\sum{z_{inv}}) \\end{align*}\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_switch_open_voltage_distance-Tuple{PowerModelsDistribution.AbstractUnbalancedPolarModels, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}, Real, Real}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_switch_open_voltage_distance","text":"constraint_mc_switch_open_voltage_distance(pm::PMD.AbstractUnbalancedPolarModels, nw::Int, i::Int, f_bus::Int, t_bus::Int, f_connections::Vector{Int}, t_connections::Vector{Int}, vm_delta_pu::Real, ::Real)\n\nConstraints for voltages on either side of an open switch to be within some distance of one another (provided by user) for Polar models math``` \\begin{align}     |V{i,\\phi}|-|V{j,\\phi}| &\\leq \\overline{\\delta}^{|V|}{k} + \\tau^{|V|}{k,\\phi},   \\; \\; & \\forall (i,j,k) \\in {\\cal E}{sw}^{\\mathrm{open}},\\forall \\phi \\in \\Phi \\\n    -\\left[|V{i,\\phi}|-|V{j,\\phi}|\\right] &\\leq \\overline{\\delta}^{|V|}{k} + \\tau^{|V|}{k,\\phi},   \\; \\; &\\forall (i,j,k) \\in {\\cal E}{sw}^{\\mathrm{open}},\\forall \\phi \\in \\Phi \\\n    \\angle V{i,\\phi}-\\angle V{j,\\phi} &\\leq \\overline{\\delta}^{\\angle V}{k} + \\tau^{\\angle V}{k,\\phi},   \\; \\; &\\forall (i,j,k) \\in {\\cal E}{sw}^{\\mathrm{open}},\\forall \\phi \\in \\Phi \\\n    -\\left[\\angle V{i,\\phi}-\\angle V{j,\\phi}\\right] &\\leq \\overline{\\delta}^{\\angle V}{k} + \\tau^{\\angle V}{k,\\phi},   \\; \\; &\\forall (i,j,k) \\in {\\cal E}{sw}^{\\mathrm{open}},\\forall \\phi \\in \\Phi \\end{align}\n\n\nmath```\n\\begin{align}\n        \\tau^{V}_{k,\\phi} = \\left(\\frac{\\tau^{|V|}_{k,\\phi}}{\\overline{\\delta}^{|V|}_{k,\\phi}}\\right)^2 +\\left(\\frac{\\tau^{\\angle V}_{k,\\phi}}{\\overline{\\delta}^{\\angle V}_{k,\\phi}}\\right)^2, \\; \\; \\forall (i,j,k) \\in {\\cal E}_{sw}^{\\mathrm{open}},\\forall \\phi \\in \\Phi\n\\end{align}\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_switch_open_voltage_distance-Tuple{PowerModelsDistribution.AbstractUnbalancedRectangularModels, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}, Real, Real}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_switch_open_voltage_distance","text":"constraint_mc_switch_open_voltage_distance(pm::PMD.AbstractUnbalancedRectangularModels, nw::Int, i::Int, f_bus::Int, t_bus::Int, f_connections::Vector{Int}, t_connections::Vector{Int}, vm_delta_pu::Real, ::Real)\n\nConstraints for voltages on either side of an open switch to be within some distance of one another (provided by user) for Rectangular models math``` \\begin{align}     \\sqrt{\\Re{V{i,\\phi}}^2 + \\Im{V{i,\\phi}}^2}-\\sqrt{\\Re{V{j,\\phi}}^2 + \\Im{V{j,\\phi}}^2} &\\leq \\overline{\\delta}^{|V|}{k} + \\tau^{|V|}{k,\\phi},   \\; \\; &\\forall (i,j,k) \\in {\\cal E}{sw}^{\\mathrm{open}},\\forall \\phi \\in \\Phi \\\n    -\\left[\\sqrt{\\Re{V{i,\\phi}}^2 + \\Im{V{i,\\phi}}^2}-\\sqrt{\\Re{V{j,\\phi}}^2 + \\Im{V{j,\\phi}}^2}\\right] &\\leq \\overline{\\delta}^{|V|}{k} + \\tau^{|V|}{k,\\phi},   \\; \\; &\\forall (i,j,k) \\in {\\cal E}{sw}^{\\mathrm{open}},\\forall \\phi \\in \\Phi \\\n    \\arctan{\\left(\\frac{\\Im{V{i,\\phi}}}{\\Re{V{i,\\phi}}}\\right)}-\\arctan{\\left(\\frac{\\Im{V{j,\\phi}}}{\\Re{V{j,\\phi}}}\\right)} &\\leq \\overline{\\delta}^{\\angle V}{k} + \\tau^{\\angle V}{k,\\phi},   \\; \\; &\\forall (i,j,k) \\in {\\cal E}{sw}^{\\mathrm{open}},\\forall \\phi \\in \\Phi \\\n    -\\left[\\arctan{\\left(\\frac{\\Im{V{i,\\phi}}}{\\Re{V{i,\\phi}}}\\right)}-\\arctan{\\left(\\frac{\\Im{V{j,\\phi}}}{\\Re{V{j,\\phi}}}\\right)}\\right] &\\leq \\overline{\\delta}^{\\angle V}{k} + \\tau^{\\angle V}{k,\\phi},   \\; \\; &\\forall (i,j,k) \\in {\\cal E}{sw}^{\\mathrm{open}},\\forall \\phi \\in \\Phi \\end{align}\n\n\nmath```\n\\begin{align}\n        \\tau^{V}_{k,\\phi} = \\left(\\frac{\\tau^{|V|}_{k,\\phi}}{\\overline{\\delta}^{|V|}_{k,\\phi}}\\right)^2 +\\left(\\frac{\\tau^{\\angle V}_{k,\\phi}}{\\overline{\\delta}^{\\angle V}_{k,\\phi}}\\right)^2, \\; \\; \\forall (i,j,k) \\in {\\cal E}_{sw}^{\\mathrm{open}},\\forall \\phi \\in \\Phi\n\\end{align}\n\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.constraint_mc_switch_open_voltage_distance-Tuple{PowerModelsDistribution.AbstractUnbalancedWModels, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}, Real, Real}","page":"Variables and Constraints","title":"PowerModelsONM.constraint_mc_switch_open_voltage_distance","text":"constraint_mc_switch_open_voltage_distance(pm::PMD.AbstractUnbalancedWModels, nw::Int, i::Int, f_bus::Int, t_bus::Int, f_connections::Vector{Int}, t_connections::Vector{Int}, vm_delta_pu::Real, ::Real)\n\nConstraints for voltages on either side of an open switch to be within some distance of one another (provided by user) for W models\n\nmath``` \\begin{align}     w{i,\\phi} - w{j,\\phi} &\\leq \\left(\\overline{\\delta}^{|V|}{k}\\right)^2 + \\tau^{w}{k,\\phi}, \\; \\; &\\forall (i,j,k) \\in {\\cal E}{sw}^{\\mathrm{open}},\\forall \\phi \\in \\Phi \\\n    -\\left[w{i,\\phi} - w{j,\\phi}\\right] &\\leq \\left(\\overline{\\delta}^{|V|}{k}\\right)^2 + \\tau^{w}{k,\\phi}, \\; \\; &\\forall (i,j,k) \\in {\\cal E}{sw}^{\\mathrm{open}},\\forall \\phi \\in \\Phi \\end{align}\n\n\nmath```\n\\begin{align}\n        \\tau^{V}_{k,\\phi} = \\frac{\\upsilon^{w}_{k,\\phi}}{\\left(\\overline{\\delta}^{|V|}_{k}\\right)^2}, \\; \\; \\forall (i,j,k) \\in {\\cal E}_{sw}^{\\mathrm{open}},\\forall \\phi \\in \\Phi\n\\end{align}\n\nwhere\n\nmath``` \\begin{align}     \\upsilon^{w}{k,\\phi} \\geq 2 (\\underline{\\tau}^{|V|}{k})^2 \\tau^{w}{k,\\phi} - (\\underline{\\tau}^{|V|}{k})^4 \\\n    \\upsilon^{w}{k,\\phi} \\geq 2 (\\overline{\\tau}^{|V|}{k})^2 \\tau^{w}{k,\\phi} - (\\overline{\\tau}^{|V|}{k})^4 \\\n    \\upsilon^{w}{k,\\phi} \\leq \\left((\\overline{\\tau}^{|V|}{k})^2 + (\\underline{\\tau}^{|V|}{k})^2\\right) \\tau^{w}{k,\\phi} - (\\overline{\\tau}^{|V|}{k})^2(\\underline{\\tau}^{|V|}{k})^2 \\\n\\end{align} ```\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#Objectives","page":"Variables and Constraints","title":"Objectives","text":"","category":"section"},{"location":"reference/variable_constraint.html","page":"Variables and Constraints","title":"Variables and Constraints","text":"Modules = [PowerModelsONM]\nPrivate = false\nOrder = [:function]\nPages = [\"objective.jl\"]","category":"page"},{"location":"reference/variable_constraint.html#PowerModelsONM.objective_mc_min_storage_utilization-Tuple{AbstractUnbalancedPowerModel}","page":"Variables and Constraints","title":"PowerModelsONM.objective_mc_min_storage_utilization","text":"objective_mc_min_storage_utilization(pm::AbstractUnbalancedPowerModel)\n\nMinimizes the amount of storage that gets utilized in favor of using all available generation first\n\nbeginalign*\nmboxminimize   \n sum_substacke in Et in T epsilon^ub_e - epsilon_et \nendalign*\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.objective_min_shed_load_block-Tuple{AbstractUnbalancedPowerModel}","page":"Variables and Constraints","title":"PowerModelsONM.objective_min_shed_load_block","text":"objective_min_shed_load_block(pm::AbstractUnbalancedPowerModel)\n\nMinimum block load shed objective for rolling horizon problem. Note that the difference between this and objective_min_shed_load_block_rolling_horizon is that the sum over the switches in line 2 of the objective is optional, as determined by user inputs in the model, i.e., enable_switch_state_open_cost (default: false), and disable-switch-state-change-cost (default: false).\n\n```math \\begin{align} \\mbox{minimize: } & \\\n& \\sum{\\substack{b \\in B,t \\in T}} W^{bl}{b,t} \\left(1 - z^{bl}{b,t} \\right) \\\n& + \\sum{\\substack{s \\in S,t \\in T}} \\left[ W^{sw}{s,t} \\left(1 - \\gamma{s,t} \\right )) +  W^{\\Delta^{\\gamma}}{s,t}\\Delta^{\\gamma}{s,t}\\right ]\\\n& + \\sum{\\substack{e \\in E,t \\in T}} \\epsilon^{ub}{e} - \\epsilon{e,t} \\\n& + \\sum{\\substack{g \\in G,t \\in T}} f1 P{g,t} + f_0 \\end{align}```\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.objective_min_shed_load_block_rolling_horizon-Tuple{AbstractUnbalancedPowerModel}","page":"Variables and Constraints","title":"PowerModelsONM.objective_min_shed_load_block_rolling_horizon","text":"objective_min_shed_load_block_rolling_horizon(pm::AbstractUnbalancedPowerModel)\n\nMinimum block load shed objective for rolling horizon problem. Note that the difference between this and objective_min_shed_load_block is that the sum over the switches in line 2 of the objective is non-optional.\n\n```math \\begin{align} \\mbox{minimize: } & \\\n& \\sum{\\substack{b \\in B,t \\in T}} W^{bl}{b,t} \\left(1 - z^{bl}{b,t} \\right) \\\n& + \\sum{\\substack{s \\in S,t \\in T}} \\left[ W^{sw}{s,t} \\left(1 - \\gamma{s,t} \\right )) +  W^{\\Delta^{\\gamma}}{s,t}\\Delta^{\\gamma}{s,t}\\right ]\\\n& + \\sum{\\substack{e \\in E,t \\in T}} \\epsilon^{ub}{e} - \\epsilon{e,t} \\\n& + \\sum{\\substack{g \\in G,t \\in T}} f1 P{g,t} + f_0 \\end{align}```\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.objective_min_shed_load_traditional-Tuple{AbstractUnbalancedPowerModel}","page":"Variables and Constraints","title":"PowerModelsONM.objective_min_shed_load_traditional","text":"objective_min_shed_load_traditional(pm::AbstractUnbalancedPowerModel)\n\nMinimum block load shed objective for rolling horizon problem. Note that the difference between this and objective_min_shed_load_traditional_rolling_horizon is that the sum over the switches in line 2 of the objective is optional, as determined by user inputs in the model, i.e., enable_switch_state_open_cost (default: false), and disable-switch-state-change-cost (default: false).\n\nbeginalign*\nmboxminimize   \n sum_substackl in Lt in T W^d_lt left(1 - z^d_lt right) \n + sum_substacks in St in T left W^sw_st left(1 - gamma_st right )) +  W^Delta^gamma_stDelta^gamma_stright \n + sum_substacke in Et in T epsilon^ub_e - epsilon_et \n + sum_substackg in Gt in T f_1 P_gt + f_0\nendalign*\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.objective_min_shed_load_traditional_rolling_horizon-Tuple{AbstractUnbalancedPowerModel}","page":"Variables and Constraints","title":"PowerModelsONM.objective_min_shed_load_traditional_rolling_horizon","text":"objective_min_shed_load_traditional_rolling_horizon(pm::AbstractUnbalancedPowerModel)\n\nMinimum block load shed objective for rolling horizon problem. Note that the difference between this and objective_min_shed_load_traditional is that the sum over the switches in line 2 of the objective is non-optional.\n\nbeginalign*\nmboxminimize   \n sum_substackl in Lt in T W^d_lt left(1 - z^d_lt right) \n + sum_substacks in St in T left W^sw_st left(1 - gamma_st right )) +  W^Delta^gamma_stDelta^gamma_stright \n + sum_substacke in Et in T epsilon^ub_e - epsilon_et \n + sum_substackg in Gt in T f_1 P_gt + f_0\nendalign*\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.objective_robust_min_shed_load_block_rolling_horizon-Tuple{AbstractUnbalancedPowerModel, Dict{Int64, JuMP.AffExpr}, Int64}","page":"Variables and Constraints","title":"PowerModelsONM.objective_robust_min_shed_load_block_rolling_horizon","text":"objective_robust_min_shed_load_block_rolling_horizon(pm::AbstractUnbalancedPowerModel, scenarios::Vector{Int})\n\nMinimum block load shed objective (similar to objectiveminshedloadblockrollinghorizon) for robust partitioning problem considering uncertainty\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#Ref-extensions","page":"Variables and Constraints","title":"Ref extensions","text":"","category":"section"},{"location":"reference/variable_constraint.html","page":"Variables and Constraints","title":"Variables and Constraints","text":"Modules = [PowerModelsONM]\nPrivate = false\nOrder = [:function]\nPages = [\"ref.jl\"]","category":"page"},{"location":"reference/variable_constraint.html#PowerModelsONM.ref_add_load_blocks!-Tuple{Dict{Symbol}, Dict{String}}","page":"Variables and Constraints","title":"PowerModelsONM.ref_add_load_blocks!","text":"ref_add_load_blocks!(ref::Dict{Symbol,<:Any}, data::Dict{String,<:Any})\n\nRef extension to add load blocks to ref for all time steps\n\n\n\n\n\n","category":"method"},{"location":"reference/variable_constraint.html#PowerModelsONM.ref_add_options!-Tuple{Dict{Symbol}, Dict{String}}","page":"Variables and Constraints","title":"PowerModelsONM.ref_add_options!","text":"ref_add_options!(ref::Dict{Symbol,<:Any}, data::Dict{String,<:Any})\n\nRef extension to add options to ref for all time steps\n\n\n\n\n\n","category":"method"},{"location":"installation.html#Installation-Guide","page":"Installation Guide","title":"Installation Guide","text":"","category":"section"},{"location":"installation.html","page":"Installation Guide","title":"Installation Guide","text":"From Julia, PowerModelsONM is installed using the built-in package manager:","category":"page"},{"location":"installation.html","page":"Installation Guide","title":"Installation Guide","text":"]add PowerModelsONM","category":"page"},{"location":"installation.html","page":"Installation Guide","title":"Installation Guide","text":"or equivalently,","category":"page"},{"location":"installation.html","page":"Installation Guide","title":"Installation Guide","text":"import Pkg\nPkg.add(\"PowerModelsONM\")","category":"page"},{"location":"installation.html#Developer-Installation","page":"Installation Guide","title":"Developer Installation","text":"","category":"section"},{"location":"installation.html","page":"Installation Guide","title":"Installation Guide","text":"To install PowerModelsONM as a developer,","category":"page"},{"location":"installation.html","page":"Installation Guide","title":"Installation Guide","text":"import Pkg\nPkg.develop(Pkg.PackageSpec(; name=\"PowerModelsONM\", url=\"https://github.com/lanl-ansi/PowerModelsONM.jl\"))","category":"page"},{"location":"installation.html","page":"Installation Guide","title":"Installation Guide","text":"From the command-line, outside Julia, one could download the repository, either via Github.com, or using git, i.e.,","category":"page"},{"location":"installation.html","page":"Installation Guide","title":"Installation Guide","text":"git clone https://github.com/lanl-ansi/PowerModelsONM.jl.git\ngit checkout tags/v1.0.0","category":"page"},{"location":"installation.html","page":"Installation Guide","title":"Installation Guide","text":"Then to install PowerModelsONM and its required packages","category":"page"},{"location":"installation.html","page":"Installation Guide","title":"Installation Guide","text":"julia --project=\"path/to/PowerModelsONM\" -e 'using Pkg; Pkg.instantiate(); Pkg.precompile();'","category":"page"},{"location":"installation.html#Gurobi-Configuration","page":"Installation Guide","title":"Gurobi Configuration","text":"","category":"section"},{"location":"installation.html","page":"Installation Guide","title":"Installation Guide","text":"To use Gurobi, a Gurobi binary in required on your system, as well as ENV variables defining where the Gurobi binary is, and where your Gurobi license file is, e.g., for Gurobi 9.10 on MacOS,","category":"page"},{"location":"installation.html","page":"Installation Guide","title":"Installation Guide","text":"export GRB_LICENSE_FILE=\"$HOME/.gurobi/gurobi.lic\"\nexport GUROBI_HOME=\"/Library/gurobi910/mac64\"","category":"page"},{"location":"installation.html","page":"Installation Guide","title":"Installation Guide","text":"BEFORE importing PowerModelsONM with using PowerModelsONM, you must import Gurobi.","category":"page"},{"location":"developer/style.html#Style-Conventions","page":"Style Guide","title":"Style Conventions","text":"","category":"section"},{"location":"developer/style.html","page":"Style Guide","title":"Style Guide","text":"In general, the following conventions should be adhered to when making changes or additions to the code base. These conventions should include any conventions applied across the InfrastructureModels ecosystem specific to power engineering (i.e conventions from InfrastructureModels, PowerModels, PowerModelsRestoration, etc.) with some additions specific to PowerModelsONM.","category":"page"},{"location":"developer/style.html#Functions","page":"Style Guide","title":"Functions","text":"","category":"section"},{"location":"developer/style.html","page":"Style Guide","title":"Style Guide","text":"Function additions should meeting the following criteria:","category":"page"},{"location":"developer/style.html","page":"Style Guide","title":"Style Guide","text":"All functions should be clearly named, without abbreviations, and with underscores between words, e.g. parse_file or constraint_bus_voltage_magnitude; in Python this is known as lower_case_with_underscores. The exception to the abbreviate rule is cases where abbreviations would be expected in the modeling of power systems.\nAll functions that are not prepended by an underscore _ will be exported by default (i.e. when a user uses using PowerModelsONM). Public functions should have a detailed docstring instructing on usage\nAll functions that modify data in place should end with an exclamation point ! and the function input that is being modified should be the first argument (or first arguments in the case where multiple inputs are being modified in place). The exceptions to this rule are constraint and variable creation functions (i.e. those functions related to JuMP model creation), which do not include the exclaimation point\nAll function arguments, including keyword arguments, should have their types specified.\nPrivate functions, i.e. those intended to be for internal use only, should follow the same descriptive naming conventions as functions exported by default, and should always include docstrings to describe their purpose.\nFunctions should be separated by two blank lines","category":"page"},{"location":"developer/style.html","page":"Style Guide","title":"Style Guide","text":"\"this function demonstrates how an internal, in-place data altering function should be defined\"\nfunction _concise_descriptive_name!(data::Dict{String,<:Any}, a::Real, b::Vector{<:Real}, c::Matrix{<:Complex}; d::Bool=false, e::Vector{Function}=Function[])\nend","category":"page"},{"location":"developer/style.html#Types-and-Enums","page":"Style Guide","title":"Types & Enums","text":"","category":"section"},{"location":"developer/style.html","page":"Style Guide","title":"Style Guide","text":"When specifying types, i.e. when specifying the type of a function argument, or creating enums, these guidelines are recommended:","category":"page"},{"location":"developer/style.html","page":"Style Guide","title":"Style Guide","text":"Prefer to use Vector{T} instead of Array{T,1}\nPrefer to use Matrix{T} instead of Array{T,2}\nEnums should only be used in the ENGINEERING data model, never the MATHEMATICAL data model\nEnums must be added to the JSON parser when introduced","category":"page"},{"location":"developer/style.html#Constants","page":"Style Guide","title":"Constants","text":"","category":"section"},{"location":"developer/style.html","page":"Style Guide","title":"Style Guide","text":"Whenever possible, const should be used to eliminate unnecesary re-evaluations of code, and every const should have a docstring, whether internal or public.","category":"page"},{"location":"developer/style.html#JuMP-Variables-and-Constraints","page":"Style Guide","title":"JuMP Variables and Constraints","text":"","category":"section"},{"location":"developer/style.html","page":"Style Guide","title":"Style Guide","text":"For functions that create JuMP variables and constraints in particular, we follow the following naming convention as originally adopted by PowerModels:","category":"page"},{"location":"developer/style.html","page":"Style Guide","title":"Style Guide","text":"<jump macro id>(_<phase variant>)_<comp short name>_<quantity name>(_real|_imaginary|_magnitude|_angle|_factor)(_fr|_to)(_sqr)(_on_off)","category":"page"},{"location":"developer/style.html","page":"Style Guide","title":"Style Guide","text":"in the interest of intuitive names for users, the following special cases are also acceptable,","category":"page"},{"location":"developer/style.html","page":"Style Guide","title":"Style Guide","text":"_power_real -(can be replaced with)-> _active\n_power_imaginary -(can be replaced with)-> _reactive","category":"page"},{"location":"developer/style.html","page":"Style Guide","title":"Style Guide","text":"In the case of PowerModelsONM, there are additional tags indicating that a function is a multiconductor variant, three-phase specific, etc.:","category":"page"},{"location":"developer/style.html","page":"Style Guide","title":"Style Guide","text":"mc multi-conductor, with an explicit neutral (which is the last conductor by convention?)\nmp multi-phase, for constraints that have no (explicit) neutral and multiple phases\n3p three-phase, when a constraint is hard-coded for three phases","category":"page"},{"location":"developer/style.html","page":"Style Guide","title":"Style Guide","text":"Currently, all phase-aware functions use mc, but this is subject to change in the future as we refactor. If the function is not multiphase specific, these are not needed in the function name.","category":"page"},{"location":"developer/style.html#Formulation-Styles","page":"Style Guide","title":"Formulation Styles","text":"","category":"section"},{"location":"developer/style.html","page":"Style Guide","title":"Style Guide","text":"All new formulations should have clear error messages when they do not support existing components. For example, if a formulation addition which is intended to work with OPF does not support delta-wye transformers, the constraint_mc_transformer_power_dy\nFormulation abstract type and mutable struct must be specified in CapitalizedWords, which is a subtype of camelCase with the first word also capitalized.","category":"page"},{"location":"developer/style.html#Problem-Specification-Styles","page":"Style Guide","title":"Problem Specification Styles","text":"","category":"section"},{"location":"developer/style.html","page":"Style Guide","title":"Style Guide","text":"If a new problem specification is only needed due to the requirements of a new formulation, and is not a new type of problem, e.g. another OPF formulation, a build_ function with the same name as the existing formulation should be created that accepts a specific PowerModel (multiple dispatch)\nIf a new problem specification is a new type of problem that will e.g. accept multiple formulations, new build_ and run_ functions should be created that do not collide with existing problem specification functions","category":"page"},{"location":"developer/style.html#Metaprogramming","page":"Style Guide","title":"Metaprogramming","text":"","category":"section"},{"location":"developer/style.html","page":"Style Guide","title":"Style Guide","text":"In general, it is better to avoid metaprogramming patterns, like creating functions algorithmically, in order to aid in the debugging of code. Metaprogramming can create significant challenges in interpreting stacktraces upon errors.","category":"page"},{"location":"developer/style.html#Markdown","page":"Style Guide","title":"Markdown","text":"","category":"section"},{"location":"developer/style.html","page":"Style Guide","title":"Style Guide","text":"Markdown files should be properly formatted, particularly when including tables. Developers are encouraged to use markdownlint and a markdown formatter (such as in VSCode).","category":"page"},{"location":"developer/style.html#File-Structure","page":"Style Guide","title":"File Structure","text":"","category":"section"},{"location":"developer/style.html","page":"Style Guide","title":"Style Guide","text":"It is important that new functions, variables, constraints, etc. all go into appropriate places in the code base so that future maintenance and debugging is easier. Pay attention to the current file structure and attempt to conform as best as possible to it. In general","category":"page"},{"location":"developer/style.html","page":"Style Guide","title":"Style Guide","text":"src/app contains the main ONM workflow, for uses in binaries, docker images, etc.\nsrc/cli contains the runtime arguments for the command line\nsrc/core contains the core logic of the package, including variable creation and constraint templates, i.e. things that are agnostic to the formulation\nsrc/data_model contains all of the logic to transform between the ENGINEERING and MATHEMATICAL data models and model creation helper tools\nsrc/form contains formulation specific variable and constraint functions, organized under separate files for different formulations\nsrc/io contains all of the tools to parse and save files, in particular all of the logic necessary to parse dss files and output json files\nsrc/prob contains all problem specifications\nsrc/stats contains all statistical analysis functions\ndocs/src contains all source markdown files for the documentation\nexamples contains Pluto.jl notebooks with walkthroughs of PowerModelsONM for new users\nschemas contains JSON Schemas for supported I/O file formats","category":"page"},{"location":"developer/style.html#Dependencies-(Project.toml)","page":"Style Guide","title":"Dependencies (Project.toml)","text":"","category":"section"},{"location":"developer/style.html","page":"Style Guide","title":"Style Guide","text":"All new dependencies should be carefully considered before being added. It is important to keep the number of external dependencies low to avoid reliance on features that may not be maintained in the future. If possible, Julia Standard Library should be used, particularly in the case where reproducing the desired feature is trivial. There will be cases where it is not simple to duplicate a feature and subsequently maintain it within the package, so adding a dependency would be appropriate in such cases.","category":"page"},{"location":"developer/style.html","page":"Style Guide","title":"Style Guide","text":"All new dependencies are are ultimately approved should also include an entry under [compat] indicating the acceptable versions (Julia automerge requirement). This includes test-only dependencies that appear under [extras]","category":"page"},{"location":"developer/style.html","page":"Style Guide","title":"Style Guide","text":"The Manifest.toml should not be included in the repo.","category":"page"},{"location":"schemas/input-faults.schema.html#Faults-Schema","page":"faults.schema","title":"Faults Schema","text":"","category":"section"},{"location":"schemas/input-faults.schema.html","page":"faults.schema","title":"faults.schema","text":"If this page exists in final documentation, automatic conversion of schema to documentation failed.","category":"page"},{"location":"reference/schema.html#SchemaAPI","page":"Schema","title":"Schema","text":"","category":"section"},{"location":"reference/schema.html#Validation","page":"Schema","title":"Validation","text":"","category":"section"},{"location":"reference/schema.html","page":"Schema","title":"Schema","text":"Modules = [PowerModelsONM]\nPrivate = false\nOrder = [:function]\nPages = [\"checks.jl\"]","category":"page"},{"location":"reference/schema.html#PowerModelsONM.check_switch_state_feasibility-Tuple{Dict{String}}","page":"Schema","title":"PowerModelsONM.check_switch_state_feasibility","text":"check_switch_state_feasibility(data::Dict{String,<:Any})::Union{Dict{String,Bool},Bool}\n\nHelper function to aid users in determining whether network model has a feasible starting switch configuration (at each time step, if the network model is multinetwork), assuming radiality constraints are applied.\n\n\n\n\n\n","category":"method"},{"location":"reference/schema.html#PowerModelsONM.evaluate_events-Tuple{Dict}","page":"Schema","title":"PowerModelsONM.evaluate_events","text":"evaluate_events(data::Dict)\n\nHelper function to give detailed output on JSON Schema validation of events data\n\n\n\n\n\n","category":"method"},{"location":"reference/schema.html#PowerModelsONM.evaluate_output-Tuple{Dict}","page":"Schema","title":"PowerModelsONM.evaluate_output","text":"evaluate_output(data::Dict)\n\nHelper function to give detailed output on JSON Schema validation of output data\n\n\n\n\n\n","category":"method"},{"location":"reference/schema.html#PowerModelsONM.evaluate_robust_partitions-Tuple{Vector}","page":"Schema","title":"PowerModelsONM.evaluate_robust_partitions","text":"evaluate_robust_partitions(data::Dict)\n\nHelper function to give detailed output on JSON Schema validation of settings data\n\n\n\n\n\n","category":"method"},{"location":"reference/schema.html#PowerModelsONM.evaluate_runtime_arguments-Tuple{Dict}","page":"Schema","title":"PowerModelsONM.evaluate_runtime_arguments","text":"evaluate_runtime_arguments(data::Dict)\n\nHelper function to give detailed output on JSON Schema validation of runtime arguments data\n\n\n\n\n\n","category":"method"},{"location":"reference/schema.html#PowerModelsONM.evaluate_settings-Tuple{Dict}","page":"Schema","title":"PowerModelsONM.evaluate_settings","text":"evaluate_settings(data::Dict)\n\nHelper function to give detailed output on JSON Schema validation of settings data\n\n\n\n\n\n","category":"method"},{"location":"reference/schema.html#PowerModelsONM.update_start_values!-Tuple{Dict{String, Any}}","page":"Schema","title":"PowerModelsONM.update_start_values!","text":"update_start_values!(data::Dict{String,Any}; overwrite_start_values::Bool=false)::Dict{String,Any}\n\nHelper function to add some start values for variables to prevent starting MIP infeasibilities\n\n\n\n\n\n","category":"method"},{"location":"reference/schema.html#PowerModelsONM.update_start_values_eng!-Tuple{Dict{String, Any}}","page":"Schema","title":"PowerModelsONM.update_start_values_eng!","text":"update_start_values_eng!(eng::Dict{String,Any}; overwrite_start_values::Bool=false)::Dict{String,Any}\n\nHelper function to add some start values for variables to prevent starting MIP infeasibilities to the ENGINEERING model\n\n\n\n\n\n","category":"method"},{"location":"reference/schema.html#PowerModelsONM.update_start_values_math!-Tuple{Dict{String, Any}}","page":"Schema","title":"PowerModelsONM.update_start_values_math!","text":"update_start_values_math!(math::Dict{String,Any}; overwrite_start_values::Bool=false)::Dict{String,Any}\n\nHelper function to add some start values for variables to prevent starting MIP infeasibilities to the MATHEMATICAL model\n\n\n\n\n\n","category":"method"},{"location":"reference/schema.html#PowerModelsONM.validate_events-Tuple{Vector}","page":"Schema","title":"PowerModelsONM.validate_events","text":"validate_events(data::Vector{Dict})::Bool\n\nValidates events data against models/events schema\n\n\n\n\n\n","category":"method"},{"location":"reference/schema.html#PowerModelsONM.validate_faults-Tuple{Dict}","page":"Schema","title":"PowerModelsONM.validate_faults","text":"validate_faults(data::Dict)::Bool\n\nValidates fault input data against models/faults schema\n\n\n\n\n\n","category":"method"},{"location":"reference/schema.html#PowerModelsONM.validate_inverters-Tuple{Dict}","page":"Schema","title":"PowerModelsONM.validate_inverters","text":"validate_inverters(data::Dict)::Bool\n\nValidates inverter data against models/inverters schema\n\n\n\n\n\n","category":"method"},{"location":"reference/schema.html#PowerModelsONM.validate_output-Tuple{Dict}","page":"Schema","title":"PowerModelsONM.validate_output","text":"validate_output(data::Dict)::Bool\n\nValidates output data against models/outputs schema\n\n\n\n\n\n","category":"method"},{"location":"reference/schema.html#PowerModelsONM.validate_robust_partitions-Tuple{Vector}","page":"Schema","title":"PowerModelsONM.validate_robust_partitions","text":"validate_robust_partitions(data::Vector{Dict})::Bool\n\nValidates events data against robust partitions output schema\n\n\n\n\n\n","category":"method"},{"location":"reference/schema.html#PowerModelsONM.validate_runtime_arguments-Tuple{Dict}","page":"Schema","title":"PowerModelsONM.validate_runtime_arguments","text":"validate_runtime_arguments(data::Dict)::Bool\n\nValidates runtimearguments data against models/runtimearguments schema\n\n\n\n\n\n","category":"method"},{"location":"reference/schema.html#PowerModelsONM.validate_settings-Tuple{Dict}","page":"Schema","title":"PowerModelsONM.validate_settings","text":"validate_settings(data::Dict)::Bool\n\nValidates runtimesettings data against models/runtimesettings schema\n\n\n\n\n\n","category":"method"},{"location":"tutorials/Beginners Guide.html#Introduction-to-PowerModelsONM","page":"Beginners Guide","title":"Introduction to PowerModelsONM","text":"","category":"section"},{"location":"tutorials/Beginners Guide.html","page":"Beginners Guide","title":"Beginners Guide","text":"This is a stub for an interactive Pluto.jl tutorial contained in examples.","category":"page"},{"location":"tutorials/Beginners Guide.html","page":"Beginners Guide","title":"Beginners Guide","text":"During documentation build time, this tutorial will be automatically converted to HTML, but will lose its interactivity.","category":"page"},{"location":"tutorials/Beginners Guide.html","page":"Beginners Guide","title":"Beginners Guide","text":"To experience the full interactivity of this notebook please install Pluto.jl, and open this file","category":"page"},{"location":"tutorials/Beginners Guide.html#Installing-and-running-Pluto.jl","page":"Beginners Guide","title":"Installing and running Pluto.jl","text":"","category":"section"},{"location":"tutorials/Beginners Guide.html","page":"Beginners Guide","title":"Beginners Guide","text":"Run Julia and add the package:","category":"page"},{"location":"tutorials/Beginners Guide.html","page":"Beginners Guide","title":"Beginners Guide","text":"]add Pluto","category":"page"},{"location":"tutorials/Beginners Guide.html","page":"Beginners Guide","title":"Beginners Guide","text":"Using the package manager for the first time after installing Julia can take up to 15 minutes - hang in there!","category":"page"},{"location":"tutorials/Beginners Guide.html","page":"Beginners Guide","title":"Beginners Guide","text":"To run the notebook server:","category":"page"},{"location":"tutorials/Beginners Guide.html","page":"Beginners Guide","title":"Beginners Guide","text":"import Pluto\nPluto.run()","category":"page"},{"location":"tutorials/Beginners Guide.html","page":"Beginners Guide","title":"Beginners Guide","text":"Pluto will open in your browser, and you can get started!","category":"page"},{"location":"reference/graphml.html#GraphMLAPI","page":"GraphML Functions","title":"GraphML","text":"","category":"section"},{"location":"reference/graphml.html","page":"GraphML Functions","title":"GraphML Functions","text":"Modules = [PowerModelsONM]\nPrivate = false\nOrder = [:function]\nPages = [\"graphml.jl\"]","category":"page"},{"location":"reference/graphml.html#PowerModelsONM.add_graphml_data!-Tuple{EzXML.Node, String, Any}","page":"GraphML Functions","title":"PowerModelsONM.add_graphml_data!","text":"add_graphml_data!(node::EzXML.Node, key::String, value::Any)::EzXML.Node\n\nHelper function to add an AttributeNode with key and value to a node\n\n\n\n\n\n","category":"method"},{"location":"reference/graphml.html#PowerModelsONM.add_root_graphml_node!-Tuple{EzXML.Document}","page":"GraphML Functions","title":"PowerModelsONM.add_root_graphml_node!","text":"add_root_graphml_node!(doc::EzXML.Document)::EzXML.Node\n\nHelper function to build 'graphml' root XML Node for GraphML XML documents\n\n\n\n\n\n","category":"method"},{"location":"reference/graphml.html#PowerModelsONM.build_graphml_document-Tuple{Dict{String}}","page":"GraphML Functions","title":"PowerModelsONM.build_graphml_document","text":"build_graphml_document(eng::Dict{String,<:Any}; type::Type=\"nested\")\n\nHelper function to build GraphML XML document from a eng network data structure.\n\ntype controls whether the resulting graph is a NestedGraph, i.e., buses are contained within load blocks, or a UnnestedGraph, where node groups are not utilized.\n\n\n\n\n\n","category":"method"},{"location":"reference/graphml.html#PowerModelsONM.build_graphml_document-Tuple{NestedGraph}","page":"GraphML Functions","title":"PowerModelsONM.build_graphml_document","text":"build_graphml_document(gr::NestedGraph)::EzXML.Document\n\nHelper function to build GraphML XML document from a NestedGraph\n\n\n\n\n\n","category":"method"},{"location":"reference/graphml.html#PowerModelsONM.build_graphml_document-Tuple{UnnestedGraph}","page":"GraphML Functions","title":"PowerModelsONM.build_graphml_document","text":"build_graphml_document(gr::UnnestedGraph)::EzXML.Document\n\nHelper function to build GraphML XML document from an UnnestedGraph\n\n\n\n\n\n","category":"method"},{"location":"reference/graphml.html#PowerModelsONM.build_graphml_edge-Tuple{String, String, String}","page":"GraphML Functions","title":"PowerModelsONM.build_graphml_edge","text":"build_graphml_edge(id::String, source::String, target::String)::EzXML.Node\n\nHelper function to build an 'edge' XML Node object for GraphML XML documents\n\n\n\n\n\n","category":"method"},{"location":"reference/graphml.html#PowerModelsONM.build_graphml_graph","page":"GraphML Functions","title":"PowerModelsONM.build_graphml_graph","text":"build_graphml_graph(id::String, directed::Bool=false)::EzXML.Node\n\nHelper function to build a 'graph' XML Node for GraphML XML documents\n\n\n\n\n\n","category":"function"},{"location":"reference/graphml.html#PowerModelsONM.build_graphml_key","page":"GraphML Functions","title":"PowerModelsONM.build_graphml_key","text":"build_graphml_key(id::String, is_for::String, attr_name::String, attr_type::String, default::Any=missing)::EzXML.Node\n\nHelper function to build an XML AttributeNode for attribute data for GraphML XML documents\n\n\n\n\n\n","category":"function"},{"location":"reference/graphml.html#PowerModelsONM.build_graphml_node-Tuple{String}","page":"GraphML Functions","title":"PowerModelsONM.build_graphml_node","text":"build_graphml_node(id::String)::EzXML.Node\n\nHelper function to build graph 'node' XML Node for GraphML XML documents\n\n\n\n\n\n","category":"method"},{"location":"reference/graphml.html#PowerModelsONM.build_nested_graph-Tuple{Dict{String, Any}}","page":"GraphML Functions","title":"PowerModelsONM.build_nested_graph","text":"build_nested_graph(eng::Dict{String,Any})::NestedGraph\n\nHelper function to build a NestedGraph of network data eng\n\n\n\n\n\n","category":"method"},{"location":"reference/graphml.html#PowerModelsONM.build_unnested_graph-Tuple{Dict{String}}","page":"GraphML Functions","title":"PowerModelsONM.build_unnested_graph","text":"build_unnested_graph(eng::Dict{String,<:Any})::UnnestedGraph\n\nHelper function to build an UnnestedGraph from eng network data.\n\n\n\n\n\n","category":"method"},{"location":"reference/graphml.html#PowerModelsONM.save_graphml-Tuple{IO, Dict{String}}","page":"GraphML Functions","title":"PowerModelsONM.save_graphml","text":"save_graphml(io::IO, eng::Dict{String,<:Any}; type::String=\"nested\")\n\nSave a GraphML XML document built from eng network data to IO stream.\n\ntype controls whether the resulting graph is a NestedGraph, i.e., buses are contained within load blocks, or a UnnestedGraph, where node groups are not utilized.\n\n\n\n\n\n","category":"method"},{"location":"reference/graphml.html#PowerModelsONM.save_graphml-Tuple{String, Dict{String}}","page":"GraphML Functions","title":"PowerModelsONM.save_graphml","text":"save_graphml(graphml_file::String, eng::Dict{String,<:Any}; type::String=\"nested\")\n\nSave a GraphML XML document built from eng network data to graphml_file.\n\ntype controls whether the resulting graph is a NestedGraph, i.e., buses are contained within load blocks, or a UnnestedGraph, where node groups are not utilized.\n\n\n\n\n\n","category":"method"},{"location":"reference/io.html#IOAPI","page":"IO Functions","title":"IO","text":"","category":"section"},{"location":"reference/io.html#Parsers","page":"IO Functions","title":"Parsers","text":"","category":"section"},{"location":"reference/io.html","page":"IO Functions","title":"IO Functions","text":"parse_file\nparse_network\nparse_network!\nparse_events\nparse_events!\nparse_settings\nparse_settings!\nparse_faults\nparse_inverters","category":"page"},{"location":"reference/io.html#PowerModelsONM.parse_file","page":"IO Functions","title":"PowerModelsONM.parse_file","text":"parse_file(network_file::String; dss2eng_extensions=Function[], transformations=Function[], import_all=true, kwargs...)\n\nONM version of PowerModelsDistribution.parse_file, which includes some dss2eng_extensions and transformations by default\n\n\n\n\n\n","category":"function"},{"location":"reference/io.html#PowerModelsONM.parse_network","page":"IO Functions","title":"PowerModelsONM.parse_network","text":"parse_network(\n    network_file::String\n)::Tuple{Dict{String,Any},Dict{String,Any}}\n\nParses network file given by runtime arguments into its base network, i.e., not expanded into a multinetwork, and multinetwork, which is the multinetwork ENGINEERING representation of the network.\n\n\n\n\n\n","category":"function"},{"location":"reference/io.html#PowerModelsONM.parse_network!","page":"IO Functions","title":"PowerModelsONM.parse_network!","text":"parse_network!(args::Dict{String,<:Any})::Dict{String,Any}\n\nIn-place version of parse_network, returns the ENGINEERING multinetwork data structure, which is available in args under args[\"network\"], and adds the non-expanded ENGINEERING data structure under args[\"base_network\"]\n\n\n\n\n\n","category":"function"},{"location":"reference/io.html#PowerModelsONM.parse_events","page":"IO Functions","title":"PowerModelsONM.parse_events","text":"parse_events(\n    events_file::String;\n    validate::Bool=true\n)::Vector{Dict{String,Any}}\n\nParses an events file into a raw events data structure\n\nValidation\n\nIf validate=true (default), the parsed data structure will be validated against the latest Events Schema.\n\n\n\n\n\nparse_events(\n    raw_events::Vector{<:Dict{String,<:Any}},\n    mn_data::Dict{String,<:Any}\n)::Dict{String,Any}\n\nConverts raw_events, e.g. loaded from JSON, and therefore in the format Vector{Dict}, to an internal data structure that closely matches the multinetwork data structure for easy merging (applying) to the multinetwork data structure.\n\nWill attempt to find the correct subnetwork from the specified timestep by using \"mn_lookup\" in the multinetwork data structure.\n\nSwitch events\n\nWill find the correct switch id from a source_id, i.e., the assettype.name from the source file, which for switches will be line.name, and create a data structure containing the properties defined in `eventdata` under the native ENGINEERING switch id.\n\nFault events\n\nWill attempt to find the appropriate switches that need to be OPEN to isolate a fault, and disable them, i.e., set dispatchable=false, until the end of the duration of the fault, which is specified in milliseconds.\n\nIt will re-enable the switches, i.e., set dispatchable=true after the fault has ended, if the next timestep exists, but will not automatically set the switches to CLOSED again; this is a decision for the algorithm optimize_switches to make.\n\n\n\n\n\nparse_events(\n    events_file::String,\n    mn_data::Dict{String,<:Any};\n    validate::Bool=true\n)::Dict{String,Any}\n\nParses raw events from events_file and passes it to parse_events to convert to the native data type.\n\nValidation\n\nIf validate=true (default), the parsed data structure will be validated against the latest Events Schema.\n\n\n\n\n\n","category":"function"},{"location":"reference/io.html#PowerModelsONM.parse_events!","page":"IO Functions","title":"PowerModelsONM.parse_events!","text":"parse_events!(\n    args::Dict{String,<:Any};\n    validate::Bool=true,\n    apply::Bool=true\n)::Dict{String,Any}\n\nParses events file in-place using parse_events, for use inside of entrypoint.\n\nIf apply, will apply the events to the multinetwork data structure.\n\nValidation\n\nIf validate=true (default), the parsed data structure will be validated against the latest Events Schema.\n\n\n\n\n\n","category":"function"},{"location":"reference/io.html#PowerModelsONM.parse_settings","page":"IO Functions","title":"PowerModelsONM.parse_settings","text":"parse_settings(\n    settings_file::String;\n    validate::Bool=true\n    correct::Bool=true\n)::Dict{String,Any}\n\nParses network settings JSON file.\n\nValidation\n\nIf validate=true (default), the parsed data structure will be validated against the latest Settings Schema.\n\n\n\n\n\n","category":"function"},{"location":"reference/io.html#PowerModelsONM.parse_settings!","page":"IO Functions","title":"PowerModelsONM.parse_settings!","text":"parse_settings!(\n    args::Dict{String,<:Any};\n    apply::Bool=true,\n    validate::Bool=true\n)::Dict{String,Any}\n\nParses settings file specifed in runtime arguments in-place\n\nWill attempt to convert deprecated runtime arguments to appropriate network settings data structure.\n\nValidation\n\nIf validate=true (default), the parsed data structure will be validated against the latest Settings Schema.\n\n\n\n\n\n","category":"function"},{"location":"reference/io.html#PowerModelsONM.parse_faults","page":"IO Functions","title":"PowerModelsONM.parse_faults","text":"parse_faults(\n    faults_file::String;\n    validate::Bool=true\n)::Dict{String,Any}\n\nParses fault JSON input files which have the same structure as the outputs from PowerModelsProtection.build_mc_fault_stuides\n\nExpected JSON Structure\n\n{\n    \"bus_name\": {\n        \"fault_type\": {\n            \"fault_key\": {\n                \"g\": [ [200, -100, -100], [-100, 200, -100], [-100, -100, 200]],\n                \"b\": [ [0, 0, 0], [0, 0, 0], [0, 0, 0]],\n                \"status\": \"ENABLED\",\n                \"fault_type\": \"fault_type\",\n                \"bus\": \"bus_name\",\n                \"name\": \"fault_key\",\n                \"connections\": [1, 2, 3]\n            }\n        }\n    }\n}\n\nwhere \"fault_type\" is one of:\n\n\"3p\" : 3-phase\n\"3pg\" : 3-phase-to-ground\n\"ll\" : line-to-line\n\"llg\" : line-to-line-to-ground\n\"ll\" : line-to-line\n\n\"bus_name\" is arbitrary, and just needs to match a bus's name in the network model.\n\n\"status\" is a PowerModelsDistribution.Status Enum in String form, and must be either \"ENABLED\" or \"DISABLED\".\n\n\"g\" and \"b\" are matrices in SI units.\n\n\"fault_type\" in the deepest level is merely metadata and should match the \"fault_type\" key above.\n\n\"name\" should match the fault key and is required to be an Integer.\n\n\"connections\" is a Vector of Integers indicating the phases that the fault applies to.\n\nFor more details see PowerModelsProtection's documentation\n\nValidation\n\nIf validate=true (default), the parsed data structure will be validated against the latest Faults Schema.\n\n\n\n\n\n","category":"function"},{"location":"reference/io.html#PowerModelsONM.parse_inverters","page":"IO Functions","title":"PowerModelsONM.parse_inverters","text":"parse_inverters(\n    inverter_file::String;\n    validate::Bool=true\n)::Dict{String,Any}\n\nParses an inverters JSON file, used in run_stability_analysis!\n\nValidation\n\nIf validate=true (default), the parsed data structure will be validated against the latest Inverters Schema.\n\n\n\n\n\n","category":"function"},{"location":"reference/io.html#Builders","page":"IO Functions","title":"Builders","text":"","category":"section"},{"location":"reference/io.html","page":"IO Functions","title":"IO Functions","text":"build_events_file\nbuild_settings_file","category":"page"},{"location":"reference/io.html#PowerModelsONM.build_events_file","page":"IO Functions","title":"PowerModelsONM.build_events_file","text":"build_events_file(case_file::String, io::IO; kwargs...)\n\nA helper function to save a rudamentary events data structure to io from a network case at path case_file.\n\n\n\n\n\nbuild_events_file(eng::Dict{String,<:Any}, io::IO; kwargs...)\n\nA helper function to save a rudamentary events data structure to io from a network case eng.\n\n\n\n\n\nbuild_events_file(case_file::String, events_file::String; kwargs...)\n\nA helper function to build a rudamentary events_file from a network case at path case_file.\n\n\n\n\n\nbuild_events_file(eng::Dict{String,<:Any}, events_file::String; kwargs...)\n\nA helper function to build a rudamentary events_file from a network case eng.\n\n\n\n\n\n","category":"function"},{"location":"reference/io.html#PowerModelsONM.build_settings_file","page":"IO Functions","title":"PowerModelsONM.build_settings_file","text":"build_settings_file(network_file::String, settings_file::String; kwargs...)\n\nBuilds and writes a settings_file::String by parsing a network_file\n\n\n\n\n\nbuild_settings_file(eng::Dict{String,<:Any}, settings_file::String; kwargs...)\n\nBuilds and writes a settings_file::String from a network data set eng::Dict{String,Any}\n\n\n\n\n\nbuild_settings_file(\n    network_file::String,\n    settings_file::String=\"settings.json\";\n    kwargs...\n)\n\nHelper function to write a settings structure to an io for use with ONM from a network data structure eng::Dict{String,<:Any}.\n\n\n\n\n\n","category":"function"},{"location":"reference/io.html#Applicators","page":"IO Functions","title":"Applicators","text":"","category":"section"},{"location":"reference/io.html","page":"IO Functions","title":"IO Functions","text":"apply_events\napply_events!\napply_settings\napply_settings!\ninitialize_output\nget_protection_network_model\nget_protection_network_model!\nget_timestep_bus_types\nget_timestep_bus_types!","category":"page"},{"location":"reference/io.html#PowerModelsONM.apply_events","page":"IO Functions","title":"PowerModelsONM.apply_events","text":"apply_events(\n    network::Dict{String,<:Any},\n    events::Dict{String,<:Any}\n)::Dict{String,Any}\n\nCreates a copy of the multinetwork data structure network and applies the events in events to that data.\n\n\n\n\n\n","category":"function"},{"location":"reference/io.html#PowerModelsONM.apply_events!","page":"IO Functions","title":"PowerModelsONM.apply_events!","text":"apply_events!(args::Dict{String,<:Any})::Dict{String,Any}\n\nApplies events in-place using apply_events, for use inside of entrypoint\n\n\n\n\n\n","category":"function"},{"location":"reference/io.html#PowerModelsONM.apply_settings","page":"IO Functions","title":"PowerModelsONM.apply_settings","text":"apply_settings(\n    network::Dict{String,<:Any},\n    settings::Dict{String,<:Any};\n    multinetwork::Bool=true\n)::Dict{String,Any}\n\nApplies settings to single-network network\n\n\n\n\n\n","category":"function"},{"location":"reference/io.html#PowerModelsONM.apply_settings!","page":"IO Functions","title":"PowerModelsONM.apply_settings!","text":"apply_settings!(args::Dict{String,Any}; multinetwork::Bool=true)::Dict{String,Any}\n\nApplies settings to the network.\n\n\n\n\n\n","category":"function"},{"location":"reference/io.html#PowerModelsONM.initialize_output","page":"IO Functions","title":"PowerModelsONM.initialize_output","text":"initialize_output(args::Dict{String,<:Any})::Dict{String,Any}\n\nInitializes the empty data structure for \"output_data\"\n\n\n\n\n\n","category":"function"},{"location":"reference/io.html#PowerModelsONM.get_protection_network_model","page":"IO Functions","title":"PowerModelsONM.get_protection_network_model","text":"get_protection_network_model(base_eng::Dict{String,<:Any})\n\nBuilds a network data model for use in Protection optimization from the base network model base_eng.\n\n\n\n\n\n","category":"function"},{"location":"reference/io.html#PowerModelsONM.get_protection_network_model!","page":"IO Functions","title":"PowerModelsONM.get_protection_network_model!","text":"get_protection_network_model!(args::Dict{String,<:Any})\n\nBuilds a network data model for use in Protection settings optimization.\n\n\n\n\n\n","category":"function"},{"location":"reference/io.html#PowerModelsONM.get_timestep_bus_types","page":"IO Functions","title":"PowerModelsONM.get_timestep_bus_types","text":"get_timestep_bus_types(::Dict{String,<:Any}, ::String)::Vector{Dict{String,String}}\n\nHelper function for the variant where args[\"network\"] hasn't been parsed yet.\n\n\n\n\n\nget_timestep_bus_types(\n    optimal_dispatch_solution::Dict{String,<:Any},\n    network::Dict{String,<:Any}\n)::Vector{Dict{String,String}}\n\nGets bus types (PQ, PV, ref, isolated) for each timestep from the optimal_dispatch_solution\n\n\n\n\n\n","category":"function"},{"location":"reference/io.html#PowerModelsONM.get_timestep_bus_types!","page":"IO Functions","title":"PowerModelsONM.get_timestep_bus_types!","text":"get_timestep_bus_types!(args::Dict{String,<:Any})::Vector{Dict{String,String}}\n\nGets bus types (PQ, PV, ref, isolated) for each timestep from the optimal dispatch result and assigns it to args[\"output_data\"][\"Protection settings\"][\"bus_types\"]\n\n\n\n\n\n","category":"function"},{"location":"reference/io.html#Writers","page":"IO Functions","title":"Writers","text":"","category":"section"},{"location":"reference/io.html","page":"IO Functions","title":"IO Functions","text":"write_json","category":"page"},{"location":"reference/io.html#PowerModelsONM.write_json","page":"IO Functions","title":"PowerModelsONM.write_json","text":"write_json(\n    file::String,\n    data::Dict{String,<:Any};\n    indent::Union{Int,Missing}=missing\n)\n\nWrite JSON data to file. If !ismissing(indent), JSON will be pretty-formatted with indent\n\n\n\n\n\n","category":"function"},{"location":"reference/io.html#Getters-and-Setters","page":"IO Functions","title":"Getters and Setters","text":"","category":"section"},{"location":"reference/io.html","page":"IO Functions","title":"IO Functions","text":"get_option\nget_setting\nset_setting!\nset_settings!\nset_option!\nset_options!","category":"page"},{"location":"reference/io.html#PowerModelsONM.get_option","page":"IO Functions","title":"PowerModelsONM.get_option","text":"get_option(network::Dict{String,<:Any}, path::Tuple{Vararg{String}}, default::Any=missing)::Any\n\nHelper function to get a property at an arbitrary nested path in a network dictionary, returning the default value if path does not exist.\n\n\n\n\n\nget_option(settings_file::String, path::Tuple{Vararg{String}}, default::Any=missing)::Any\n\nHelper function for variant where settings_file has not been parsed yet.\n\n\n\n\n\n","category":"function"},{"location":"reference/io.html#PowerModelsONM.get_setting","page":"IO Functions","title":"PowerModelsONM.get_setting","text":"get_setting(args::Dict{String,Any}, path::Tuple{Vararg{String}}, default::Any=missing)::Any\n\nHelper function to get a property in settings at an arbitrary nested path in an args dictionary, returning the default value if path does not exist.\n\n\n\n\n\n","category":"function"},{"location":"reference/io.html#PowerModelsONM.set_setting!","page":"IO Functions","title":"PowerModelsONM.set_setting!","text":"set_setting!(args::Dict{String,<:Any}, path::Tuple{Vararg{String}}, value::Any)\n\nHelper function to set an option at path to value and then regenerate the multinetwork data from args.\n\n\n\n\n\n","category":"function"},{"location":"reference/io.html#PowerModelsONM.set_settings!","page":"IO Functions","title":"PowerModelsONM.set_settings!","text":"set_settings!(args, options::Dict{Tuple{Vararg{String}},<:Any})\n\nHelper function to set multiple options at path to value and then regenerate the multinetwork data from args, where the paths are the keys of the options input dictionary.\n\n\n\n\n\n","category":"function"},{"location":"reference/io.html#PowerModelsONM.set_option!","page":"IO Functions","title":"PowerModelsONM.set_option!","text":"set_option!(network::Dict{String,<:Any}, path::Tuple{Vararg{String}}, value::Any)\n\nHelper function to set a property in a network data structure at path to value\n\n\n\n\n\n","category":"function"},{"location":"reference/io.html#PowerModelsONM.set_options!","page":"IO Functions","title":"PowerModelsONM.set_options!","text":"set_options!(settings::Dict{String,<:Any}, options::Dict{Tuple{Vararg{String}},<:Any})\n\nHelper function to set multiple properties in an options at path::Tuple{Vararg{String}} to value::Any. This does not rebuild the network data structure.\n\n\n\n\n\n","category":"function"},{"location":"reference/logging.html#LoggingAPI","page":"Logging","title":"Logging","text":"","category":"section"},{"location":"reference/logging.html","page":"Logging","title":"Logging","text":"Modules = [PowerModelsONM]\nPrivate = false\nOrder = [:function]\nPages = [\"logging.jl\"]","category":"page"},{"location":"reference/logging.html#PowerModelsONM.set_log_level!-Tuple{Symbol}","page":"Logging","title":"PowerModelsONM.set_log_level!","text":"set_log_level!(level::Symbol)\n\nConfigures logging based level, :Error, :Warn, :Info, or :Debug\n\n\n\n\n\n","category":"method"},{"location":"reference/logging.html#PowerModelsONM.setup_logging!-Tuple{Dict{String}}","page":"Logging","title":"PowerModelsONM.setup_logging!","text":"setup_logging!(args::Dict{String,<:Any})\n\nConfigures logging based on runtime arguments\n\n\n\n\n\n","category":"method"},{"location":"reference/logging.html#PowerModelsONM.silence!-Tuple{}","page":"Logging","title":"PowerModelsONM.silence!","text":"silence!()\n\nSets logging level to \"quiet\"\n\n\n\n\n\n","category":"method"},{"location":"tutorials/JuMP Model by Hand - MLD-Block.html#JuMP-Model-by-Hand-MLD-Block","page":"JuMP Model by Hand - MLD-Block Example","title":"JuMP Model by Hand - MLD-Block","text":"","category":"section"},{"location":"tutorials/JuMP Model by Hand - MLD-Block.html","page":"JuMP Model by Hand - MLD-Block Example","title":"JuMP Model by Hand - MLD-Block Example","text":"This is a stub for an interactive Pluto.jl tutorial contained in examples.","category":"page"},{"location":"tutorials/JuMP Model by Hand - MLD-Block.html","page":"JuMP Model by Hand - MLD-Block Example","title":"JuMP Model by Hand - MLD-Block Example","text":"During documentation build time, this tutorial will be automatically converted to HTML, but will lose its interactivity.","category":"page"},{"location":"tutorials/JuMP Model by Hand - MLD-Block.html","page":"JuMP Model by Hand - MLD-Block Example","title":"JuMP Model by Hand - MLD-Block Example","text":"To experience the full interactivity of this notebook please install Pluto.jl, and open this file","category":"page"},{"location":"tutorials/JuMP Model by Hand - MLD-Block.html#Installing-and-running-Pluto.jl","page":"JuMP Model by Hand - MLD-Block Example","title":"Installing and running Pluto.jl","text":"","category":"section"},{"location":"tutorials/JuMP Model by Hand - MLD-Block.html","page":"JuMP Model by Hand - MLD-Block Example","title":"JuMP Model by Hand - MLD-Block Example","text":"Run Julia and add the package:","category":"page"},{"location":"tutorials/JuMP Model by Hand - MLD-Block.html","page":"JuMP Model by Hand - MLD-Block Example","title":"JuMP Model by Hand - MLD-Block Example","text":"]add Pluto","category":"page"},{"location":"tutorials/JuMP Model by Hand - MLD-Block.html","page":"JuMP Model by Hand - MLD-Block Example","title":"JuMP Model by Hand - MLD-Block Example","text":"Using the package manager for the first time after installing Julia can take up to 15 minutes - hang in there!","category":"page"},{"location":"tutorials/JuMP Model by Hand - MLD-Block.html","page":"JuMP Model by Hand - MLD-Block Example","title":"JuMP Model by Hand - MLD-Block Example","text":"To run the notebook server:","category":"page"},{"location":"tutorials/JuMP Model by Hand - MLD-Block.html","page":"JuMP Model by Hand - MLD-Block Example","title":"JuMP Model by Hand - MLD-Block Example","text":"import Pluto\nPluto.run()","category":"page"},{"location":"tutorials/JuMP Model by Hand - MLD-Block.html","page":"JuMP Model by Hand - MLD-Block Example","title":"JuMP Model by Hand - MLD-Block Example","text":"Pluto will open in your browser, and you can get started!","category":"page"},{"location":"manual/opf_model.html#opf-math","page":"Optimal Dispatch Mathematical Model","title":"Optimal Dispatch Mathematical model","text":"","category":"section"},{"location":"manual/opf_model.html","page":"Optimal Dispatch Mathematical Model","title":"Optimal Dispatch Mathematical Model","text":"Reproduced in part from PowerModelsDistribution AC-OPF Documentation.","category":"page"},{"location":"manual/opf_model.html","page":"Optimal Dispatch Mathematical Model","title":"Optimal Dispatch Mathematical Model","text":"The following represents the nonlinear AC optimization problem specification utilized for the optimize_dispatch algorithm contained within PowerModelsONM.","category":"page"},{"location":"manual/opf_model.html#Sets","page":"Optimal Dispatch Mathematical Model","title":"Sets","text":"","category":"section"},{"location":"manual/opf_model.html","page":"Optimal Dispatch Mathematical Model","title":"Optimal Dispatch Mathematical Model","text":"The definitions of the sets involved remain unchanged w.r.t. the balanced OPF problem definition, except for the addition of the conductor set:","category":"page"},{"location":"manual/opf_model.html","page":"Optimal Dispatch Mathematical Model","title":"Optimal Dispatch Mathematical Model","text":"beginalign\nmboxsets  nonumber \n N mbox - busesnonumber \n R mbox - references busesnonumber \n E E^R mbox - branches forward and reverse orientation nonumber \n G G_i mbox - generators and generators at bus i nonumber \n L L_i mbox - loads and loads at bus i nonumber \n S S_i mbox - shunts and shunts at bus i nonumber \n C mbox - conductors nonumber \nendalign","category":"page"},{"location":"manual/opf_model.html","page":"Optimal Dispatch Mathematical Model","title":"Optimal Dispatch Mathematical Model","text":"where the set of conductors C typically equals  abc.","category":"page"},{"location":"manual/opf_model.html#Data","page":"Optimal Dispatch Mathematical Model","title":"Data","text":"","category":"section"},{"location":"manual/opf_model.html","page":"Optimal Dispatch Mathematical Model","title":"Optimal Dispatch Mathematical Model","text":"beginalign\nmboxdata  nonumber \n S^gl_kc S^gu_kc in mathbbC  forall k in G forall c in C nonumber mathbfS^gl_k= S^gl_kc_c in C mathbfS^gu_k = S^gu_kc_c in C  \n c_2k c_1k c_0k in mathbbR  forall k in G nonumber \n v^l_ic v^u_ic in mathbbR  forall i in N forall c in C nonumber mathbfv^l_i = v^l_ic_c in C mathbfv^u_i = v^u_ic_c in C \n S^d_kcin mathbbC  forall k in L forall c in C nonumber mathbfS^d_k = S^d_kc_c in C \n mathbfY^s_kin mathbbC^ctimes c  forall k in S nonumber \n mathbfY_ij mathbfY^c_ij mathbfY^c_jiin mathbbC^ctimes c  forall (ij) in E nonumber \n s^u_ijc theta^Delta l_ijc theta^Delta u_ijc in mathbbR forall (ij) in E forall c in C nonumber mathbfs^u_ij = s^u_ijc_c in C \n V^textref_ic  in mathbbC  forall r in R  mathbfV^textref_i =  V^textref_ic_c in C \nendalign","category":"page"},{"location":"manual/opf_model.html","page":"Optimal Dispatch Mathematical Model","title":"Optimal Dispatch Mathematical Model","text":"where the notation mathbfv^l_i = v^l_ic_c in C reflects that the vector mathbfv^l_i is constructed by putting the individual phase values v^l_ic in a vector (in order abc).","category":"page"},{"location":"manual/opf_model.html","page":"Optimal Dispatch Mathematical Model","title":"Optimal Dispatch Mathematical Model","text":"Alternatively, the series impedance of a line can be written in impedance form:","category":"page"},{"location":"manual/opf_model.html","page":"Optimal Dispatch Mathematical Model","title":"Optimal Dispatch Mathematical Model","text":"mathbfZ_ij in mathbbC^ctimes c  forall (ij) in E nonumber mathbfY_ij = ( mathbfZ_ij)^-1","category":"page"},{"location":"manual/opf_model.html","page":"Optimal Dispatch Mathematical Model","title":"Optimal Dispatch Mathematical Model","text":"where superscript -1 indicates the matrix inverse. Note that mathbfY_ij or mathbfZ_ij may not be invertible, e.g. in case of single-phase branches in a three-phase grid. In this case the pseudo-inverse can be used.","category":"page"},{"location":"manual/opf_model.html#Variables-for-a-Bus-Injection-Model","page":"Optimal Dispatch Mathematical Model","title":"Variables for a Bus Injection Model","text":"","category":"section"},{"location":"manual/opf_model.html","page":"Optimal Dispatch Mathematical Model","title":"Optimal Dispatch Mathematical Model","text":"beginalign\n S^g_kc  in mathbbC  forall kin G forall c in C nonumber mathbfS^g_k = S^g_kc_c in C \n V_ic  in mathbbC  forall iin N forall c in C nonumber mathbfV_i = V_ic_c in C \n mathbfS_ij  in mathbbC^ctimes c  forall (ij) in E cup E^R \nendalign","category":"page"},{"location":"manual/opf_model.html#Mathematical-Formulation-of-a-Bus-Injection-Model","page":"Optimal Dispatch Mathematical Model","title":"Mathematical Formulation of a Bus Injection Model","text":"","category":"section"},{"location":"manual/opf_model.html","page":"Optimal Dispatch Mathematical Model","title":"Optimal Dispatch Mathematical Model","text":"A complete mathematical model is as follows,","category":"page"},{"location":"manual/opf_model.html","page":"Optimal Dispatch Mathematical Model","title":"Optimal Dispatch Mathematical Model","text":"beginalign\nmboxminimize   sum_k in G c_2k left( sum_c in C Re(S^g_kc) right)^2 + c_1k  sum_c in C Re(S^g_kc) + c_0k \nmboxsubject to   nonumber \n mathbfV_i = mathbfV^textref_i    forall r in R \n S^gl_kc leq S^g_kc leq S^gu_kc  forall k in G forall c in C  \n v^l_ic leq V_ic leq v^u_ic  forall i in N forall c in C \n sum_substackk in G_i mathbfS^g_k - sum_substackk in L_i mathbfS^d_k - sum_substackk in S_i  mathbfV_i mathbfV^H_i (mathbfY^s_k)^H = sum_substack(ij)in E_i cup E_i^R diag(mathbfS_ij)  forall iin N \n mathbfS_ij =  mathbfV_i mathbfV_i^H left( mathbfY_ij + mathbfY^c_ijright)^H - mathbfV_i mathbfV^H_j mathbfY^H_ij   forall (ij)in E \n mathbfS_ji = mathbfV_j mathbfV_j^H left( mathbfY_ij + mathbfY^c_ji right)^H - mathbfV^H_i mathbfV_j mathbfY^H_ij  forall (ij)in E \n diag(mathbfS_ij) leq mathbfs^u_ij  forall (ij) in E cup E^R \n theta^Delta l_ijc leq angle (V_ic V^*_jc) leq theta^Delta u_ijc  forall (ij) in E forall c in C\nendalign","category":"page"},{"location":"schemas/input-runtime_arguments.schema.html#Runtime-Arguments-Schema","page":"runtime-arguments.schema","title":"Runtime Arguments Schema","text":"","category":"section"},{"location":"schemas/input-runtime_arguments.schema.html","page":"runtime-arguments.schema","title":"runtime-arguments.schema","text":"If this page exists in final documentation, automatic conversion of schema to documentation failed.","category":"page"},{"location":"reference/base.html#BaseAPI","page":"Base functions","title":"Data","text":"","category":"section"},{"location":"reference/base.html","page":"Base functions","title":"Base functions","text":"Modules = [PowerModelsONM]\nPrivate = false\nOrder = [:function]\nPages = [\"base.jl\"]","category":"page"},{"location":"reference/base.html#PowerModelsONM.convert","page":"Base functions","title":"PowerModelsONM.convert","text":"convert(value::Any, path::Tuple{Vararg{String}}=tuple())\n\nHelper function to assist in converting deprecated settings to their correct types / values\n\n\n\n\n\n","category":"function"},{"location":"reference/base.html#PowerModelsONM.delete_path!-Tuple{Any, Tuple{Vararg{String}}}","page":"Base functions","title":"PowerModelsONM.delete_path!","text":"delete_path!(data::Dict{String,<:Any}, path::Tuple{Vararg{String}})\n\nHelper function for variant where data is not a dict\n\n\n\n\n\n","category":"method"},{"location":"reference/base.html#PowerModelsONM.delete_path!-Tuple{Dict{String}, Tuple{Vararg{String}}}","page":"Base functions","title":"PowerModelsONM.delete_path!","text":"delete_path!(data::Dict{String,<:Any}, path::Tuple{Vararg{String}})\n\nHelper function to delete a path within a dictionary\n\n\n\n\n\n","category":"method"},{"location":"reference/base.html#PowerModelsONM.recursive_merge-Tuple","page":"Base functions","title":"PowerModelsONM.recursive_merge","text":"recursive other merge, with vectors getting overwritten instead of appended\n\n\n\n\n\n","category":"method"},{"location":"reference/base.html#PowerModelsONM.recursive_merge-Tuple{Vararg{AbstractDict}}","page":"Base functions","title":"PowerModelsONM.recursive_merge","text":"recursive dictionary merge, similar to update data, with vectors getting overwritten instead of appended\n\n\n\n\n\n","category":"method"},{"location":"reference/base.html#PowerModelsONM.recursive_merge_including_vectors-Tuple","page":"Base functions","title":"PowerModelsONM.recursive_merge_including_vectors","text":"recursive other merge\n\n\n\n\n\n","category":"method"},{"location":"reference/base.html#PowerModelsONM.recursive_merge_including_vectors-Tuple{Vararg{AbstractDict}}","page":"Base functions","title":"PowerModelsONM.recursive_merge_including_vectors","text":"recursive dictionary merge, similar to update data\n\n\n\n\n\n","category":"method"},{"location":"reference/base.html#PowerModelsONM.recursive_merge_including_vectors-Tuple{Vararg{AbstractVector}}","page":"Base functions","title":"PowerModelsONM.recursive_merge_including_vectors","text":"recursive vector merge, similar to update data\n\n\n\n\n\n","category":"method"},{"location":"reference/base.html#PowerModelsONM.recursive_merge_timesteps-Union{Tuple{U}, Tuple{T}, Tuple{T, U}} where {T<:(AbstractVector), U<:(AbstractVector)}","page":"Base functions","title":"PowerModelsONM.recursive_merge_timesteps","text":"recursive_merge_timesteps(x::T, y::U)::promote_type(T,U) where {T<: AbstractVector,U<: AbstractVector}\n\nhelper function to recursively merge timestep vectors (e.g., of dictionaries)\n\n\n\n\n\n","category":"method"},{"location":"reference/base.html#PowerModelsONM.set_dict_value!-Tuple{Dict, String, Any}","page":"Base functions","title":"PowerModelsONM.set_dict_value!","text":"set_dict_value!(a::Dict, key::String, value::Any)\n\nHelper function to assist in setting nested Dict values\n\n\n\n\n\n","category":"method"},{"location":"reference/base.html#PowerModelsONM.set_dict_value!-Union{Tuple{T}, Tuple{T, Tuple{Vararg{String}}, Any}} where T<:Dict","page":"Base functions","title":"PowerModelsONM.set_dict_value!","text":"set_dict_value!(a::T, path::Tuple{Vararg{String}}, value::Any) where T <: Dict\n\nHelper function to assist in setting nested Dict values\n\n\n\n\n\n","category":"method"},{"location":"schemas/input-events.schema.html#Events-Schema","page":"events.schema","title":"Events Schema","text":"","category":"section"},{"location":"schemas/input-events.schema.html","page":"events.schema","title":"events.schema","text":"If this page exists in final documentation, automatic conversion of schema to documentation failed.","category":"page"},{"location":"manual/mld_model.html#mld-math","page":"Optimal Switch / Load shed Mathematical Model","title":"Optimal Load Shed Mathematical Model","text":"","category":"section"},{"location":"manual/mld_model.html","page":"Optimal Switch / Load shed Mathematical Model","title":"Optimal Switch / Load shed Mathematical Model","text":"The following contains the mathematical model for the optimal switching / load shed problem as implemented in PowerModelsONM.","category":"page"},{"location":"manual/mld_model.html","page":"Optimal Switch / Load shed Mathematical Model","title":"Optimal Switch / Load shed Mathematical Model","text":"For more information about notation see the optimal dispatch documentation, or PowerModelsDistribution AC OPF documentation.","category":"page"},{"location":"manual/mld_model.html#MLD-Variables","page":"Optimal Switch / Load shed Mathematical Model","title":"MLD Variables","text":"","category":"section"},{"location":"manual/mld_model.html","page":"Optimal Switch / Load shed Mathematical Model","title":"Optimal Switch / Load shed Mathematical Model","text":"beginalign\nmboxvariables   nonumber \n z^v_i in 01  forall i in N mbox - bus voltage onoff variable \n z^g_i in 01  forall i in G mbox - generator onoff variable \n z^b_i in 01  forall i in Bmbox - storage onoff variable \n z^d_i in 01  forall i in L mbox - load onoff variable \n z^s_i in 01  forall i in H mbox - shunt onoff variable \n z^sw_i in 01  forall i in S mbox - switch openclosed variable\nendalign","category":"page"},{"location":"manual/mld_model.html#MLD-Objective","page":"Optimal Switch / Load shed Mathematical Model","title":"MLD Objective","text":"","category":"section"},{"location":"manual/mld_model.html","page":"Optimal Switch / Load shed Mathematical Model","title":"Optimal Switch / Load shed Mathematical Model","text":"beginalign\nmboxminimize   nonumber \n sum_substackiin Ncin C10 left (1-z^v_i right ) + nonumber \n sum_substackiin Lcin C10 omega_icleft Releft (S^d_iright )right left ( 1-z^d_i right )  + nonumber \n sum_substackiin Hcin Cleft  Releft (S^s_i right )right  left (1-z^s_i right )  + nonumber \n sum_substackiin Gcin CDelta^g_i  + nonumber \n sum_substackiin Bcin CDelta^b_i  + nonumber \n sum_substackiin SDelta^sw_i\nendalign","category":"page"},{"location":"manual/mld_model.html","page":"Optimal Switch / Load shed Mathematical Model","title":"Optimal Switch / Load shed Mathematical Model","text":"where","category":"page"},{"location":"manual/mld_model.html","page":"Optimal Switch / Load shed Mathematical Model","title":"Optimal Switch / Load shed Mathematical Model","text":"beginalign\nDelta^g_i = left Releft (S^g_i(0) right ) - Releft (S^g_i right ) right  \nDelta^g_i = -left Releft (S^g_i(0) right ) - Releft (S^g_i right ) right  \nDelta^b_i = left Releft (S^b_i(0) right ) - Releft (S^b_i right ) right  \nDelta^b_i = -left Releft (S^b_i(0) right ) - Releft (S^b_i right ) right \nendalign","category":"page"},{"location":"manual/mld_model.html#MLD-Constraints","page":"Optimal Switch / Load shed Mathematical Model","title":"MLD Constraints","text":"","category":"section"},{"location":"manual/mld_model.html","page":"Optimal Switch / Load shed Mathematical Model","title":"Optimal Switch / Load shed Mathematical Model","text":"beginalign\nmboxsubject to   nonumber \n z^v_i v^l_ic leq left  V_ic right  leq z_i^v v^u_ic  forall i in Nforall c in C \n z^g_i S^gl_ic leq S^g_ic leq z^g_i S^gu_ic  forall i in Gforall c in C \n sum_substackkin G_icin C S^g_kc - sum_substackkin L_icin C z^d_k S^d_kc- sum_substackkin H_icin C z^s_k Y^s_kc left  V_ic right ^2 = nonumber \n sum_substack(ij)in E_icup E_i^Rcin C S_ijc forall i in N \n z^sw_i leq z^d_b forall i in Sforall b in L \n z^sw_i geq 0 forall i in S \n S^sw_i leq S^swu z^sw_i forall i in S \n S^sw_i geq -S^swu z^sw_i forall i in S \n V^fr_ic - V^to_ic leq v^u_ic left ( 1 - z^sw_i right ) forall i in Sforall c in C \n V^fr_ic - V^to_ic geq -v^u_ic left ( 1 - z^sw_i right ) forall i in Sforall c in C\nendalign","category":"page"},{"location":"tutorials/Use Case Examples.html#ONM-Use-Cases","page":"Use Case Examples","title":"ONM Use Cases","text":"","category":"section"},{"location":"tutorials/Use Case Examples.html","page":"Use Case Examples","title":"Use Case Examples","text":"This is a stub for an interactive Pluto.jl tutorial contained in examples.","category":"page"},{"location":"tutorials/Use Case Examples.html","page":"Use Case Examples","title":"Use Case Examples","text":"During documentation build time, this tutorial will be automatically converted to HTML, but will lose its interactivity.","category":"page"},{"location":"tutorials/Use Case Examples.html","page":"Use Case Examples","title":"Use Case Examples","text":"To experience the full interactivity of this notebook please install Pluto.jl, and open this file","category":"page"},{"location":"tutorials/Use Case Examples.html#Installing-and-running-Pluto.jl","page":"Use Case Examples","title":"Installing and running Pluto.jl","text":"","category":"section"},{"location":"tutorials/Use Case Examples.html","page":"Use Case Examples","title":"Use Case Examples","text":"Run Julia and add the package:","category":"page"},{"location":"tutorials/Use Case Examples.html","page":"Use Case Examples","title":"Use Case Examples","text":"]add Pluto","category":"page"},{"location":"tutorials/Use Case Examples.html","page":"Use Case Examples","title":"Use Case Examples","text":"Using the package manager for the first time after installing Julia can take up to 15 minutes - hang in there!","category":"page"},{"location":"tutorials/Use Case Examples.html","page":"Use Case Examples","title":"Use Case Examples","text":"To run the notebook server:","category":"page"},{"location":"tutorials/Use Case Examples.html","page":"Use Case Examples","title":"Use Case Examples","text":"import Pluto\nPluto.run()","category":"page"},{"location":"tutorials/Use Case Examples.html","page":"Use Case Examples","title":"Use Case Examples","text":"Pluto will open in your browser, and you can get started!","category":"page"},{"location":"manual/quickguide.html#Quick-Start-Guide","page":"Getting Started","title":"Quick Start Guide","text":"","category":"section"},{"location":"manual/quickguide.html","page":"Getting Started","title":"Getting Started","text":"Once PowerModelsONM is installed, To operate PowerModelsONM several other things are required, at a minimum, a distribution data set in .dss format that includes timeseries data (e.g., LoadShapes defined and assigned to some Loads or DER assets).","category":"page"},{"location":"manual/quickguide.html","page":"Getting Started","title":"Getting Started","text":"The easiest way to use PowerModelsONM's complete algorithm that includes optimal switching, optimal dispatch, fault studies and stability analysis, is to use the command line interface:","category":"page"},{"location":"manual/quickguide.html","page":"Getting Started","title":"Getting Started","text":"julia --project=path/to/PowerModelsONM path/to/PowerModelsONM/cli/entrypoint.jl -n \"path/to/network.dss\" -o \"path/to/output.json\"","category":"page"},{"location":"manual/quickguide.html","page":"Getting Started","title":"Getting Started","text":"For complete documentation of available command line arguments see parse_commandline.","category":"page"},{"location":"manual/quickguide.html","page":"Getting Started","title":"Getting Started","text":"The binary builds available on GitHub under Releases may also be used in a similar manner:","category":"page"},{"location":"manual/quickguide.html","page":"Getting Started","title":"Getting Started","text":"path/to/PowerModelsONM_binary -n \"path/to/network.dss\" -o \"path/to/output.json\"","category":"page"},{"location":"manual/quickguide.html","page":"Getting Started","title":"Getting Started","text":"Alternatively, you may wish to use PowerModelsONM from the Julia REPL, which if you want to use custom Optimizers is advisable. You should have your custom solvers installed in your primary Julia environment (e.g., v1.6), and launch the REPL with the command:","category":"page"},{"location":"manual/quickguide.html","page":"Getting Started","title":"Getting Started","text":"julia --project=path/to/PowerModelsONM","category":"page"},{"location":"manual/quickguide.html","page":"Getting Started","title":"Getting Started","text":"Once in the REPL, import PowerModelsONM with:","category":"page"},{"location":"manual/quickguide.html","page":"Getting Started","title":"Getting Started","text":"using PowerModelsONM","category":"page"},{"location":"manual/quickguide.html","page":"Getting Started","title":"Getting Started","text":"For more detailed use of PowerModelsONM from the REPL, read the Beginner's Tutorial","category":"page"},{"location":"manual/quickguide.html#Optimizers","page":"Getting Started","title":"Optimizers","text":"","category":"section"},{"location":"manual/quickguide.html","page":"Getting Started","title":"Getting Started","text":"Although PowerModelsONM includes some open source solvers by default, namely","category":"page"},{"location":"manual/quickguide.html","page":"Getting Started","title":"Getting Started","text":"NLP: Ipopt.jl\nMIP: Cbc.jl\nMINLP: Alpine.jl\nMISOCP: Juniper.jl","category":"page"},{"location":"manual/quickguide.html","page":"Getting Started","title":"Getting Started","text":"we recommend using Gurobi to solve the optimal switching problem, if it is available to you, as we have found it has far superior performance on the MISOCP problem that it is solving as compared to the open-source solutions.","category":"page"},{"location":"manual/quickguide.html","page":"Getting Started","title":"Getting Started","text":"info: Info\n","category":"page"},{"location":"manual/quickguide.html","page":"Getting Started","title":"Getting Started","text":"To use Gurobi with PowerModelsONM, do import Gurobi BEFORE import PowerModelsONM. We use Requires.jl to manage the Gurobi Environment GRB_ENV, which will check out a license that can be used throughout the optimization solves.","category":"page"},{"location":"reference/prob.html#ProblemAPI","page":"Optimization Problems","title":"Optimization Problems","text":"","category":"section"},{"location":"reference/prob.html#Optimal-Switching-/-Maximal-Load-Delivery-(MLD)","page":"Optimization Problems","title":"Optimal Switching / Maximal Load Delivery (MLD)","text":"","category":"section"},{"location":"reference/prob.html","page":"Optimization Problems","title":"Optimization Problems","text":"optimize_switches\nsolve_block_mld\nsolve_mn_block_mld\nsolve_traditional_mld\nsolve_mn_traditional_mld","category":"page"},{"location":"reference/prob.html#PowerModelsONM.optimize_switches","page":"Optimization Problems","title":"PowerModelsONM.optimize_switches","text":"optimize_switches(\n    network::Dict{String,<:Any},\n    solver;\n    formulation::Type=PMD.LPUBFDiagPowerModel,\n    algorithm::String=\"full-lookahead\"\n)::Dict{String,Any}\n\nalgorithm::String, if \"rolling-horizon\", iterates over all subnetworks in a multinetwork data structure network, in order, and solves the optimal switching / MLD problem sequentially, updating the next timestep with the new switch configurations and storage energies from the solved timestep. Otherwise, if \"full-lookahead\", will solve all time steps in a single optimization problem (default: \"full-lookahead\")\n\n\n\n\n\noptimize_switches(\n    subnetwork::Dict{String,<:Any},\n    prob::Function,\n    solver;\n    formulation=PMD.LPUBFDiagPowerModel\n)::Dict{String,Any}\n\nOptimizes switch states for load shedding on a single subnetwork (not a multinetwork), using prob\n\nOptionally, a PowerModelsDistribution formulation can be set independently, but is LinDist3Flow by default.\n\n\n\n\n\n","category":"function"},{"location":"reference/prob.html#PowerModelsONM.solve_block_mld","page":"Optimization Problems","title":"PowerModelsONM.solve_block_mld","text":"solve_block_mld(\n    data::Dict{String,<:Any},\n    model_type::Type,\n    solver;\n    kwargs...\n)::Dict{String,Any}\n\nSolves a multiconductor optimal switching (mixed-integer) problem using model_type and solver\n\nCalls back to PowerModelsDistribution.solvemcmodel, and therefore will accept any valid kwargs for that function. See PowerModelsDistribution documentation for more details.\n\n\n\n\n\n","category":"function"},{"location":"reference/prob.html#PowerModelsONM.solve_mn_block_mld","page":"Optimization Problems","title":"PowerModelsONM.solve_mn_block_mld","text":"solve_mn_block_mld(\n    data::Dict{String,<:Any},\n    model_type::Type,\n    solver;\n    kwargs...\n)::Dict{String,Any}\n\nSolves a multinetwork multiconductor optimal switching (mixed-integer) problem using model_type and solver\n\nCalls back to PowerModelsDistribution.solvemcmodel, and therefore will accept any valid kwargs for that function. See PowerModelsDistribution documentation for more details.\n\n\n\n\n\n","category":"function"},{"location":"reference/prob.html#PowerModelsONM.solve_traditional_mld","page":"Optimization Problems","title":"PowerModelsONM.solve_traditional_mld","text":"solve_traditional_mld(\n    data::Dict{String,<:Any},\n    model_type::Type,\n    solver;\n    kwargs...\n)::Dict{String,Any}\n\nSolves a multiconductor traditional mld problem using model_type and solver\n\nCalls back to PowerModelsDistribution.solvemcmodel, and therefore will accept any valid kwargs for that function. See PowerModelsDistribution documentation for more details.\n\n\n\n\n\n","category":"function"},{"location":"reference/prob.html#PowerModelsONM.solve_mn_traditional_mld","page":"Optimization Problems","title":"PowerModelsONM.solve_mn_traditional_mld","text":"solve_mn_traditional_mld(\n    data::Dict{String,<:Any},\n    model_type::Type,\n    solver;\n    kwargs...\n)::Dict{String,Any}\n\nSolves a multinetwork multiconductor traditional mld problem using model_type and solver\n\nCalls back to PowerModelsDistribution.solvemcmodel, and therefore will accept any valid kwargs for that function. See PowerModelsDistribution documentation for more details.\n\n\n\n\n\n","category":"function"},{"location":"reference/prob.html#Optimal-Dispatch","page":"Optimization Problems","title":"Optimal Dispatch","text":"","category":"section"},{"location":"reference/prob.html","page":"Optimization Problems","title":"Optimization Problems","text":"optimize_dispatch\nsolve_mn_opf","category":"page"},{"location":"reference/prob.html#PowerModelsONM.optimize_dispatch","page":"Optimization Problems","title":"PowerModelsONM.optimize_dispatch","text":"optimize_dispatch(\n    network::Dict{String,<:Any},\n    formulation::Type,\n    solver;\n    switching_solutions::Union{Missing,Dict{String,<:Any}}=missing\n)::Dict{String,Any}\n\nSolve a multinetwork optimal power flow (solve_mn_mc_opf) using formulation and solver\n\n\n\n\n\n","category":"function"},{"location":"reference/prob.html#PowerModelsONM.solve_mn_opf","page":"Optimization Problems","title":"PowerModelsONM.solve_mn_opf","text":"solve_mn_opf(\n    data::Dict{String,<:Any},\n    model_type::Type,\n    solver;\n    kwargs...\n)::Dict{String,Any}\n\nSolve multinetwork OPF with transformer tap and capacitor control\n\n\n\n\n\n","category":"function"},{"location":"reference/prob.html#Fault-stuides","page":"Optimization Problems","title":"Fault stuides","text":"","category":"section"},{"location":"reference/prob.html","page":"Optimization Problems","title":"Optimization Problems","text":"run_fault_studies\nrun_fault_study","category":"page"},{"location":"reference/prob.html#PowerModelsONM.run_fault_studies","page":"Optimization Problems","title":"PowerModelsONM.run_fault_studies","text":"run_fault_studies(\n    network::Dict{String,<:Any},\n    solver;\n    faults::Dict{String,<:Any}=Dict{String,Any}(),\n    switching_solutions::Union{Missing,Dict{String,<:Any}}=missing,\n    dispatch_solution::Union{Missing,Dict{String,<:Any}}=missing,\n    distributed::Bool=false\n)::Dict{String,Any}\n\nRuns fault studies defined in ieee13faults.json. If no faults file is provided, it will automatically generate faults using `PowerModelsProtection.buildmcfaultstudy`.\n\nIt will convert storage to limited generators, since storage is not yet supported in IVRU models in PowerModelsProtection\n\nUses run_fault_study to solve the actual fault study.\n\nsolver will determine which instantiated solver is used, \"nlp_solver\" or \"juniper_solver\"\n\n\n\n\n\n","category":"function"},{"location":"reference/prob.html#PowerModelsONM.run_fault_study","page":"Optimization Problems","title":"PowerModelsONM.run_fault_study","text":"run_fault_study(\n    subnetwork::Dict{String,<:Any},\n    faults::Dict{String,<:Any},\n    solver\n)::Dict{String,Any}\n\nUses PowerModelsProtection.solve_mc_fault_study to solve multiple faults defined in faults, applied to subnetwork, i.e., not a multinetwork, using a nonlinear solver.\n\nRequires the use of PowerModelsDistribution.IVRUPowerModel.\n\n\n\n\n\n","category":"function"},{"location":"reference/prob.html#Stability-Analysis","page":"Optimization Problems","title":"Stability Analysis","text":"","category":"section"},{"location":"reference/prob.html","page":"Optimization Problems","title":"Optimization Problems","text":"run_stability_analysis","category":"page"},{"location":"reference/prob.html#PowerModelsONM.run_stability_analysis","page":"Optimization Problems","title":"PowerModelsONM.run_stability_analysis","text":"run_stability_analysis(\n    network::Dict{String,<:Any},\n    inverters::Dict{String,<:Any},\n    solver;\n    formulation::Type=PMD.ACRUPowerModel,\n    switching_solutions::Union{Missing,Dict{String,<:Any}}=missing,\n    distributed::Bool=false\n)::Dict{String,Bool}\n\nRuns small signal stability analysis using PowerModelsStability and determines if each timestep configuration is stable\n\ninverters is an already parsed inverters file using parse_inverters\n\nThe formulation can be specified with formulation, but note that it must result in \"vm\" and \"va\" variables in the solution, or else PowerModelsDistribution.sol_data_model! must support converting the voltage variables into polar coordinates.\n\nsolver for stability analysis (NLP OPF)\n\n\n\n\n\nrun_stability_analysis(\n    subnetwork::Dict{String,<:Any},\n    omega0::Real,\n    rN::Int,\n    solver;\n    formulation::Type=PMD.ACPUPowerModel\n)::Bool\n\nRuns stability analysis on a single subnetwork (not a multinetwork) using a nonlinear solver.\n\n\n\n\n\n","category":"function"},{"location":"reference/prob.html#Optimization-solvers","page":"Optimization Problems","title":"Optimization solvers","text":"","category":"section"},{"location":"reference/prob.html","page":"Optimization Problems","title":"Optimization Problems","text":"build_solver_instances","category":"page"},{"location":"reference/prob.html#PowerModelsONM.build_solver_instances","page":"Optimization Problems","title":"PowerModelsONM.build_solver_instances","text":"build_solver_instances(;\n    nlp_solver::Union{Missing,JuMP.MOI.OptimizerWithAttributes}=missing,\n    mip_solver::Union{Missing,JuMP.MOI.OptimizerWithAttributes}=missing,\n    minlp_solver::Union{Missing,JuMP.MOI.OptimizerWithAttributes}=missing,\n    misocp_solver::Union{Missing,JuMP.MOI.OptimizerWithAttributes}=missing,\n    solver_options::Dict{String,<:Any}=Dict{String,Any}(),\n    log_level::String=\"warn\",\n)::Dict{String,Any}\n\nReturns solver instances as a Dict ready for use with JuMP Models, for NLP (\"nlp_solver\"), MIP (\"mip_solver\"), MINLP (\"minlp_solver\"), and (MI)SOC (\"misocp_solver\") problems.\n\nnlp_solver (default: missing): If missing, will use Ipopt as NLP solver, or KNITRO if knitro=true\nmip_solver (default: missing): If missing, will use Cbc as MIP solver, or Gurobi if gurobi==true\nminlp_solver (default: missing): If missing, will use Juniper with nlp_solver and mip_solver, of KNITRO if knitro=true\nmisocp_solver (default: missing): If missing will use Juniper with mip_solver, or Gurobi if gurobi==true\nsolver_options (default: Dict{String,Any}())\nlog_level (default: \"warn\")\n\n\n\n\n\n","category":"function"},{"location":"manual/onm_workflow.html#ONM-Workflow","page":"The ONM Workflow","title":"ONM Workflow","text":"","category":"section"},{"location":"manual/onm_workflow.html","page":"The ONM Workflow","title":"The ONM Workflow","text":"(Image: ONM Workflow Diagram)","category":"page"},{"location":"manual/onm_workflow.html","page":"The ONM Workflow","title":"The ONM Workflow","text":"PowerModelsONM is designed to have a straightforward workflow for optimizing the operation and recovering of distribution feeders under contingencies.","category":"page"},{"location":"manual/onm_workflow.html","page":"The ONM Workflow","title":"The ONM Workflow","text":"In particular, the workflow consists of the following steps (see diagram above):","category":"page"},{"location":"manual/onm_workflow.html","page":"The ONM Workflow","title":"The ONM Workflow","text":"Data processing and preparation\nSolving an optimal switching (osw) / load shed (mld) problem\nSolving an optimal dispatch (opf) problem using the optimal configurations\nStatistical analysis of the combined solution","category":"page"},{"location":"manual/onm_workflow.html","page":"The ONM Workflow","title":"The ONM Workflow","text":"In this document we outline essentials about each of these steps, but for full exploration of the practicalities, read the Introduction to PowerModelsONM Tutorial","category":"page"},{"location":"manual/onm_workflow.html#Data-processing","page":"The ONM Workflow","title":"Data processing","text":"","category":"section"},{"location":"manual/onm_workflow.html","page":"The ONM Workflow","title":"The ONM Workflow","text":"At a minimum, PowerModelsONM requires a network file, in DSS format, with timeseries data (e.g., LoadShapes). Without timeseries data, the ONM switching algorithm can still be utilized, but the Optimal Dispatch algorithm will error. For an example of an appropriate network definition, see our modified IEEE13 feeder.","category":"page"},{"location":"manual/onm_workflow.html","page":"The ONM Workflow","title":"The ONM Workflow","text":"There are several other supplementary files that can be included as well, of which the events data is the most important. This file defines the contingency, by either explicitly defining the switching actions, or by applying a fault to a particular asset (i.e., a line).","category":"page"},{"location":"manual/onm_workflow.html","page":"The ONM Workflow","title":"The ONM Workflow","text":"Another useful file is the network settings data, which is used to define extra information about the network, not related to the timeseries, which cannot be expressed in the DSS format, such as bus voltage magnitude bounds, cold load pickup factors, voltage angle difference bounds, microgrid definitions, etc.","category":"page"},{"location":"manual/onm_workflow.html","page":"The ONM Workflow","title":"The ONM Workflow","text":"Finally, there are the two inputs for Stability Analysis and Fault Analysis, performed post optimization. For stability analysis, inverters data is required for the analysis to produce meaningful results (see, PowerModelsStability documentation), but for fault analysis, although you can specify faults ahead of time via fault data, it is not necessary because if no faults are specified, a set of faults for analysis will be automatically generated. It should be noted however that a large number of faults will be generated automatically, which could incur serious time penalties in the completion of the algorithm. For more information, see PowerModelsProtection documentation.","category":"page"},{"location":"manual/onm_workflow.html#Optimal-Switching-Problem-(MLD)","page":"The ONM Workflow","title":"Optimal Switching Problem (MLD)","text":"","category":"section"},{"location":"manual/onm_workflow.html","page":"The ONM Workflow","title":"The ONM Workflow","text":"The optimal switching algorithm in ONM is an extension of the single-network MLD problem contained in PowerModelsDistribution, that takes into consideration certain engineering realities of distribution feeders.","category":"page"},{"location":"manual/onm_workflow.html","page":"The ONM Workflow","title":"The ONM Workflow","text":"First, it should be noted that because loads are most typically not individually controllable in distribution feeders, with a few notable exceptions, loads must largely be shed by isolating a load block with switching actions. A load block is defined as a block of buses which can be fully isolated from the grid by opening one or more operable switches.","category":"page"},{"location":"manual/onm_workflow.html","page":"The ONM Workflow","title":"The ONM Workflow","text":"To accomodate this reality, we can extended PowerModelsDistribution by adding the ability to assign single load status variables to a collection of loads (i.e., by block), and adding constraints that isolate blocks of load that are desired to be shed to maintain operability of the rest of the grid.","category":"page"},{"location":"manual/onm_workflow.html","page":"The ONM Workflow","title":"The ONM Workflow","text":"Second, the optimal switching problem currently uses the LinDist3Flow model (PowerModelsDistribution.LPUBFDiagModel), which is a quadratic approximation, due to the presence of mixed integers.","category":"page"},{"location":"manual/onm_workflow.html","page":"The ONM Workflow","title":"The ONM Workflow","text":"Finally, the optimial switching problem currently solves sequentially, rather than globally over the entire multinetwork, which means switch configurations and storage energies are manually updated after each timestep is solved.","category":"page"},{"location":"manual/onm_workflow.html","page":"The ONM Workflow","title":"The ONM Workflow","text":"The mathematical formulation can be found here.","category":"page"},{"location":"manual/onm_workflow.html#Optimal-Dispatch-(OPF)","page":"The ONM Workflow","title":"Optimal Dispatch (OPF)","text":"","category":"section"},{"location":"manual/onm_workflow.html","page":"The ONM Workflow","title":"The ONM Workflow","text":"Because the optimal switching is performed with a) a linear approximation, and b) sequentially, it is necessary to run a subsequent optimal dispatch solve on the resulting optimal configuration to ensure solution feasibility and accuracy.","category":"page"},{"location":"manual/onm_workflow.html","page":"The ONM Workflow","title":"The ONM Workflow","text":"This nonlinear AC OPF problem is a simple extension of the AC-OPF problem contained in PowerModelsDistribution, a truncated version of which is reproduced here.","category":"page"},{"location":"manual/onm_workflow.html#Statistics","page":"The ONM Workflow","title":"Statistics","text":"","category":"section"},{"location":"manual/onm_workflow.html","page":"The ONM Workflow","title":"The ONM Workflow","text":"After the optimizations have completed, ONM collects essential statistics for our default output specification. These include:","category":"page"},{"location":"manual/onm_workflow.html","page":"The ONM Workflow","title":"The ONM Workflow","text":"a device action timeline, which contains an ordered list of the switch settings and loads shed at each timestep,\na list of switch changes, i.e., switches whose state has changed from the previous timestep,\nmicrogrid statistics, including\nminimum, mean, maximum voltages in per-unit representation at each timestep,\nstate of charge of all energy storage at each timestep,\ndetails of load served in percent, i.e., how much load is supported by the feeder (substation/grid), how much by microgrids, and how much extra load are the microgrids supporting,\ndetails of the sources of generation in kW, i.e., how much power is coming from the grid, solar, energy storage, or traditional deisel generation, and\ngeneration dispatch setpoints, both real and reactive.","category":"page"},{"location":"manual/onm_workflow.html","page":"The ONM Workflow","title":"The ONM Workflow","text":"If small signal stability analysis is performed, an ordered list of whether the configuration at each timestep is small signal stable is available.","category":"page"},{"location":"manual/onm_workflow.html","page":"The ONM Workflow","title":"The ONM Workflow","text":"Finally, if fault analysis is performed, an ordered list of fault analysis results at each timestep is given, which includes,","category":"page"},{"location":"manual/onm_workflow.html","page":"The ONM Workflow","title":"The ONM Workflow","text":"the fault susceptance / conductance,\nboth the unbalanced and symmetric (sequence) fault currents at each protection device, and\nthe voltage magnitude at each protection device.","category":"page"},{"location":"manual/onm_workflow.html","page":"The ONM Workflow","title":"The ONM Workflow","text":"Full details of what is included in the output can be found in the schema files.","category":"page"},{"location":"developer/contributing.html#Pull-Requests","page":"Contributing Guide","title":"Pull Requests","text":"","category":"section"},{"location":"developer/contributing.html","page":"Contributing Guide","title":"Contributing Guide","text":"All pull requests should be reviewed by a core developer, and may include a review by a subject matter expert if the area of the PR is outside that of one of the core developers. In that case, the core developers will primarily review style and design, rather than substance.","category":"page"},{"location":"developer/contributing.html","page":"Contributing Guide","title":"Contributing Guide","text":"Every PR to PowerModelsONM should strive to meet the following guidelines.","category":"page"},{"location":"developer/contributing.html#PR-Title","page":"Contributing Guide","title":"PR Title","text":"","category":"section"},{"location":"developer/contributing.html","page":"Contributing Guide","title":"Contributing Guide","text":"Should be concise and clear, describing in a phrase the content of the PR\nShould include a prefix that describes the primary type of the PR\nADD: feature addition\nFIX: bugfix\nREF: refactor\nUPD: updates to code for e.g. version bumps of dependencies\nSTY: style changes, no changes to function names, added features, etc.\nDOC: documentation-only additions/changes\nRM: dead code removal","category":"page"},{"location":"developer/contributing.html#PR-Body","page":"Contributing Guide","title":"PR Body","text":"","category":"section"},{"location":"developer/contributing.html","page":"Contributing Guide","title":"Contributing Guide","text":"If the change is breaking, it should be clearly stated up front\nThe purpose of this PR should be clearly stated right away\nMajor changes / additions to the code should be summarized. In the case where a refactor was performed, the name changes of public functions should be documented in the body of the PR\nAny associated Issues should be referenced in the body of the PR, and it is accepted/encouraged to use Closes #XX to automatically close Issues after the PR is merged","category":"page"},{"location":"developer/contributing.html#PR-Code","page":"Contributing Guide","title":"PR Code","text":"","category":"section"},{"location":"developer/contributing.html","page":"Contributing Guide","title":"Contributing Guide","text":"An entry should be added to CHANGELOG.md for every PR\nDocumentation should be updated (See Documentation section above for guidelines)\nUnit tests should be added. In the case where existing unit tests were altered, an explanation for the change must be included\nCode should be rebased to the latest version of whatever branch the PR is aimed at (no merge conflicts!)","category":"page"},{"location":"developer/contributing.html#Versions","page":"Contributing Guide","title":"Versions","text":"","category":"section"},{"location":"developer/contributing.html","page":"Contributing Guide","title":"Contributing Guide","text":"PowerModelsONM follows the Semantic Versioning (SemVer) convention of Major.minor.patch, where Major indicates breaking changes, minor indicates non-breaking feature additions, and patch indicates non-breaking bugfixes.","category":"page"},{"location":"developer/contributing.html","page":"Contributing Guide","title":"Contributing Guide","text":"Currently, because Major==0, minor indicates breaking changes and patch indicates any non-breaking change, including both feature additions and bugfixes. Once PowerModelsONM reaches v1.0.0, we will adhere strictly to the SemVer convention.","category":"page"},{"location":"developer/contributing.html#Branch-Management","page":"Contributing Guide","title":"Branch Management","text":"","category":"section"},{"location":"developer/contributing.html","page":"Contributing Guide","title":"Contributing Guide","text":"The main branch is a protected branch, meaning that its history will always be contiguous and can never be overwritten.","category":"page"},{"location":"developer/contributing.html","page":"Contributing Guide","title":"Contributing Guide","text":"Release candidate branches of the format vM.m.0-rc are also protected branches. These branches will contain only breaking changes and will not be merged into the main branch until a new version is ready to be tagged. Pull requests including breaking changes should be directed into the next release candidate branch available, e.g. if the current version of the package is v0.9.0, the next release candidate branch will be v0.10.0-rc.","category":"page"},{"location":"developer/contributing.html","page":"Contributing Guide","title":"Contributing Guide","text":"Pull requests that include only non-breaking changes can be merged directly into the main branch once approved, and in the case of merge conflicts arising for release candidate branches, the -rc branch will need to be updated to include the latest main branch.","category":"page"},{"location":"developer/contributing.html","page":"Contributing Guide","title":"Contributing Guide","text":"Pull requests will generally be merged using squash and merge into the branch they are aimed at, with the exception of release candidate branches, which generally be merged using rebase and merge into the main branch.","category":"page"},{"location":"reference/stats.html#StatisticsAPI","page":"Solution Statistics","title":"Statistics","text":"","category":"section"},{"location":"reference/stats.html#Dispatch","page":"Solution Statistics","title":"Dispatch","text":"","category":"section"},{"location":"reference/stats.html","page":"Solution Statistics","title":"Solution Statistics","text":"Modules = [PowerModelsONM]\nPrivate = false\nOrder = [:function]\nPages = [\"stats/dispatch.jl\"]","category":"page"},{"location":"reference/stats.html#PowerModelsONM.get_timestep_dispatch!-Tuple{Dict{String}}","page":"Solution Statistics","title":"PowerModelsONM.get_timestep_dispatch!","text":"get_timestep_dispatch!(\n    args::Dict{String,<:Any}\n)::Vector{Dict{String,Any}}\n\nGets the optimal dispatch results in-place in args, for use in entrypoint, using get_timestep_dispatch.\n\n\n\n\n\n","category":"method"},{"location":"reference/stats.html#PowerModelsONM.get_timestep_dispatch-Tuple{Dict{String}, Dict{String}}","page":"Solution Statistics","title":"PowerModelsONM.get_timestep_dispatch","text":"get_timestep_dispatch(\n    solution::Dict{String,<:Any},\n    network::Dict{String,<:Any}\n)::Vector{Dict{String,Any}}\n\nReturns the dispatch information for generation assets (generator, storage, solar, voltage_source) and bus voltage magnitudes in SI units for each timestep from the optimal dispatch solution\n\n\n\n\n\n","category":"method"},{"location":"reference/stats.html#PowerModelsONM.get_timestep_dispatch-Tuple{Dict{String}, String}","page":"Solution Statistics","title":"PowerModelsONM.get_timestep_dispatch","text":"get_timestep_dispatch(::Dict{String,<:Any}, ::String)::Vector{Dict{String,Any}}\n\nHelper function for the variant where args[\"network\"] hasn't been parsed yet.\n\n\n\n\n\n","category":"method"},{"location":"reference/stats.html#PowerModelsONM.get_timestep_dispatch_optimization_metadata!-Tuple{Dict{String}}","page":"Solution Statistics","title":"PowerModelsONM.get_timestep_dispatch_optimization_metadata!","text":"get_timestep_dispatch_optimization_metadata!(\n    args::Dict{String,<:Any}\n)::Dict{String,Any}\n\nRetrieves the switching optimization results metadata from the optimal switching solution via get_timestep_dispatch_optimization_metadata and applies it in-place to args, for use with entrypoint\n\n\n\n\n\n","category":"method"},{"location":"reference/stats.html#PowerModelsONM.get_timestep_dispatch_optimization_metadata-Tuple{Dict{String, Any}}","page":"Solution Statistics","title":"PowerModelsONM.get_timestep_dispatch_optimization_metadata","text":"get_timestep_dispatch_optimization_metadata(\n    optimal_dispatch_result::Dict{String,Any}\n)::Dict{String,Any}\n\nGets the metadata from the optimal switching results for each timestep, returning a list of Dicts (if opt_switch_algorithm=\"rolling-horizon\"), or a list with a single Dict (if opt_switch_algorithm=\"full-lookahead\").\n\n\n\n\n\n","category":"method"},{"location":"reference/stats.html#PowerModelsONM.get_timestep_inverter_states!-Tuple{Dict{String}}","page":"Solution Statistics","title":"PowerModelsONM.get_timestep_inverter_states!","text":"get_timestep_inverter_states!(args::Dict{String,<:Any})::Vector{Dict{String,Any}}\n\nAdds field \"inverter\" to power flow output for inverter objects, i.e., storage generator, voltagesource, solar. See [`gettimestepinverterstates`](@ref gettimestepinverter_states)\n\n\n\n\n\n","category":"method"},{"location":"reference/stats.html#PowerModelsONM.get_timestep_inverter_states-Tuple{Dict{String}}","page":"Solution Statistics","title":"PowerModelsONM.get_timestep_inverter_states","text":"get_timestep_inverter_states(optimal_switching_results::Dict{String,<:Any})::Vector{Dict{String,Any}}\n\nGets 'inverter' state for each generation object at each timestep from optimal_switching_results. Defaults to GRID_FORMING if no inverter state is available.\n\n\n\n\n\n","category":"method"},{"location":"reference/stats.html#PowerModelsONM.get_timestep_voltage_statistics!-Tuple{Dict{String}}","page":"Solution Statistics","title":"PowerModelsONM.get_timestep_voltage_statistics!","text":"get_timestep_voltage_statistics!(\n    args::Dict{String,<:Any}\n)::Dict{String,Vector{Real}}\n\nGets voltage statistics min, mean, max for each timestep in-place in args, for use in [entrypoint][@ref entrypoint], using get_timestep_voltage_statistics\n\n\n\n\n\n","category":"method"},{"location":"reference/stats.html#PowerModelsONM.get_timestep_voltage_statistics-Tuple{Dict{String}, Dict{String}}","page":"Solution Statistics","title":"PowerModelsONM.get_timestep_voltage_statistics","text":"get_timestep_voltage_statistics(\n    solution::Dict{String,<:Any},\n    network::Dict{String,<:Any};\n    make_per_unit::Bool=true\n)::Dict{String,Vector{Real}}\n\nReturns statistics on the Minimum, Mean, and Maximum voltages for each timestep using get_voltage_min_mean_max\n\nIf make_per_unit (default: true), will return voltage statistics in per-unit representation. If make_per_unit is false, and there are different voltage bases across the network, the statistics will not make sense.\n\n\n\n\n\n","category":"method"},{"location":"reference/stats.html#PowerModelsONM.get_timestep_voltage_statistics-Tuple{Dict{String}, String}","page":"Solution Statistics","title":"PowerModelsONM.get_timestep_voltage_statistics","text":"get_timestep_voltage_statistics(::Dict{String,<:Any}, ::String)\n\nHelper function for the variant where args[\"network\"] hasn't been parsed yet.\n\n\n\n\n\n","category":"method"},{"location":"reference/stats.html#PowerModelsONM.get_voltage_min_mean_max-Tuple{Dict{String}, Dict{String}}","page":"Solution Statistics","title":"PowerModelsONM.get_voltage_min_mean_max","text":"get_voltage_min_mean_max(\n    solution::Dict{String,<:Any},\n    data::Dict{String,<:Any};\n    make_per_unit::Bool=true\n)::Tuple{Real,Real,Real}\n\nCalculates the minimum, mean, and maximum of the voltages across a network (not a multinetwork)\n\ndata is used to convert the units to perunit if `makeperunit` and the data is not already perunit.\n\nIf make_per_unit (default: true), will return voltage statistics in per-unit representation. If make_per_unit is false, and there are different voltage bases across the network, the statistics will not make sense.\n\n\n\n\n\n","category":"method"},{"location":"reference/stats.html#Actions","page":"Solution Statistics","title":"Actions","text":"","category":"section"},{"location":"reference/stats.html","page":"Solution Statistics","title":"Solution Statistics","text":"Modules = [PowerModelsONM]\nPrivate = false\nOrder = [:function]\nPages = [\"stats/actions.jl\"]","category":"page"},{"location":"reference/stats.html#PowerModelsONM.get_timestep_device_actions!-Tuple{Dict{String}}","page":"Solution Statistics","title":"PowerModelsONM.get_timestep_device_actions!","text":"get_timestep_device_actions!(args::Dict{String,<:Any})::Vector{Dict{String,Any}}\n\nGets the device actions at every timestep using get_timestep_device_actions and applies it in place to args, for use in entrypoint.\n\n\n\n\n\n","category":"method"},{"location":"reference/stats.html#PowerModelsONM.get_timestep_device_actions-Tuple{Dict{String}, Dict{String}}","page":"Solution Statistics","title":"PowerModelsONM.get_timestep_device_actions","text":"get_timestep_device_actions(\n    network::Dict{String,<:Any},\n    optimal_switching_results::Dict{String,<:Any}\n)::Vector{Dict{String,Any}}\n\nFrom the multinetwork network, determines the switch configuration at each timestep. If the switch does not exist in mld_results, the state will default back to the state given in the original network. This could happen if the switch is not dispatchable, and therefore state would not be expected in the results.\n\nWill output Vector{Dict} where each Dict will contain \"Switch configurations\", which is a Dict with switch names as keys, and the switch state, \"open\" or \"closed\" as values, and \"Shedded loads\", which is a list of load names that have been shed at that timestep.\n\n\n\n\n\n","category":"method"},{"location":"reference/stats.html#PowerModelsONM.get_timestep_device_actions-Tuple{String, Dict{String}}","page":"Solution Statistics","title":"PowerModelsONM.get_timestep_device_actions","text":"get_timestep_device_actions(::String, ::Dict{String,<:Any})::Vector{Dict{String,Any}}\n\nHelper function for the variant where args[\"network\"] hasn't been parsed yet.\n\n\n\n\n\n","category":"method"},{"location":"reference/stats.html#PowerModelsONM.get_timestep_switch_changes","page":"Solution Statistics","title":"PowerModelsONM.get_timestep_switch_changes","text":"get_timestep_switch_changes(::String, ::Dict{String,<:Any})::Vector{Vector{String}}\n\nHelper function for the variant where args[\"network\"] hasn't been parsed yet.\n\n\n\n\n\n","category":"function"},{"location":"reference/stats.html#PowerModelsONM.get_timestep_switch_changes-2","page":"Solution Statistics","title":"PowerModelsONM.get_timestep_switch_changes","text":"get_timestep_switch_changes(\n    network::Dict{String,<:Any},\n    optimal_switching_results::Dict{String,<:Any}=Dict{String,Any}()\n)::Vector{Vector{String}}\n\nGets a list of switches whose state has changed between timesteps (always expect the first timestep to be an empty list). This expects the solutions from the MLD problem to have been merged into network\n\n\n\n\n\n","category":"function"},{"location":"reference/stats.html#PowerModelsONM.get_timestep_switch_changes!-Tuple{Dict{String}}","page":"Solution Statistics","title":"PowerModelsONM.get_timestep_switch_changes!","text":"get_timestep_switch_changes!(args::Dict{String,<:Any})::Vector{Vector{String}}\n\nGets the switch changes via get_timestep_switch_changes and applies it in-place to args, for use with entrypoint\n\n\n\n\n\n","category":"method"},{"location":"reference/stats.html#PowerModelsONM.get_timestep_switch_optimization_metadata!-Tuple{Dict{String}}","page":"Solution Statistics","title":"PowerModelsONM.get_timestep_switch_optimization_metadata!","text":"get_timestep_switch_optimization_metadata!(\n    args::Dict{String,<:Any}\n)::Vector{Dict{String,Any}}\n\nRetrieves the switching optimization results metadata from the optimal switching solution via get_timestep_switch_optimization_metadata and applies it in-place to args, for use with entrypoint\n\n\n\n\n\n","category":"method"},{"location":"reference/stats.html#PowerModelsONM.get_timestep_switch_optimization_metadata-Tuple{Dict{String, Any}}","page":"Solution Statistics","title":"PowerModelsONM.get_timestep_switch_optimization_metadata","text":"get_timestep_switch_optimization_metadata(\n    optimal_switching_results::Dict{String,Any};\n    opt_switch_algorithm::String=\"full-lookahead\"\n)::Vector{Dict{String,Any}}\n\nGets the metadata from the optimal switching results for each timestep, returning a list of Dicts (if opt_switch_algorithm=\"iterative), or a list with a single Dict (if opt_switch_algorithm=\"full-lookahead\").\n\n\n\n\n\n","category":"method"},{"location":"reference/stats.html#Analysis","page":"Solution Statistics","title":"Analysis","text":"","category":"section"},{"location":"reference/stats.html","page":"Solution Statistics","title":"Solution Statistics","text":"Modules = [PowerModelsONM]\nPrivate = false\nOrder = [:function]\nPages = [\"stats/analysis.jl\"]","category":"page"},{"location":"reference/stats.html#PowerModelsONM.get_microgrid_networks-Tuple{Dict{String, Any}}","page":"Solution Statistics","title":"PowerModelsONM.get_microgrid_networks","text":"get_microgrid_networks(network::Dict{String,Any}; switch_config::Union{Missing,Dict{String,PMD.SwitchState}}=missing)::Vector{Vector{String}}\n\nCollects microgrid networks in a single timestep\n\n\n\n\n\n","category":"method"},{"location":"reference/stats.html#PowerModelsONM.get_timestep_microgrid_networks!-Tuple{Dict{String}}","page":"Solution Statistics","title":"PowerModelsONM.get_timestep_microgrid_networks!","text":"get_timestep_microgrid_networks!(args::Dict{String,<:Any})::Vector{Dict{String,Any}}\n\nCollects microgrid networks per timestep and assigns them to 'Device action timestep'/'Microgrid networks'\n\n\n\n\n\n","category":"method"},{"location":"reference/stats.html#PowerModelsONM.get_timestep_microgrid_networks-Tuple{Dict{String, Any}, Dict{String, Any}}","page":"Solution Statistics","title":"PowerModelsONM.get_timestep_microgrid_networks","text":"get_timestep_microgrid_networks(network::Dict{String,Any}, switching_results::Dict{String,Any})::Vector{Vector{Vector{String}}}\n\nCollects microgrid networks per timestep\n\n\n\n\n\n","category":"method"},{"location":"reference/stats.html#PowerModelsONM.get_timestep_microgrid_networks_from_output_file-Tuple{String, Dict{String}}","page":"Solution Statistics","title":"PowerModelsONM.get_timestep_microgrid_networks_from_output_file","text":"get_timestep_microgrid_networks_from_output_file(output::String, network::Dict{String,<:Any})::Vector{Vector{Vector{String}}}\n\nAnalytics for determining when microgrids network from output file\n\n\n\n\n\n","category":"method"},{"location":"reference/stats.html#Faults","page":"Solution Statistics","title":"Faults","text":"","category":"section"},{"location":"reference/stats.html","page":"Solution Statistics","title":"Solution Statistics","text":"Modules = [PowerModelsONM]\nPrivate = false\nOrder = [:function]\nPages = [\"stats/fault.jl\"]","category":"page"},{"location":"reference/stats.html#PowerModelsONM.get_timestep_fault_currents!-Tuple{Dict{String}}","page":"Solution Statistics","title":"PowerModelsONM.get_timestep_fault_currents!","text":"get_timestep_fault_currents!(\n    args::Dict{String,<:Any}\n)::Vector{Dict{String,Any}}\n\nGets fault currents for switches and corresponding fault from study in-place in args, for use in entrypoint, using get_timestep_fault_currents.\n\n\n\n\n\n","category":"method"},{"location":"reference/stats.html#PowerModelsONM.get_timestep_fault_currents-Tuple{Dict{String}, Dict{String}, Dict{String}}","page":"Solution Statistics","title":"PowerModelsONM.get_timestep_fault_currents","text":"get_timestep_fault_currents(\n    fault_studies_results::Dict{String,<:Any},\n    faults::Dict{String,<:Any},\n    network::Dict{String,<:Any};\n    ret_protection_only::Bool=false\n)::Vector{Dict{String,Any}}\n\nGets information about the results of fault studies at each timestep, including:\n\ninformation about the fault, such as\nthe admittance (\"conductance (S)\" and \"susceptance (S)\"),\nthe bus at which the fault is applied\nthe type of fault (3p, 3pg, llg, ll, lg), and\nto which connections the fault applies\ninformation about the state at the network's protection, including\nthe fault current |I| (A)\nthe zero-sequence fault current |I0| (A)\nthe positive-sequence fault current |I1| (A)\nthe negative-sequence fault current |I2| (A)\nthe bus voltage from the from-side of the switch |V| (V)\nthe bus voltage angle from the from-side of the switch phi (deg)\n\nret_protection_only==false indicates that currents and voltages should be returned for all lines where switch=y, and if true, should only return switches for which a protection device is defined (recloser, relay, fuse)\n\n\n\n\n\n","category":"method"},{"location":"reference/stats.html#PowerModelsONM.get_timestep_fault_currents-Tuple{Dict{String}, String, Dict{String}}","page":"Solution Statistics","title":"PowerModelsONM.get_timestep_fault_currents","text":"get_timestep_fault_currents(\n    fault_studies_results::Dict{String,<:Any},\n    faults::String,\n    network::Dict{String,<:Any}\n)::Vector{Dict{String,Any}}\n\nSpecial case where the faults string was not parsed\n\n\n\n\n\n","category":"method"},{"location":"reference/stats.html#PowerModelsONM.get_timestep_fault_currents-Tuple{Dict{String}, String, String}","page":"Solution Statistics","title":"PowerModelsONM.get_timestep_fault_currents","text":"get_timestep_fault_currents(::Dict{String,<:Any}, ::String, ::String; ret_protection_only::Bool=false)::Vector{Dict{String,Any}}\n\nHelper function for the variant where args[\"network\"] hasn't been parsed yet.\n\n\n\n\n\n","category":"method"},{"location":"reference/stats.html#PowerModelsONM.get_timestep_fault_study_metadata!-Tuple{Dict{String}}","page":"Solution Statistics","title":"PowerModelsONM.get_timestep_fault_study_metadata!","text":"get_timestep_fault_study_metadata!(\n    args::Dict{String,<:Any}\n)::Vector{Dict{String,Any}}\n\nRetrieves the switching optimization results metadata from the optimal switching solution via get_timestep_fault_study_metadata and applies it in-place to args, for use with entrypoint\n\n\n\n\n\n","category":"method"},{"location":"reference/stats.html#PowerModelsONM.get_timestep_fault_study_metadata-Tuple{Dict{String, Any}}","page":"Solution Statistics","title":"PowerModelsONM.get_timestep_fault_study_metadata","text":"get_timestep_fault_study_metadata(\n    fault_studies_results::Dict{String,Any}\n)::Vector{Dict{String,Any}}\n\nGets the metadata from the optimal switching results for each timestep, returning a list of Dicts (if opt_switch_algorithm=\"rolling-horizon\"), or a list with a single Dict (if opt_switch_algorithm=\"full-lookahead\").\n\n\n\n\n\n","category":"method"},{"location":"reference/stats.html#Microgrid","page":"Solution Statistics","title":"Microgrid","text":"","category":"section"},{"location":"reference/stats.html","page":"Solution Statistics","title":"Solution Statistics","text":"Modules = [PowerModelsONM]\nPrivate = false\nOrder = [:function]\nPages = [\"stats/microgrid.jl\"]","category":"page"},{"location":"reference/stats.html#PowerModelsONM.get_timestep_generator_profiles!-Tuple{Dict{String}}","page":"Solution Statistics","title":"PowerModelsONM.get_timestep_generator_profiles!","text":"get_timestep_generator_profiles!(\n    args::Dict{String,<:Any}\n)::Dict{String,Vector{Real}}\n\nGets generator profile statistics for each timestep in-place in args, for use in entrypoint, using get_timestep_generator_profiles\n\n\n\n\n\n","category":"method"},{"location":"reference/stats.html#PowerModelsONM.get_timestep_generator_profiles-Tuple{Dict{String}}","page":"Solution Statistics","title":"PowerModelsONM.get_timestep_generator_profiles","text":"get_timestep_generator_profiles(\n    solution::Dict{String,<:Any}\n)::Dict{String,Vector{Real}}\n\nReturns statistics about the generator profiles from the optimal dispatch solution:\n\n\"Grid mix (kW)\": how much power is from the substation\n\"Solar DG (kW)\": how much power is from Solar PV DER\n\"Energy storage (kW): how much power is from Energy storage DER\n\"Diesel DG (kW)\": how much power is from traditional generator DER\n\n\n\n\n\n","category":"method"},{"location":"reference/stats.html#PowerModelsONM.get_timestep_load_served","page":"Solution Statistics","title":"PowerModelsONM.get_timestep_load_served","text":"get_timestep_load_served(::Dict{String,<:Any}, network::String, switching_solution::Union{Missing,Dict{String,<:Any}}=missing)\n\nHelper function for the variant where args[\"network\"] hasn't been parsed yet.\n\n\n\n\n\n","category":"function"},{"location":"reference/stats.html#PowerModelsONM.get_timestep_load_served-2","page":"Solution Statistics","title":"PowerModelsONM.get_timestep_load_served","text":"get_timestep_load_served(\n    solution::Dict{String,<:Any},\n    network::Dict{String,<:Any}\n)::Dict{String,Vector{Real}}\n\nReturns Load statistics from an optimal dispatch solution, and compares to the base load (non-shedded) in network, giving statistics for\n\n\"Feeder load (%)\": How much load is the feeder supporting,\n\"Microgrid load (%)\": How much load is(are) the microgrid(s) supporting,\n\"Bonus load via microgrid (%)\": How much extra load is being supported.\n\nNote\n\nCurrently, because microgrids are not explicitly defined yet (see 'settings' file for initial implementation of microgrid tagging), \"Bonus load via microgrid (%)\" only indicates how much charging is being performed on Storage.\n\n\n\n\n\n","category":"function"},{"location":"reference/stats.html#PowerModelsONM.get_timestep_load_served!-Tuple{Dict{String}}","page":"Solution Statistics","title":"PowerModelsONM.get_timestep_load_served!","text":"get_timestep_load_served!(\n    args::Dict{String,<:Any}\n)::Dict{String,Vector{Real}}\n\nGets Load served statistics in-place in args, for use in entrypoint, using get_timestep_load_served.\n\n\n\n\n\n","category":"method"},{"location":"reference/stats.html#PowerModelsONM.get_timestep_storage_soc!-Tuple{Dict{String}}","page":"Solution Statistics","title":"PowerModelsONM.get_timestep_storage_soc!","text":"get_timestep_storage_soc!(\n    args::Dict{String,<:Any}\n)::Vector{Real}\n\nGets storage energy remaining percentage for each timestep in-place in args, for use in entrypoint, using get_timestep_storage_soc\n\n\n\n\n\n","category":"method"},{"location":"reference/stats.html#PowerModelsONM.get_timestep_storage_soc-Tuple{Dict{String}, Dict{String}}","page":"Solution Statistics","title":"PowerModelsONM.get_timestep_storage_soc","text":"get_timestep_storage_soc(\n    solution::Dict{String,<:Any},\n    network::Dict{String,<:Any}\n)::Vector{Real}\n\nReturns the storage state of charge, i.e., how much energy is remaining in all of the the energy storage DER based on the optimal dispatch solution. Needs network to give percentage.\n\n\n\n\n\n","category":"method"},{"location":"reference/stats.html#PowerModelsONM.get_timestep_storage_soc-Tuple{Dict{String}, String}","page":"Solution Statistics","title":"PowerModelsONM.get_timestep_storage_soc","text":"get_timestep_storage_soc(::Dict{String,<:Any}, ::String)\n\nHelper function for the variant where args[\"network\"] hasn't been parsed yet.\n\n\n\n\n\n","category":"method"},{"location":"reference/stats.html#Stability","page":"Solution Statistics","title":"Stability","text":"","category":"section"},{"location":"reference/stats.html","page":"Solution Statistics","title":"Solution Statistics","text":"Modules = [PowerModelsONM]\nPrivate = false\nOrder = [:function]\nPages = [\"stats/stability.jl\"]","category":"page"},{"location":"reference/stats.html#PowerModelsONM.get_timestep_stability!-Tuple{Dict{String}}","page":"Solution Statistics","title":"PowerModelsONM.get_timestep_stability!","text":"get_timestep_stability!(\n    args::Dict{String,<:Any}\n)::Vector{Bool}\n\nGets the stability at each timestep and applies it in-place to args, for use in entrypoint, using get_timestep_stability\n\n\n\n\n\n","category":"method"},{"location":"reference/stats.html#PowerModelsONM.get_timestep_stability-Tuple{Dict{String, Bool}}","page":"Solution Statistics","title":"PowerModelsONM.get_timestep_stability","text":"get_timestep_stability(\n    is_stable::Dict{String,Bool}\n)::Vector{Bool}\n\nThis is a placeholder function that simple passes through the is_stable Vector back, until the Stability feature gets more complex.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/Block MLD Basic Example.html#Block-MLD-Basic-Example","page":"Block MLD Basic Example","title":"Block MLD Basic Example","text":"","category":"section"},{"location":"tutorials/Block MLD Basic Example.html","page":"Block MLD Basic Example","title":"Block MLD Basic Example","text":"This is a stub for an interactive Pluto.jl tutorial contained in examples.","category":"page"},{"location":"tutorials/Block MLD Basic Example.html","page":"Block MLD Basic Example","title":"Block MLD Basic Example","text":"During documentation build time, this tutorial will be automatically converted to HTML, but will lose its interactivity.","category":"page"},{"location":"tutorials/Block MLD Basic Example.html","page":"Block MLD Basic Example","title":"Block MLD Basic Example","text":"To experience the full interactivity of this notebook please install Pluto.jl, and open this file","category":"page"},{"location":"tutorials/Block MLD Basic Example.html#Installing-and-running-Pluto.jl","page":"Block MLD Basic Example","title":"Installing and running Pluto.jl","text":"","category":"section"},{"location":"tutorials/Block MLD Basic Example.html","page":"Block MLD Basic Example","title":"Block MLD Basic Example","text":"Run Julia and add the package:","category":"page"},{"location":"tutorials/Block MLD Basic Example.html","page":"Block MLD Basic Example","title":"Block MLD Basic Example","text":"]add Pluto","category":"page"},{"location":"tutorials/Block MLD Basic Example.html","page":"Block MLD Basic Example","title":"Block MLD Basic Example","text":"Using the package manager for the first time after installing Julia can take up to 15 minutes - hang in there!","category":"page"},{"location":"tutorials/Block MLD Basic Example.html","page":"Block MLD Basic Example","title":"Block MLD Basic Example","text":"To run the notebook server:","category":"page"},{"location":"tutorials/Block MLD Basic Example.html","page":"Block MLD Basic Example","title":"Block MLD Basic Example","text":"import Pluto\nPluto.run()","category":"page"},{"location":"tutorials/Block MLD Basic Example.html","page":"Block MLD Basic Example","title":"Block MLD Basic Example","text":"Pluto will open in your browser, and you can get started!","category":"page"},{"location":"schemas/input-settings.schema.html#Settings-Schema","page":"settings.schema","title":"Settings Schema","text":"","category":"section"},{"location":"schemas/input-settings.schema.html","page":"settings.schema","title":"settings.schema","text":"If this page exists in final documentation, automatic conversion of schema to documentation failed.","category":"page"},{"location":"reference/types.html#TypesAPI","page":"Types","title":"Data","text":"","category":"section"},{"location":"reference/types.html","page":"Types","title":"Types","text":"","category":"page"},{"location":"reference/internal.html#Internal-Functions","page":"Internal Functions","title":"Internal Functions","text":"","category":"section"},{"location":"reference/internal.html","page":"Internal Functions","title":"Internal Functions","text":"Modules = [PowerModelsONM]\nFilter = t -> startswith(string(t), \"_\")","category":"page"},{"location":"reference/internal.html#PowerModelsONM._check_switch_state_feasibility-Tuple{Dict{String, Any}}","page":"Internal Functions","title":"PowerModelsONM._check_switch_state_feasibility","text":"_check_switch_state_feasibility(eng::Dict{String,Any})\n\nHelper function to aid users in determining whether network model has a feasible starting switch configuration, assuming radiality constraints are applied.\n\n\n\n\n\n","category":"method"},{"location":"reference/internal.html#PowerModelsONM._convert_event_data_types!-Tuple{Vector{<:Dict{String}}}","page":"Internal Functions","title":"PowerModelsONM._convert_event_data_types!","text":"_convert_event_data_types!(\n    events::Vector{<:Dict{String,<:Any}}\n)::Vector{Dict{String,Any}}\n\nHelper function to convert JSON data types to native data types (Enums) in events.\n\n\n\n\n\n","category":"method"},{"location":"reference/internal.html#PowerModelsONM._correct_switch_directions!-Tuple{Dict{String}, Dict{Int64, Set}, Dict{Int64, Int64}, Vector{Int64}}","page":"Internal Functions","title":"PowerModelsONM._correct_switch_directions!","text":"_correct_branch_directions!(switches::Dict{String,<:Any}, ref::Dict{Symbol,<:Any})::Dict{String,Any}\n\nHelper function that will attempt to make a directed graph that is strong-connected by adjusting the switch directions starting from the voltage_sources\n\n\n\n\n\n","category":"method"},{"location":"reference/internal.html#PowerModelsONM._deepcopy_args!-Tuple{Dict{String}}","page":"Internal Functions","title":"PowerModelsONM._deepcopy_args!","text":"_deepcopy_args!(args::Dict{String,<:Any})::Dict{String,Any}\n\nCopies arguments to \"raw_args\" in-place in args, for use in entrypoint\n\n\n\n\n\n","category":"method"},{"location":"reference/internal.html#PowerModelsONM._dss2eng_protection_locations!-Tuple{Dict{String}, Dict{String}}","page":"Internal Functions","title":"PowerModelsONM._dss2eng_protection_locations!","text":"_dss2eng_protection!(\n    eng::Dict{String,<:Any},\n    dss::Dict{String,<:Any}\n)\n\nExtension function for converting opendss protection into protection objects for protection optimization.\n\n\n\n\n\n","category":"method"},{"location":"reference/internal.html#PowerModelsONM._find_next_nw_id_from_fault_duration-Tuple{Dict{String}, String, Real}","page":"Internal Functions","title":"PowerModelsONM._find_next_nw_id_from_fault_duration","text":"_find_next_nw_id_from_fault_duration(\n    network::Dict{String,<:Any},\n    nw_id::String,\n    duration::Real\n)::Union{String,Missing}\n\nHelper function to find the next timestep following a fault given its duration in ms\n\n\n\n\n\n","category":"method"},{"location":"reference/internal.html#PowerModelsONM._find_nw_id_from_timestep-Tuple{Dict{String}, Union{Real, String}}","page":"Internal Functions","title":"PowerModelsONM._find_nw_id_from_timestep","text":"_find_nw_id_from_timestep(\n    network::Dict{String,<:Any},\n    timestep::Union{Real,String}\n)::String\n\nHelper function to find the multinetwork id of the subnetwork of network corresponding most closely to a timestep.\n\n\n\n\n\n","category":"method"},{"location":"reference/internal.html#PowerModelsONM._find_switch_id_from_source_id-Tuple{Dict{String}, String}","page":"Internal Functions","title":"PowerModelsONM._find_switch_id_from_source_id","text":"_find_switch_id_from_source_id(\n    network::Dict{String,<:Any},\n    source_id::String\n)::Union{String,Missing}\n\nHelper function to find a switch id in the network model based on the dss source_id\n\n\n\n\n\n","category":"method"},{"location":"reference/internal.html#PowerModelsONM._find_switch_ids_by_faulted_asset-Tuple{Dict{String}, String}","page":"Internal Functions","title":"PowerModelsONM._find_switch_ids_by_faulted_asset","text":"helper function to find which switches need to be opened to isolate a fault on asset given by source_id\n\n\n\n\n\n","category":"method"},{"location":"reference/internal.html#PowerModelsONM._fix_enums!-Tuple{Any, Any, Any}","page":"Internal Functions","title":"PowerModelsONM._fix_enums!","text":"helper function to convert stringified enums\n\n\n\n\n\n","category":"method"},{"location":"reference/internal.html#PowerModelsONM._fix_fault_data_types!-Tuple{Dict{String}}","page":"Internal Functions","title":"PowerModelsONM._fix_fault_data_types!","text":"_fix_fault_data_types!(faults::Dict{String,<:Any})\n\nHelper function to help parse data types for multiconductor fault study data structures from JSON faults.\n\n\n\n\n\n","category":"method"},{"location":"reference/internal.html#PowerModelsONM._fix_nulls!-Tuple{Any, Any, Any}","page":"Internal Functions","title":"PowerModelsONM._fix_nulls!","text":"helper function to fix null values from json (usually Inf or NaN)\n\n\n\n\n\n","category":"method"},{"location":"reference/internal.html#PowerModelsONM._fix_symbols!-Tuple{Any, Any, Any}","page":"Internal Functions","title":"PowerModelsONM._fix_symbols!","text":"helper function to convert stringified Symbols\n\n\n\n\n\n","category":"method"},{"location":"reference/internal.html#PowerModelsONM._get_formulation-Tuple{String}","page":"Internal Functions","title":"PowerModelsONM._get_formulation","text":"_get_formulation(form_string::String)\n\nhelper function to convert from opt-disp-formulation, opt-switch-formulation string to PowerModelsDistribution Type\n\n\n\n\n\n","category":"method"},{"location":"reference/internal.html#PowerModelsONM._get_formulation-Tuple{Type}","page":"Internal Functions","title":"PowerModelsONM._get_formulation","text":"_get_formulation(form::Type)\n\nhelper function to convert from PowerModelsDistribution Type to PowerModelsDistribution Type\n\n\n\n\n\n","category":"method"},{"location":"reference/internal.html#PowerModelsONM._make_filtered_logger-Tuple{Vector{<:Module}, Base.CoreLogging.LogLevel}","page":"Internal Functions","title":"PowerModelsONM._make_filtered_logger","text":"_make_filtered_logger(mods::Vector, level::Logging.LogLevel)\n\nHelper function to create the filtered logger for PMD\n\n\n\n\n\n","category":"method"},{"location":"reference/internal.html#PowerModelsONM._make_filtered_logger-Tuple{Vector{Tuple{Module, Base.CoreLogging.LogLevel}}}","page":"Internal Functions","title":"PowerModelsONM._make_filtered_logger","text":"_make_filtered_logger(mods::Vector{Tuple{<:Module,Logging.LogLevel}})\n\nHelper function to create the filtered logger for PMD\n\n\n\n\n\n","category":"method"},{"location":"reference/internal.html#PowerModelsONM._map_eng2math_scenarios!-Tuple{Dict{String}, Dict{String}}","page":"Internal Functions","title":"PowerModelsONM._map_eng2math_scenarios!","text":"_map_eng2math_scenarios!(data_math::Dict{String,<:Any}, data_eng::Dict{String,<:Any}; pass_props::Vector{String}=String[])\n\nConverts engineering scenarios into mathematical scenarios.\n\n\n\n\n\n","category":"method"},{"location":"reference/internal.html#PowerModelsONM._prepare_dispatch_data","page":"Internal Functions","title":"PowerModelsONM._prepare_dispatch_data","text":"_prepare_dispatch_data(\n    network::Dict{String,<:Any},\n    switching_solutions::Union{Missing,Dict{String,<:Any}}=missing\n)::Dict{String,Any}\n\nHelper function to prepare data for running a optimal dispatch problem, copying in solutions from the switching results, if present.\n\n\n\n\n\n","category":"function"},{"location":"reference/internal.html#PowerModelsONM._prepare_fault_study_multinetwork_data","page":"Internal Functions","title":"PowerModelsONM._prepare_fault_study_multinetwork_data","text":"_prepare_fault_study_multinetwork_data(\n    network::Dict{String,<:Any},\n    switching_solutions::Union{Missing,Dict{String,<:Any}}=missing,\n    dispatch_solution::Union{Missing,Dict{String,<:Any}}=missing\n)\n\nHelper function that helps to prepare all of the subnetworks for use in PowerModelsProtection.solve_mc_fault_study\n\n\n\n\n\n","category":"function"},{"location":"reference/internal.html#PowerModelsONM._prepare_optimal_switching_data-Tuple{Dict{String}}","page":"Internal Functions","title":"PowerModelsONM._prepare_optimal_switching_data","text":"_prepare_optimal_switching_data(network::Dict{String,<:Any})::Dict{String,Any}\n\nHelper function to prepare optimal switching data structure.\n\n\n\n\n\n","category":"method"},{"location":"reference/internal.html#PowerModelsONM._prepare_stability_multinetwork_data","page":"Internal Functions","title":"PowerModelsONM._prepare_stability_multinetwork_data","text":"_prepare_stability_multinetwork_data(\n    network::Dict{String,<:Any},\n    inverters::Dict{String,<:Any},\n    switching_solutions::Union{Missing,Dict{String,<:Any}}=missing,\n    dispatch_solution::Union{Missing,Dict{String,<:Any}}=missing\n)::Dict{String,Any}\n\nHelper function to prepare the multinetwork data for stability analysis (adds inverters, data_model).\n\n\n\n\n\n","category":"function"},{"location":"reference/internal.html#PowerModelsONM._recursive_initialize_output_from_schema!-Tuple{Dict{String}, Dict{String}}","page":"Internal Functions","title":"PowerModelsONM._recursive_initialize_output_from_schema!","text":"_recursive_initialize_output_from_schema!(output::Dict{String,<:Any}, schema_properties::Dict{String,<:Any})\n\nHelper function to initialize the output data structure from the output schema\n\n\n\n\n\n","category":"method"},{"location":"reference/internal.html#PowerModelsONM._ref_add_load_blocks!-Tuple{Dict{Symbol}, Dict{String}}","page":"Internal Functions","title":"PowerModelsONM._ref_add_load_blocks!","text":"_ref_add_load_blocks!(ref::Dict{Symbol,<:Any}, data::Dict{String,<:Any})\n\nRef extension to add load blocks to ref at a single time step\n\n\n\n\n\n","category":"method"},{"location":"reference/internal.html#PowerModelsONM._ref_add_options!-Tuple{Dict{Symbol}, Dict{String}}","page":"Internal Functions","title":"PowerModelsONM._ref_add_options!","text":"_ref_add_options!(ref::Dict{Symbol,<:Any}, data::Dict{String,<:Any})\n\nRef extension to add options to ref for all time steps\n\n\n\n\n\n","category":"method"},{"location":"reference/internal.html#PowerModelsONM._ref_add_scenarios!-Tuple{Dict{Symbol}, Dict{String}}","page":"Internal Functions","title":"PowerModelsONM._ref_add_scenarios!","text":"_ref_add_scenarios!(ref::Dict{Symbol,<:Any}, data::Dict{String,<:Any})\n\nRef extension to add scenario information to ref at a single time step\n\n\n\n\n\n","category":"method"},{"location":"reference/internal.html#PowerModelsONM._sanitize_results_metadata!-Tuple{Dict{String}}","page":"Internal Functions","title":"PowerModelsONM._sanitize_results_metadata!","text":"_sanitize_results_metadata!(metadata::Dict{String,<:Any})::Dict{String,Any}\n\nHelper function to turn any field that is not a Real into a String.\n\n\n\n\n\n","category":"method"},{"location":"reference/internal.html#PowerModelsONM._set_property!-Tuple{Dict{String}, Tuple{Vararg{AbstractString}}, Any}","page":"Internal Functions","title":"PowerModelsONM._set_property!","text":"_set_property!(data::Dict{String,<:Any}, path::Tuple{Vararg{String}}, value::Any)\n\nHelper function to set a property to value at an arbitrary nested path in a dictionary\n\n\n\n\n\n","category":"method"},{"location":"reference/internal.html#PowerModelsONM._solution_blocks!-Tuple{Dict{String}, Dict{Symbol}}","page":"Internal Functions","title":"PowerModelsONM._solution_blocks!","text":"_solution_statuses!(sol::Dict{String,<:Any}, ref::Dict{Symbol,<:Any})\n\nAdds block ids (as generated in the ref), and microgrid_ids to the solution\n\n\n\n\n\n","category":"method"},{"location":"reference/internal.html#PowerModelsONM._solution_inverter!-Tuple{Dict{String}, Dict{String}}","page":"Internal Functions","title":"PowerModelsONM._solution_inverter!","text":"_solution_inverter!(data::Dict{String,<:Any}, sol::Dict{String,<:Any})\n\nConverts inverter to Inverter enum, from a single time step.\n\n\n\n\n\n","category":"method"},{"location":"reference/internal.html#PowerModelsONM._solution_reference_buses!-Tuple{Dict{String}, Dict{String}}","page":"Internal Functions","title":"PowerModelsONM._solution_reference_buses!","text":"_solution_reference_buses!(data::Dict{String,<:Any}, sol::Dict{String,<:Any})\n\nRaises bus_type from math model up to solution for reporting, from a single time step.\n\n\n\n\n\n","category":"method"},{"location":"reference/internal.html#PowerModelsONM._solution_statuses!-Tuple{Dict{String}}","page":"Internal Functions","title":"PowerModelsONM._solution_statuses!","text":"_solution_statuses!(sol::Dict{String,<:Any})\n\nConverts all status fields in a solution sol from Float64 to Status enum, for a single time step.\n\n\n\n\n\n","category":"method"},{"location":"reference/internal.html#PowerModelsONM._update_inverter_settings!-Tuple{Dict{String}, Dict{String}}","page":"Internal Functions","title":"PowerModelsONM._update_inverter_settings!","text":"_update_inverter_settings!(data::Dict{String,<:Any}, sol::Dict{String,<:Any})\n\nHelper function to update inverter settings from a solution, for the mld robust problem to check for feasibility.\n\n\n\n\n\n","category":"method"},{"location":"reference/internal.html#PowerModelsONM._update_storage_capacity!-Tuple{Dict{String}, Dict{String}}","page":"Internal Functions","title":"PowerModelsONM._update_storage_capacity!","text":"_update_storage_capacity!(data::Dict{String,<:Any}, solution::Dict{String,<:Any})\n\nHelper function to update storage capacity for the next subnetwork based on a solution, for the rolling horizon algorithm.\n\n\n\n\n\n","category":"method"},{"location":"reference/internal.html#PowerModelsONM._update_switch_settings!-Tuple{Dict{String}, Dict{String}}","page":"Internal Functions","title":"PowerModelsONM._update_switch_settings!","text":"_update_switch_settings!(data::Dict{String,<:Any}, solution::Dict{String,<:Any})\n\nHelper function to update switch settings from a solution, for the rolling horizon algorithm.\n\n\n\n\n\n","category":"method"},{"location":"reference/internal.html#PowerModelsONM._validate_against_schema-Tuple{Union{Dict{String}, Vector}, JSONSchema.Schema}","page":"Internal Functions","title":"PowerModelsONM._validate_against_schema","text":"_validate_against_schema(\n    data::Union{Dict{String,<:Any}, Vector},\n    schema::JSONSchema.Schema\n)::Bool\n\nValidates dict or vector structure data against json schema using JSONSchema.jl.\n\n\n\n\n\n","category":"method"},{"location":"reference/internal.html#PowerModelsONM._validate_against_schema-Tuple{Union{Dict{String}, Vector}, String}","page":"Internal Functions","title":"PowerModelsONM._validate_against_schema","text":"_validate_against_schema(\n    data::Union{Dict{String,<:Any}, Vector},\n    schema_name::String\n)::Bool\n\nValidates dict or vector structure data against json schema given by schema_name.\n\n\n\n\n\n","category":"method"},{"location":"reference/internal.html#Constants","page":"Internal Functions","title":"Constants","text":"","category":"section"},{"location":"reference/internal.html","page":"Internal Functions","title":"Internal Functions","text":"PowerModelsONM._default_ref_extensions\nPowerModelsONM._default_solution_processors\nPowerModelsONM._formulation_lookup","category":"page"},{"location":"reference/internal.html#PowerModelsONM._default_ref_extensions","page":"Internal Functions","title":"PowerModelsONM._default_ref_extensions","text":"default ref_extension functions\n\n\n\n\n\n","category":"constant"},{"location":"reference/internal.html#PowerModelsONM._default_solution_processors","page":"Internal Functions","title":"PowerModelsONM._default_solution_processors","text":"default solution_processor functions\n\n\n\n\n\n","category":"constant"},{"location":"reference/internal.html#PowerModelsONM._formulation_lookup","page":"Internal Functions","title":"PowerModelsONM._formulation_lookup","text":"string to PowerModelsDistribution type conversion for opt-disp-formulation\n\n\n\n\n\n","category":"constant"},{"location":"index.html#PowerModelsONM.jl","page":"Introduction","title":"PowerModelsONM.jl","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"CurrentModule = PowerModelsONM","category":"page"},{"location":"index.html#What-is-PowerModelsONM?","page":"Introduction","title":"What is PowerModelsONM?","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"PowerModelsONM.jl is a Julia/JuMP-based library for optimizing the operations of networked microgrids under contingencies, in particular unbalanced (i.e., multiconductor) power distribution networks.","category":"page"},{"location":"index.html#Resources-for-Getting-Started","page":"Introduction","title":"Resources for Getting Started","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Read the Installation Guide","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Read the Quickstart Guide","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Read the introductory tutorial Introduction to PowerModelsONM","category":"page"},{"location":"index.html#How-the-documentation-is-structured","page":"Introduction","title":"How the documentation is structured","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The following is a high-level overview of how our documetation is structured. There are three primary sections:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The Manual contains detailed documentation for certain aspects of PowerModelsONM, such as\nTutorials contains working examples of how to use PowerModelsONM. Start here if you are new to PowerModelsONM.\nThe API Reference contains a complete list of the functions you can use in PowerModelsONM. Look here if you want to know how to use a particular function.","category":"page"},{"location":"index.html#PowerModelsONM-Analyses-Packages","page":"Introduction","title":"PowerModelsONM Analyses Packages","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"PowerModelsONM depends on several other PowerModels(...) packages from the InfrastructureModels ecosystem. The packages in blue below are created and maintained by the core InfrastructureModels developer team, and the other packages are those that are built as extensions or rely on one of the core InfrastructureModels packages in some way.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"(Image: InfrastructureModels Ecosystem)","category":"page"},{"location":"index.html#PowerModelsDistribution","page":"Introduction","title":"PowerModelsDistribution","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"PowerModelsDistribution.jl is a Julia/JuMP-based package for modeling unbalanced (i.e., multiconductor) power networks. This is the primary modeling framework utilized in PowerModelsONM, and contains the primary logic for optimization and parsing of network data.","category":"page"},{"location":"index.html#PowerModelsProtection","page":"Introduction","title":"PowerModelsProtection","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"PowerModelsProtection.jl is a Julia/JuMP-based package for performing fault studies on both transmission (via extentions to PowerModels.jl) and distribution (via extensions to PowerModelsDistribution.jl). In the future, the goal is to include optimal protection coordination formulations and constraints for optimal switching problems.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"PowerModelsONM utilizes PowerModelsProtection to perform fault analysis after optimizing the switch configurations and dispatch by using an unbalanced IVR formuation.","category":"page"},{"location":"index.html#PowerModelsStability","page":"Introduction","title":"PowerModelsStability","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"PowerModelsStability.jl is a Julia/JuMP-based package for performing small signal stability analysis on distribution data sets (via extensions to PowerModelsDistribution.jl). Currently the capabilities of this tool are somewhat limited, as they are under active research and development; this capability is completely novel in this context. PowerModelsONM uses PowerModelsStability to report whether the resulting network configurations are small signal stable at each timestep.","category":"page"},{"location":"index.html#License","page":"Introduction","title":"License","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"This code is provided under a BSD license as part of the Multi-Infrastructure Control and Optimization Toolkit (MICOT) project, LA-CC-13-108.","category":"page"},{"location":"reference/entrypoint.html#EntrypointAPI","page":"Main Entrypoint","title":"Main Entrypoint","text":"","category":"section"},{"location":"reference/entrypoint.html#Entrypoint-Functions","page":"Main Entrypoint","title":"Entrypoint Functions","text":"","category":"section"},{"location":"reference/entrypoint.html","page":"Main Entrypoint","title":"Main Entrypoint","text":"entrypoint","category":"page"},{"location":"reference/entrypoint.html#PowerModelsONM.entrypoint","page":"Main Entrypoint","title":"PowerModelsONM.entrypoint","text":"entrypoint(args::Dict{String,<:Any})::Dict{String,Any}\n\nThe main ONM Algorithm, performs the following steps:\n\ninitialize_output!\nsanitize_args!\nsetup_logging!\nprepare_data!\nbuild_solver_instances!\noptimize_switches!\noptimize_dispatch!\nrun_stability_analysis!\nrun_fault_studies!\nanalyze_results!\n\nIf args[\"debug\"] a file containing all data, results, etc. will be written to \"debugonmyyyy-mm-ddHH-MM-SS.json\"\n\nReturns the full data structure contains all inputs and outputs.\n\n\n\n\n\n","category":"function"},{"location":"reference/entrypoint.html","page":"Main Entrypoint","title":"Main Entrypoint","text":"initialize_output!\nsetup_logging!\nprepare_data!\nbuild_solver_instances!\noptimize_switches!\noptimize_dispatch!\nrun_stability_analysis!\nrun_fault_studies!\nanalyze_results!","category":"page"},{"location":"reference/entrypoint.html#PowerModelsONM.initialize_output!","page":"Main Entrypoint","title":"PowerModelsONM.initialize_output!","text":"initialize_output!(args::Dict{String,<:Any})::Dict{String,Any}\n\nInitializes the output data strucutre inside of the args dict at \"output_data\"\n\n\n\n\n\n","category":"function"},{"location":"reference/entrypoint.html#PowerModelsONM.setup_logging!","page":"Main Entrypoint","title":"PowerModelsONM.setup_logging!","text":"setup_logging!(args::Dict{String,<:Any})\n\nConfigures logging based on runtime arguments\n\n\n\n\n\n","category":"function"},{"location":"reference/entrypoint.html#PowerModelsONM.prepare_data!","page":"Main Entrypoint","title":"PowerModelsONM.prepare_data!","text":"prepare_data!(args::Dict{String,<:Any})::Dict{String,Any}\n\nPerforms the data preparation actions\n\nparse_network\nparse_events!\nparse_settings!\n\n\n\n\n\n","category":"function"},{"location":"reference/entrypoint.html#PowerModelsONM.build_solver_instances!","page":"Main Entrypoint","title":"PowerModelsONM.build_solver_instances!","text":"build_solver_instances!(args::Dict{String,<:Any})::Dict{String,Any}\n\nCreates the Optimizers in-place (within the args dict data structure), for use inside entrypoint, using build_solver_instances, assigning them to args[\"solvers\"]`\n\n\n\n\n\n","category":"function"},{"location":"reference/entrypoint.html#PowerModelsONM.optimize_switches!","page":"Main Entrypoint","title":"PowerModelsONM.optimize_switches!","text":"optimize_switches!(args::Dict{String,<:Any})::Dict{String,Any}\n\nOptimizes switch states (therefore shedding load or not) in-place, for use in entrypoint, using [optimize_switches]\n\nUses LPUBFDiagPowerModel (LinDist3Flow), and therefore requires args[\"solvers\"][\"misocp_solver\"] to be specified\n\n\n\n\n\n","category":"function"},{"location":"reference/entrypoint.html#PowerModelsONM.optimize_dispatch!","page":"Main Entrypoint","title":"PowerModelsONM.optimize_dispatch!","text":"optimize_dispatch!(\n    args::Dict{String,<:Any};\n    solver::Union{Missing,String}=missing\n)::Dict{String,Any}\n\nSolves optimal dispatch problem in-place, for use in entrypoint, using optimize_dispatch. If you are using this to optimize after running optimize_switches!, this assumes that the correct switch states from those results have already been propagated into args[\"network\"]\n\nsolver (default: \"nlp_solver\") specifies which solver to use for the OPF problem from args[\"solvers\"]\n\n\n\n\n\n","category":"function"},{"location":"reference/entrypoint.html#PowerModelsONM.run_stability_analysis!","page":"Main Entrypoint","title":"PowerModelsONM.run_stability_analysis!","text":"run_stability_analysis!(\n    args::Dict{String,<:Any};\n    validate::Bool=true,\n    formulation::Type=PMD.ACRUPowerModel,\n    solver::String=\"nlp_solver\"\n)::Dict{String,Bool}\n\nRuns small signal stability analysis using PowerModelsStability and determines if each timestep configuration is stable, in-place, storing the results in args[\"stability_results\"], for use in entrypoint, Uses run_stability_analysis\n\nIf validate, raw inverters data will be validated against JSON schema\n\nThe formulation can be specified with formulation, but note that it must result in \"vm\" and \"va\" variables in the solution, or else PowerModelsDistribution.sol_data_model! must support converting the voltage variables into polar coordinates.\n\nsolver (default: \"nlp_solver\") specifies which solver in args[\"solvers\"] to use for the stability analysis (NLP OPF)\n\n\n\n\n\n","category":"function"},{"location":"reference/entrypoint.html#PowerModelsONM.run_fault_studies!","page":"Main Entrypoint","title":"PowerModelsONM.run_fault_studies!","text":"run_fault_studies!(\n    args::Dict{String,<:Any};\n    validate::Bool=true,\n    solver::String=\"nlp_solver\"\n)::Dict{String,Any}\n\nRuns fault studies using args[\"faults\"], if defined, and stores the results in-place in args[\"fault_stuides_results\"], for use in entrypoint, using run_fault_studies\n\n\n\n\n\n","category":"function"},{"location":"reference/entrypoint.html#PowerModelsONM.analyze_results!","page":"Main Entrypoint","title":"PowerModelsONM.analyze_results!","text":"analyze_results!(args::Dict{String,<:Any})::Dict{String,Any}\n\nAdds information and statistics to \"output_data\", including\n\n\"Runtime arguments\": Copied from args[\"raw_args\"]\n\"Simulation time steps\": Copied from values(args[\"network\"][\"mn_lookup\"]), sorted by multinetwork id\n\"Events\": Copied from args[\"raw_events\"]\n\"Voltages\": get_timestep_voltage_statistics!\n\"Load served\": get_timestep_load_served!\n\"Generator profiles\": get_timestep_generator_profiles!\n\"Storage SOC (%)\": get_timestep_storage_soc!\n\"Powerflow output\": get_timestep_dispatch!\n\"Device action timeline\": get_timestep_device_actions!\n\"Switch changes\": get_timestep_switch_changes!\n\"Small signal stability\": get_timestep_stability!\n\"Fault currents\": get_timestep_fault_currents!\n\"Optimal dispatch metadata\": get_timestep_dispatch_optimization_metadata!\n\"Optimal switching metadata\": get_timestep_switch_optimization_metadata!\n\n\n\n\n\n","category":"function"},{"location":"reference/entrypoint.html#Command-line-arguments","page":"Main Entrypoint","title":"Command-line arguments","text":"","category":"section"},{"location":"reference/entrypoint.html","page":"Main Entrypoint","title":"Main Entrypoint","text":"parse_commandline\nsanitize_args!","category":"page"},{"location":"reference/entrypoint.html#PowerModelsONM.parse_commandline","page":"Main Entrypoint","title":"PowerModelsONM.parse_commandline","text":"parse_commandline(; validate::Bool=true)::Dict{String,Any}\n\nCommand line argument parsing\n\n\n\n\n\n","category":"function"},{"location":"reference/entrypoint.html#PowerModelsONM.sanitize_args!","page":"Main Entrypoint","title":"PowerModelsONM.sanitize_args!","text":"sanitize_args!(args::Dict{String,<:Any})::Dict{String,Any}\n\nSanitizes deprecated arguments into the correct new ones, and gives warnings\n\n\n\n\n\n","category":"function"},{"location":"reference/entrypoint.html#Binary-Operations","page":"Main Entrypoint","title":"Binary Operations","text":"","category":"section"},{"location":"reference/entrypoint.html","page":"Main Entrypoint","title":"Main Entrypoint","text":"julia_main","category":"page"},{"location":"reference/entrypoint.html#PowerModelsONM.julia_main","page":"Main Entrypoint","title":"PowerModelsONM.julia_main","text":"julia_main()\n\nPackageCompiler entrypoint\n\n\n\n\n\n","category":"function"},{"location":"tutorials/JuMP Model by Hand - MLD-scenario.html#JuMP-Model-by-Hand-MLD-scenario","page":"JuMP Model by Hand - MLD-Block Scenario Example","title":"JuMP Model by Hand - MLD-scenario","text":"","category":"section"},{"location":"tutorials/JuMP Model by Hand - MLD-scenario.html","page":"JuMP Model by Hand - MLD-Block Scenario Example","title":"JuMP Model by Hand - MLD-Block Scenario Example","text":"This is a stub for an interactive Pluto.jl tutorial contained in examples.","category":"page"},{"location":"tutorials/JuMP Model by Hand - MLD-scenario.html","page":"JuMP Model by Hand - MLD-Block Scenario Example","title":"JuMP Model by Hand - MLD-Block Scenario Example","text":"During documentation build time, this tutorial will be automatically converted to HTML, but will lose its interactivity.","category":"page"},{"location":"tutorials/JuMP Model by Hand - MLD-scenario.html","page":"JuMP Model by Hand - MLD-Block Scenario Example","title":"JuMP Model by Hand - MLD-Block Scenario Example","text":"To experience the full interactivity of this notebook please install Pluto.jl, and open this file","category":"page"},{"location":"tutorials/JuMP Model by Hand - MLD-scenario.html#Installing-and-running-Pluto.jl","page":"JuMP Model by Hand - MLD-Block Scenario Example","title":"Installing and running Pluto.jl","text":"","category":"section"},{"location":"tutorials/JuMP Model by Hand - MLD-scenario.html","page":"JuMP Model by Hand - MLD-Block Scenario Example","title":"JuMP Model by Hand - MLD-Block Scenario Example","text":"Run Julia and add the package:","category":"page"},{"location":"tutorials/JuMP Model by Hand - MLD-scenario.html","page":"JuMP Model by Hand - MLD-Block Scenario Example","title":"JuMP Model by Hand - MLD-Block Scenario Example","text":"]add Pluto","category":"page"},{"location":"tutorials/JuMP Model by Hand - MLD-scenario.html","page":"JuMP Model by Hand - MLD-Block Scenario Example","title":"JuMP Model by Hand - MLD-Block Scenario Example","text":"Using the package manager for the first time after installing Julia can take up to 15 minutes - hang in there!","category":"page"},{"location":"tutorials/JuMP Model by Hand - MLD-scenario.html","page":"JuMP Model by Hand - MLD-Block Scenario Example","title":"JuMP Model by Hand - MLD-Block Scenario Example","text":"To run the notebook server:","category":"page"},{"location":"tutorials/JuMP Model by Hand - MLD-scenario.html","page":"JuMP Model by Hand - MLD-Block Scenario Example","title":"JuMP Model by Hand - MLD-Block Scenario Example","text":"import Pluto\nPluto.run()","category":"page"},{"location":"tutorials/JuMP Model by Hand - MLD-scenario.html","page":"JuMP Model by Hand - MLD-Block Scenario Example","title":"JuMP Model by Hand - MLD-Block Scenario Example","text":"Pluto will open in your browser, and you can get started!","category":"page"}]
}
