<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Variables and Constraints · PowerModelsONM</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">PowerModelsONM</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Introduction</a></li><li><a class="tocitem" href="../installation.html">Installation Guide</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../manual/quickguide.html">Getting Started</a></li><li><a class="tocitem" href="../manual/onm_workflow.html">The ONM Workflow</a></li><li><a class="tocitem" href="../manual/mld_model.html">Optimal Switch / Load shed Mathematical Model</a></li><li><a class="tocitem" href="../manual/opf_model.html">Optimal Dispatch Mathematical Model</a></li><li><a class="tocitem" href="../manual/graphml_export.html">Exporting with GraphML</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/Beginners Guide.html">Beginners Guide</a></li><li><a class="tocitem" href="../tutorials/Block MLD Basic Example.html">Block MLD Basic Example</a></li><li><a class="tocitem" href="../tutorials/JuMP Model by Hand - MLD-Block.html">JuMP Model by Hand - MLD-Block Example</a></li><li><a class="tocitem" href="../tutorials/Use Case Examples.html">Use Case Examples</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="base.html">Base functions</a></li><li><a class="tocitem" href="data.html">Data Handling</a></li><li><a class="tocitem" href="graphml.html">GraphML Functions</a></li><li><a class="tocitem" href="entrypoint.html">Main Entrypoint</a></li><li><a class="tocitem" href="internal.html">Internal Functions</a></li><li><a class="tocitem" href="io.html">IO Functions</a></li><li><a class="tocitem" href="logging.html">Logging</a></li><li><a class="tocitem" href="prob.html">Optimization Problems</a></li><li><a class="tocitem" href="stats.html">Solution Statistics</a></li><li class="is-active"><a class="tocitem" href="variable_constraint.html">Variables and Constraints</a><ul class="internal"><li><a class="tocitem" href="#Variables"><span>Variables</span></a></li><li><a class="tocitem" href="#Constraints"><span>Constraints</span></a></li><li><a class="tocitem" href="#Objectives"><span>Objectives</span></a></li><li><a class="tocitem" href="#Ref-extensions"><span>Ref extensions</span></a></li></ul></li><li><a class="tocitem" href="types.html">Types</a></li></ul></li><li><span class="tocitem">Schemas</span><ul><li><a class="tocitem" href="../schemas/output.schema.html">output.schema</a></li><li><a class="tocitem" href="../schemas/input-settings.schema.html">settings.schema</a></li><li><a class="tocitem" href="../schemas/input-events.schema.html">events.schema</a></li><li><a class="tocitem" href="../schemas/input-faults.schema.html">faults.schema</a></li><li><a class="tocitem" href="../schemas/input-runtime_arguments.schema.html">runtime-arguments.schema</a></li></ul></li><li><span class="tocitem">Developer Docs</span><ul><li><a class="tocitem" href="../developer/contributing.html">Contributing Guide</a></li><li><a class="tocitem" href="../developer/style.html">Style Guide</a></li><li><a class="tocitem" href="../developer/roadmap.html">Roadmap</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href="variable_constraint.html">Variables and Constraints</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="variable_constraint.html">Variables and Constraints</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/main/docs/src/reference/variable_constraint.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="VarConAPI"><a class="docs-heading-anchor" href="#VarConAPI">Variables and Constraints</a><a id="VarConAPI-1"></a><a class="docs-heading-anchor-permalink" href="#VarConAPI" title="Permalink"></a></h1><h2 id="Variables"><a class="docs-heading-anchor" href="#Variables">Variables</a><a id="Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Variables" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.variable_block_indicator-Tuple{AbstractUnbalancedPowerModel}" href="#PowerModelsONM.variable_block_indicator-Tuple{AbstractUnbalancedPowerModel}"><code>PowerModelsONM.variable_block_indicator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">variable_block_indicator(
    pm::AbstractUnbalancedPowerModel;
    nw::Int=nw_id_default,
    relax::Bool=false,
    report::Bool=true
)</code></pre><p>Create variables for block status by load block, <span>$z^{bl}_i\in{0,1}~\forall i \in B$</span>, binary if <code>relax=false</code>. Variables will appear in solution if <code>report=true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/variable.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.variable_bus_voltage_indicator-Tuple{AbstractUnbalancedPowerModel}" href="#PowerModelsONM.variable_bus_voltage_indicator-Tuple{AbstractUnbalancedPowerModel}"><code>PowerModelsONM.variable_bus_voltage_indicator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">variable_bus_voltage_indicator(
    pm::AbstractUnbalancedPowerModel;
    nw::Int=nw_id_default,
    relax::Bool=false,
    report::Bool=true
)</code></pre><p>Variables for switching buses on/off <span>$z^{bus}_i,~\forall i \in N$</span>, binary if <code>relax=false</code>. Variables will appear in solution if <code>report=true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/variable.jl#L108-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.variable_generator_indicator-Tuple{AbstractUnbalancedPowerModel}" href="#PowerModelsONM.variable_generator_indicator-Tuple{AbstractUnbalancedPowerModel}"><code>PowerModelsONM.variable_generator_indicator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">variable_generator_indicator(pm::AbstractUnbalancedPowerModel; nw::Int=nw_id_default, relax::Bool=false, report::Bool=true)</code></pre><p>Variables for switching generators on/off <span>$z^{gen}_i,~\forall i \in G$</span>, binary if <code>relax=false</code>. Variables will appear in solution if <code>report=true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/variable.jl#L134-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.variable_inverter_indicator-Tuple{AbstractUnbalancedPowerModel}" href="#PowerModelsONM.variable_inverter_indicator-Tuple{AbstractUnbalancedPowerModel}"><code>PowerModelsONM.variable_inverter_indicator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">variable_inverter_indicator(pm::AbstractUnbalancedPowerModel; nw::Int=nw_id_default, relax::Bool=false, report::Bool=true)</code></pre><p>Variables for indicating whether a DER (storage or gen) is in grid-forming mode (1) or grid-following mode (0), binary is <code>relax=false</code>. Variables will appear in solution if <code>report=true</code>. If &quot;inverter&quot;==GRID_FOLLOWING on the device, the inverter variable will be a constant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/variable.jl#L197-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.variable_load_indicator-Tuple{AbstractUnbalancedPowerModel}" href="#PowerModelsONM.variable_load_indicator-Tuple{AbstractUnbalancedPowerModel}"><code>PowerModelsONM.variable_load_indicator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">variable_load_indicator(pm::AbstractUnbalancedPowerModel; nw::Int=nw_id_default, relax::Bool=false, report::Bool=true)</code></pre><p>Variables for switching loads on/off <span>$z^{d}_i,~\forall i \in L$</span>, binary if <code>relax=false</code>. Variables will appear in solution if <code>report=true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/variable.jl#L176-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.variable_mc_load_power-Tuple{PowerModelsDistribution.AbstractUBFModels, Int64}" href="#PowerModelsONM.variable_mc_load_power-Tuple{PowerModelsDistribution.AbstractUBFModels, Int64}"><code>PowerModelsONM.variable_mc_load_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">variable_mc_load_power(pm::PMD.AbstractUBFModels, scen::Int; nw=nw_id_default, report::Bool=false)</code></pre><p>Load variables creation for robust mld problem. The bounds are different for each scenario.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/variable.jl#L230-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.variable_mc_storage_power_mi_on_off-Tuple{AbstractUnbalancedPowerModel}" href="#PowerModelsONM.variable_mc_storage_power_mi_on_off-Tuple{AbstractUnbalancedPowerModel}"><code>PowerModelsONM.variable_mc_storage_power_mi_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">variable_mc_storage_power_mi_on_off(
    pm::AbstractUnbalancedPowerModel;
    nw::Int=nw_id_default,
    relax::Bool=false,
    bounded::Bool=true,
    report::Bool=true
)</code></pre><p>Variables for storage, <em>omitting</em> the storage indicator <span>$z^{strg}_i$</span> variable:</p><p class="math-container">\[\begin{align}
p^{strg}_i,~\forall i \in S \\
q^{strg}_i,~\forall i \in S \\
q^{sc}_{i},~\forall i \in S \\
\epsilon_i,~\forall i \in S \\
c^{strg}_i,~\forall i \in S \\
c^{on}_i \in {0,1},~\forall i \in S \\
d^{on}_i \in {0,1},~\forall i \in S \\
\end{align}\]</p><p class="math-container">\[c^{on}_i\]</p><p>, <span>$d^{on}_i$</span> will be binary if <code>relax=false</code>. Variables will appear in solution if <code>report=true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/variable.jl#L71-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.variable_robust_inverter_indicator-Tuple{AbstractUnbalancedPowerModel}" href="#PowerModelsONM.variable_robust_inverter_indicator-Tuple{AbstractUnbalancedPowerModel}"><code>PowerModelsONM.variable_robust_inverter_indicator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">variable_robust_inverter_indicator(pm::AbstractUnbalancedPowerModel; nw::Int=nw_id_default, report::Bool=true)</code></pre><p>Robust mld (outer) problem solution for indicating whether a DER (storage or gen) is in grid-forming mode (1) or grid-following mode (0).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/variable.jl#L306-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.variable_robust_switch_state-Tuple{AbstractUnbalancedPowerModel}" href="#PowerModelsONM.variable_robust_switch_state-Tuple{AbstractUnbalancedPowerModel}"><code>PowerModelsONM.variable_robust_switch_state</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">variable_robust_switch_state(pm::AbstractUnbalancedPowerModel; nw::Int=nw_id_default, report::Bool=true)</code></pre><p>Robust mld (outer) problem solution for switch state (open/close) variables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/variable.jl#L326-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.variable_storage_indicator-Tuple{AbstractUnbalancedPowerModel}" href="#PowerModelsONM.variable_storage_indicator-Tuple{AbstractUnbalancedPowerModel}"><code>PowerModelsONM.variable_storage_indicator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">variable_storage_indicator(pm::AbstractUnbalancedPowerModel; nw::Int=nw_id_default, relax::Bool=false, report::Bool=true)</code></pre><p>Variables for switching storage on/off <span>$z^{strg}_i,~\forall i \in E$</span>, binary if <code>relax=false</code>. Variables will appear in solution if <code>report=true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/variable.jl#L155-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.variable_switch_state-Tuple{AbstractUnbalancedPowerModel}" href="#PowerModelsONM.variable_switch_state-Tuple{AbstractUnbalancedPowerModel}"><code>PowerModelsONM.variable_switch_state</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">variable_switch_state(
    pm::AbstractUnbalancedPowerModel;
    nw::Int=nw_id_default,
    report::Bool=true,
    relax::Bool=false
)</code></pre><p>Create variables for switch state (open/close) variables, <span>$\gamma_i\in{0,1}~\forall i \in S$</span>, binary if <code>relax=false</code>. Variables for non-dispatchable switches will be constants, rather than <code>VariableRef</code>. Variables will appear in solution if <code>report=true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/variable.jl#L29-L40">source</a></section></article><h2 id="Constraints"><a class="docs-heading-anchor" href="#Constraints">Constraints</a><a id="Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Constraints" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_disable_networking-Tuple{AbstractUnbalancedPowerModel}" href="#PowerModelsONM.constraint_disable_networking-Tuple{AbstractUnbalancedPowerModel}"><code>PowerModelsONM.constraint_disable_networking</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_disable_networking(pm::AbstractUnbalancedPowerModel; nw::Int=nw_id_default, relax::Bool=false)</code></pre><p>Template function for constraint to disable microgrid networking.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint_template.jl#L402-L406">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_grid_forming_inverter_per_cc_block-Tuple{AbstractUnbalancedPowerModel}" href="#PowerModelsONM.constraint_grid_forming_inverter_per_cc_block-Tuple{AbstractUnbalancedPowerModel}"><code>PowerModelsONM.constraint_grid_forming_inverter_per_cc_block</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_grid_forming_inverter_per_cc_block(pm::AbstractUnbalancedPowerModel; nw::Int=nw_id_default, relax::Bool=false)</code></pre><p>Template function for constraining the number of grid-forming inverters per connected component in the block mld problem</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint_template.jl#L381-L385">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_grid_forming_inverter_per_cc_traditional-Tuple{AbstractUnbalancedPowerModel}" href="#PowerModelsONM.constraint_grid_forming_inverter_per_cc_traditional-Tuple{AbstractUnbalancedPowerModel}"><code>PowerModelsONM.constraint_grid_forming_inverter_per_cc_traditional</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_grid_forming_inverter_per_cc_traditional(pm::AbstractUnbalancedPowerModel; nw::Int=nw_id_default, relax::Bool=false)</code></pre><p>Template function for constraining the number of grid-forming inverters per connected component in the block mld problem</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint_template.jl#L371-L375">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_isolate_block-Tuple{AbstractUnbalancedPowerModel}" href="#PowerModelsONM.constraint_isolate_block-Tuple{AbstractUnbalancedPowerModel}"><code>PowerModelsONM.constraint_isolate_block</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_isolate_block(pm::AbstractUnbalancedPowerModel; nw::Int=nw_id_default)</code></pre><p>Template function of constraint to ensure that blocks are properly isolated by open switches in block mld problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint_template.jl#L263-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_isolate_block_traditional-Tuple{AbstractUnbalancedPowerModel}" href="#PowerModelsONM.constraint_isolate_block_traditional-Tuple{AbstractUnbalancedPowerModel}"><code>PowerModelsONM.constraint_isolate_block_traditional</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_isolate_block_traditional(pm::AbstractUnbalancedPowerModel; nw::Int=nw_id_default)</code></pre><p>Template function for constraint to ensure that blocks are properly isolated by open switches in a traditional mld problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint_template.jl#L273-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_bus_voltage_block_on_off-Tuple{AbstractUnbalancedPowerModel}" href="#PowerModelsONM.constraint_mc_bus_voltage_block_on_off-Tuple{AbstractUnbalancedPowerModel}"><code>PowerModelsONM.constraint_mc_bus_voltage_block_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_bus_voltage_block_on_off(pm::AbstractUnbalancedPowerModel; nw::Int=nw_id_default)</code></pre><p>Template function for bus voltage block on/off constraint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint_template.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_bus_voltage_traditional_on_off-Tuple{AbstractUnbalancedPowerModel}" href="#PowerModelsONM.constraint_mc_bus_voltage_traditional_on_off-Tuple{AbstractUnbalancedPowerModel}"><code>PowerModelsONM.constraint_mc_bus_voltage_traditional_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_bus_voltage_traditional_on_off(pm::AbstractUnbalancedPowerModel; nw::Int=nw_id_default)</code></pre><p>Template function for bus voltage traditional on/off constraint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint_template.jl#L13-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_generator_power_block_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsONM.constraint_mc_generator_power_block_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsONM.constraint_mc_generator_power_block_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_generator_power_block_on_off(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)</code></pre><p>Template function for generator power block on/off constraint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint_template.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_generator_power_traditional_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsONM.constraint_mc_generator_power_traditional_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsONM.constraint_mc_generator_power_traditional_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_generator_power_traditional_on_off(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)</code></pre><p>Template function for generator power traditional on/off constraint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint_template.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_inverter_theta_ref-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsONM.constraint_mc_inverter_theta_ref-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsONM.constraint_mc_inverter_theta_ref</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_inverter_theta_ref(pm::AbstractUnbalancedPowerModel; nw::Int=nw_id_default)</code></pre><p>Template function for setting the reference bus theta constraint to only the bus with a grid-forming inverter</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint_template.jl#L391-L395">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_power_balance_shed_block-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsONM.constraint_mc_power_balance_shed_block-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsONM.constraint_mc_power_balance_shed_block</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_power_balance_shed_block(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)</code></pre><p>Template function for power balance constraints for block load shed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint_template.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_power_balance_shed_traditional-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsONM.constraint_mc_power_balance_shed_traditional-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsONM.constraint_mc_power_balance_shed_traditional</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_power_balance_shed_traditional(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)</code></pre><p>Template function for power balance constraints for traditional load shed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint_template.jl#L88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_storage_block_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsONM.constraint_mc_storage_block_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsONM.constraint_mc_storage_block_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_storage_block_on_off(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)</code></pre><p>Template function for storage block on/off constraint</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint_template.jl#L143-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_storage_losses_block_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsONM.constraint_mc_storage_losses_block_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsONM.constraint_mc_storage_losses_block_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_storage_losses_block_on_off(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)</code></pre><p>Template function for storage losses block on/off constraint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint_template.jl#L200-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_storage_losses_traditional_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsONM.constraint_mc_storage_losses_traditional_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsONM.constraint_mc_storage_losses_traditional_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_storage_losses_traditional_on_off(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)</code></pre><p>Template function for storage losses traditional on/off constraint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint_template.jl#L211-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_storage_phase_unbalance-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsONM.constraint_mc_storage_phase_unbalance-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsONM.constraint_mc_storage_phase_unbalance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_storage_phase_unbalance(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)</code></pre><p>Constraint template for constraint to enforce balance between phases of ps/qs on storage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint_template.jl#L222-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_storage_phase_unbalance_grid_following-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsONM.constraint_mc_storage_phase_unbalance_grid_following-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsONM.constraint_mc_storage_phase_unbalance_grid_following</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_storage_phase_unbalance_grid_following(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)</code></pre><p>Constraint template for constraint to enforce balance between phases of ps/qs on storage for grid-following inverters only. Requires <code>z_inverter</code> variables to indicate if a DER is grid-forming or grid-following</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint_template.jl#L237-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_storage_traditional_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsONM.constraint_mc_storage_traditional_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsONM.constraint_mc_storage_traditional_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_storage_traditional_on_off(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)</code></pre><p>Template function for storage traditional on/off constraint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint_template.jl#L171-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_switch_state_open_close-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsONM.constraint_mc_switch_state_open_close-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsONM.constraint_mc_switch_state_open_close</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_switch_state_open_close(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)</code></pre><p>Voltage and power constraints for open/close switches</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint_template.jl#L294-L298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_transformer_power_block_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsONM.constraint_mc_transformer_power_block_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsONM.constraint_mc_transformer_power_block_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_transformer_power_block_on_off(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default, fix_taps::Bool=true)</code></pre><p>Template function for transformer power constraints for block mld problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint_template.jl#L313-L317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_transformer_power_traditional_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsONM.constraint_mc_transformer_power_traditional_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsONM.constraint_mc_transformer_power_traditional_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_transformer_power_traditional_on_off(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default, fix_taps::Bool=true)</code></pre><p>Template function for transformer power constraints for traditional mld problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint_template.jl#L342-L346">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_radial_topology-Tuple{AbstractUnbalancedPowerModel}" href="#PowerModelsONM.constraint_radial_topology-Tuple{AbstractUnbalancedPowerModel}"><code>PowerModelsONM.constraint_radial_topology</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_radial_topology(pm::AbstractUnbalancedPowerModel; nw::Int=nw_id_default, relax::Bool=false)</code></pre><p>Template function radial topology constraint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint_template.jl#L284-L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_storage_complementarity_mi_block_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsONM.constraint_storage_complementarity_mi_block_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsONM.constraint_storage_complementarity_mi_block_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_storage_complementarity_mi_block_on_off(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)</code></pre><p>Template function for mixed-integer storage complementarity constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint_template.jl#L115-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_storage_complementarity_mi_traditional_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsONM.constraint_storage_complementarity_mi_traditional_on_off-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsONM.constraint_storage_complementarity_mi_traditional_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_storage_complementarity_mi_traditional_on_off(pm::AbstractUnbalancedPowerModel, i::Int; nw::Int=nw_id_default)</code></pre><p>Template function for mixed-integer storage complementarity constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint_template.jl#L129-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_switch_close_action_limit-Tuple{AbstractUnbalancedPowerModel}" href="#PowerModelsONM.constraint_switch_close_action_limit-Tuple{AbstractUnbalancedPowerModel}"><code>PowerModelsONM.constraint_switch_close_action_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_switch_close_action_limit(pm::AbstractUnbalancedPowerModel; nw::Int=nw_id_default)</code></pre><p>Template function for constraint of maximum switch closes per timestep (allows unlimited switch opens).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint_template.jl#L253-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_disable_networking-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsONM.constraint_disable_networking-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsONM.constraint_disable_networking</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_disable_networking(pm::AbstractUnbalancedPowerModel, nw::Int; relax::Bool=false)</code></pre><p>Constrains each microgrid to not network with another microgrid, while still allowing them to expand.</p><p class="math-container">\[\begin{align}
\sum_{k \in |{\cal L}|} y^k_{ab} = 1, \forall ab \in {\cal S}\\
y^k_{ab} - (1 - z_{ab}) \le x_k^{mg} \le  y^k_{ab} + (1 - z_{ab}), \forall k \in {\cal L}\\
y^{k&#39;}_{dc} - (1 - z_{dc}) - (1 - z_{ab}) \le y^{k&#39;}_{ab} \le  y^{k&#39;}_{dc} + (1 - z_{dc}) + (1 - z_{ab}), \forall k \in {\cal L}, \forall ab \in {\cal T}_k, \forall dc \in {\cal T}_k\setminus {ab}
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint.jl#L1087-L1099">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_energized_blocks_strictly_increasing-Tuple{AbstractUnbalancedPowerModel, Int64, Int64}" href="#PowerModelsONM.constraint_energized_blocks_strictly_increasing-Tuple{AbstractUnbalancedPowerModel, Int64, Int64}"><code>PowerModelsONM.constraint_energized_blocks_strictly_increasing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_energized_blocks_strictly_increasing(pm::AbstractUnbalancedPowerModel, n_1::Int, n_2::Int)</code></pre><p>Constraint to ensure that the number of energized load blocks from one timestep to another is strictly increasing and that once energized, a load block cannot be shed in a later timestep.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint.jl#L1153-L1158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_grid_forming_inverter_per_cc_block-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsONM.constraint_grid_forming_inverter_per_cc_block-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsONM.constraint_grid_forming_inverter_per_cc_block</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_grid_forming_inverter_per_cc(pm::AbstractUnbalancedPowerModel, nw::Int; relax::Bool=false)</code></pre><p>Constrains each connected component of the load block graph to have only one grid-forming inverter, if the block is enabled</p><p class="math-container">\[\begin{align}
&amp; \sum_{k \in {\cal B}} y^k_{ab} \le z^{sw}_{ab} &amp;\forall ab \in {\cal E}_{sw} \\
&amp; \sum_{ab \in {\cal T}_k} (1-z^{sw}_{ab}) - |{\cal T}_k| + z^{bl}_k \le \sum_{i \in {\cal D}_k} z^{inv}_i \le z^{bl}_k &amp; \forall k \in {\cal B} \\
&amp; S^g_i \le \overline{S}^g_i (\sum_{ab \in {\cal T}_k} z^{sw}_{ab} + \sum_{j \in {\cal D}_k} z^{inv}_j) &amp; \forall i \in {\cal G} \\
&amp; S^g_i \le \overline{S}^g_i (\sum_{ab \in {\cal T}_k} \sum_{k \in {\cal B}} y_{ab}^k + \sum_{j \in {\cal D}_k} z^{sw}_j) &amp; \forall i \in {\cal G} \\
&amp; S^g_i \ge \underline{S}^g_i (\sum_{ab \in {\cal T}_k} z^{sw}_{ab} + \sum_{j \in {\cal D}_k} z^{inv}_j) &amp; \forall i \in {\cal G} \\
&amp; S^g_i \ge \underline{S}^g_i (\sum_{ab \in {\cal T}_k} \sum_{k \in {\cal B}} y_{ab}^k + \sum_{j \in {\cal D}_k} z^{sw}_j) &amp; \forall i \in {\cal G} \\
&amp; y^k_{ab} - (1 - z^{sw}_{ab}) \le \sum_{i \in {\cal D}_k} z^{inv}_i \le  y^k_{ab} + (1 - z^{sw}_{ab}) &amp; \forall k \in {\cal B},\forall ab \in {\cal E}_{sw} \\
&amp; y^{k&#39;}_{dc} - (1 - z^{sw}_{dc}) - (1 - z^{sw}_{ab}) \le y^{k&#39;}_{ab} \le  y^{k&#39;}_{dc} + (1 - z^{sw}_{dc}) + (1 - z^{sw}_{ab}) \\
&amp; ~~~~ \forall k \in {\cal B},\forall k&#39; \in {\cal B}/{k},\forall ab \in {\cal E}_{sw},\forall dc \in {\cal E}_{sw}/{ab} \nonumber \\
&amp; y_{ab}^k \le \sum_{i \in {\cal D}_k} z^{inv}_i &amp; \forall k \in {\cal B},\forall ab \in {\cal E}_{sw} \\
&amp; -z^{sw}_{ab} |{\cal B}| \le f_{ab}^k \le z^{sw}_{ab} |{\cal B}| &amp; \forall k \in {\cal B},\forall ab \in {\cal E}_{sw} \\
&amp; 0 \le \xi_{ab}^k \le 1 &amp; \forall k \in {\cal B},\forall ab \in {\cal E}_{sw} \\
&amp; \sum_{ab \in {\cal T}_k : a = k} f_{ab}^k - \sum_{ab \in {\cal T}_k : b = k} f_{ab}^k + \sum_{ab \in {\cal E}_v^k} \xi_{ab}^k = |{\cal B}| - 1 &amp; \forall k \in {\cal B} \\
&amp; \sum_{ab \in {\cal T}_{k&#39;} : a = k&#39;} f_{ab}^k - \sum_{ab \in {\cal T}_{k&#39;} : b = k&#39;} f_{ab}^k  -  \xi_{kk&#39;}^k = -1, \;\;\; \forall k&#39; \ne k &amp; \forall k \in {\cal B} \\
&amp; y_{ab}^k \le 1 - \xi_{kk&#39;}^k &amp; \forall k&#39; \ne k, ab \in {\cal T}_{k&#39;} \\
&amp; z^{bl}_k \le \sum_{i \in {\cal D}_k} z^{inv}_i + \sum_{ab \in {\cal T}_k}  \sum_{k \in {\cal B}} y^k_{ab}
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint.jl#L686-L711">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_grid_forming_inverter_per_cc_traditional-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsONM.constraint_grid_forming_inverter_per_cc_traditional-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsONM.constraint_grid_forming_inverter_per_cc_traditional</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_grid_forming_inverter_per_cc_traditional(pm::AbstractUnbalancedPowerModel, nw::Int; relax::Bool=false)</code></pre><p>Constrains each connected component of the graph to have only one grid-forming inverter, if the component is enabled</p><p class="math-container">\[\begin{align}
&amp; \sum_{k \in {\cal B}} y^k_{ab} \le z^{sw}_{ab} &amp;\forall ab \in {\cal E}_{sw} \\
&amp; \sum_{ab \in {\cal T}_k} (1-z^{sw}_{ab}) - |{\cal T}_k| + 1 \le \sum_{i \in {\cal D}_k} z^{inv}_i \le 1 &amp; \forall k \in {\cal B} \\
&amp; S^g_i \le \overline{S}^g_i (\sum_{ab \in {\cal T}_k} z^{sw}_{ab} + \sum_{j \in {\cal D}_k} z^{inv}_j) &amp; \forall i \in {\cal G} \\
&amp; S^g_i \le \overline{S}^g_i (\sum_{ab \in {\cal T}_k} \sum_{k \in {\cal B}} y_{ab}^k + \sum_{j \in {\cal D}_k} z^{sw}_j) &amp; \forall i \in {\cal G} \\
&amp; S^g_i \ge \underline{S}^g_i (\sum_{ab \in {\cal T}_k} z^{sw}_{ab} + \sum_{j \in {\cal D}_k} z^{inv}_j) &amp; \forall i \in {\cal G} \\
&amp; S^g_i \ge \underline{S}^g_i (\sum_{ab \in {\cal T}_k} \sum_{k \in {\cal B}} y_{ab}^k + \sum_{j \in {\cal D}_k} z^{sw}_j) &amp; \forall i \in {\cal G} \\
&amp; y^k_{ab} - (1 - z^{sw}_{ab}) \le \sum_{i \in {\cal D}_k} z^{inv}_i \le  y^k_{ab} + (1 - z^{sw}_{ab}) &amp; \forall k \in {\cal B},\forall ab \in {\cal E}_{sw} \\
&amp; y^{k&#39;}_{dc} - (1 - z^{sw}_{dc}) - (1 - z^{sw}_{ab}) \le y^{k&#39;}_{ab} \le  y^{k&#39;}_{dc} + (1 - z^{sw}_{dc}) + (1 - z^{sw}_{ab}) \\
&amp; ~~~~ \forall k \in {\cal B},\forall k&#39; \in {\cal B}/{k},\forall ab \in {\cal E}_{sw},\forall dc \in {\cal E}_{sw}/{ab} \nonumber \\
&amp; y_{ab}^k \le \sum_{i \in {\cal D}_k} z^{inv}_i &amp; \forall k \in {\cal B},\forall ab \in {\cal E}_{sw} \\
&amp; -z^{sw}_{ab} |{\cal B}| \le f_{ab}^k \le z^{sw}_{ab} |{\cal B}| &amp; \forall k \in {\cal B},\forall ab \in {\cal E}_{sw} \\
&amp; 0 \le \xi_{ab}^k \le 1 &amp; \forall k \in {\cal B},\forall ab \in {\cal E}_{sw} \\
&amp; \sum_{ab \in {\cal T}_k : a = k} f_{ab}^k - \sum_{ab \in {\cal T}_k : b = k} f_{ab}^k + \sum_{ab \in {\cal E}_v^k} \xi_{ab}^k = |{\cal B}| - 1 &amp; \forall k \in {\cal B} \\
&amp; \sum_{ab \in {\cal T}_{k&#39;} : a = k&#39;} f_{ab}^k - \sum_{ab \in {\cal T}_{k&#39;} : b = k&#39;} f_{ab}^k  -  \xi_{kk&#39;}^k = -1, \;\;\; \forall k&#39; \ne k &amp; \forall k \in {\cal B} \\
&amp; y_{ab}^k \le 1 - \xi_{kk&#39;}^k &amp; \forall k&#39; \ne k, ab \in {\cal T}_{k&#39;} \\
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint.jl#L912-L936">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_isolate_block-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsONM.constraint_isolate_block-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsONM.constraint_isolate_block</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_isolate_block(pm::AbstractUnbalancedPowerModel, nw::Int)</code></pre><p>constraint to ensure that blocks get properly isolated by open switches by comparing the states of two neighboring blocks. If the neighboring block indicators are not either both 0 or both 1, the switch between them should be OPEN (0)</p><p class="math-container">\[\begin{align*}
&amp; (z^{bl}_{fr} - z^{bl}_{to}) \leq  \gamma_{i}\ ~\forall i \in S \\
&amp; (z^{bl}_{fr} - z^{bl}_{fr}) \geq - \gamma_{i}\ ~\forall i \in S \\
&amp; z^{bl}_b \leq N_{gen} + N_{strg} + N_{neg load} + \sum_{i \in S \in b} \gamma_i, ~\forall b \in B
\end{align*}\]</p><p>where <span>$z^{bl}_{fr}$</span> and <span>$z^{bl}_{to}$</span> are the indicator variables for the blocks on either side of switch <span>$i$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint.jl#L78-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_isolate_block_traditional-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsONM.constraint_isolate_block_traditional-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsONM.constraint_isolate_block_traditional</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_isolate_block_traditional(pm::AbstractUnbalancedPowerModel, nw::Int)</code></pre><p>Constraint to simulate block isolation constraint in the traditional mld problem</p><p class="math-container">\[\begin{align}
&amp; z^{bus}_{fr} - z^{bus}_{to} \leq  (1-\gamma_i), ~\forall i \in S \\
&amp; z^{bus}_{fr} - z^{bus}_{to} \geq -(1-\gamma_i), ~\forall i \in S \\
&amp; z^{d}_i \leq z^{d}_j, ~\forall (i,j) \in D \in B \\
&amp; z^{d}_i \leq z^{bus}_j, ~\forall i \in D \in B, ~i \in j \in V \in B \\
&amp; z^{bus}_i \leq z^{bus}_j, ~\forall (i,j) \in V \in B \\
&amp; z^{bl}_b \leq N_{gen} + N_{strg} + N_{neg load} + \sum_{i \in S \in {b \in B}} \gamma_i, ~\forall b \in B
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint.jl#L126-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_generator_power_block_on_off-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{&lt;:Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsONM.constraint_mc_generator_power_block_on_off-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{&lt;:Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsONM.constraint_mc_generator_power_block_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_generator_power_block_on_off(
    pm::AbstractUnbalancedPowerModel,
    nw::Int,
    i::Int,
    connections::Vector{Int},
    pmin::Vector{&lt;:Real},
    pmax::Vector{&lt;:Real},
    qmin::Vector{&lt;:Real},
    qmax::Vector{&lt;:Real}
)</code></pre><p>Generic block mld on/off constraint for generator power</p><p class="math-container">\[\begin{align}
S_i \geq z^{bl}_b S^{lb}_i, i \in {b \in B} \\
S_i \leq z^{bl}_b S^{ub}_i, i \in {b \in B}
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint.jl#L364-L384">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_generator_power_traditional_on_off-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{&lt;:Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsONM.constraint_mc_generator_power_traditional_on_off-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{&lt;:Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsONM.constraint_mc_generator_power_traditional_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_generator_power_traditional_on_off(pm::AbstractUnbalancedPowerModel, nw::Int, i::Int, connections::Vector{Int}, pmin::Vector{&lt;:Real}, pmax::Vector{&lt;:Real}, qmin::Vector{&lt;:Real}, qmax::Vector{&lt;:Real})</code></pre><p>Generic traditional mld on/off constraint for generator power</p><p class="math-container">\[\begin{align}
S_i \geq z^{gen}_i S^{lb}_i \\
S_i \leq z^{gen}_i S^{ub}_i
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint.jl#L401-L412">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_storage_block_on_off-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{Int64}, Real, Real, Real, Real, Real, Real}" href="#PowerModelsONM.constraint_mc_storage_block_on_off-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{Int64}, Real, Real, Real, Real, Real, Real}"><code>PowerModelsONM.constraint_mc_storage_block_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_storage_block_on_off(
    pm::AbstractUnbalancedPowerModel,
    nw::Int,
    i::Int,
    connections::Vector{Int},
    pmin::Real,
    pmax::Real,
    qmin::Real,
    qmax::Real,
    charge_ub::Real,
    discharge_ub::Real
)</code></pre><p>block on/off constraint for storage</p><p class="math-container">\[\begin{align}
\sum_{\substack{c \in \Gamma}} S_{i,c} \geq z^{bl}_b S^{lb}_i, i \in {b \in B} \\
\sum_{\substack{c \in \Gamma}} S_{i,c} \leq z^{bl}_b S^{ub}_i, i \in {b \in B}
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint.jl#L429-L451">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_storage_phase_unbalance-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{Int64}, Real}" href="#PowerModelsONM.constraint_mc_storage_phase_unbalance-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{Int64}, Real}"><code>PowerModelsONM.constraint_mc_storage_phase_unbalance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_storage_phase_unbalance(
    pm::AbstractUnbalancedPowerModel,
    nw::Int,
    i::Int,
    connections::Vector{Int},
    unbalance_factor::Real
)</code></pre><p>Enforces that storage inputs/outputs are (approximately) balanced across each phase, by some <code>unbalance_factor</code></p><p class="math-container">\[S^{strg}_{i,c} \geq S^{strg}_{i,d} - f^{unbal} \left( -d^{on}_i S^{strg}_{i,d} + c^{on}_i S^{strg}_{i,d} \right) \forall c,d \in C
S^{strg}_{i,c} \leq S^{strg}_{i,d} + f^{unbal} \left( -d^{on}_i S^{strg}_{i,d} + c^{on}_i S^{strg}_{i,d} \right) \forall c,d \in C\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint.jl#L503-L518">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_storage_phase_unbalance_grid_following-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{Int64}, Real}" href="#PowerModelsONM.constraint_mc_storage_phase_unbalance_grid_following-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{Int64}, Real}"><code>PowerModelsONM.constraint_mc_storage_phase_unbalance_grid_following</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_storage_phase_unbalance_grid_following(
    pm::AbstractUnbalancedPowerModel,
    nw::Int,
    i::Int,
    connections::Vector{Int},
    unbalance_factor::Real
)</code></pre><p>Enforces that storage inputs/outputs are (approximately) balanced across each phase, by some <code>unbalance_factor</code> on grid-following inverters only. Requires z_inverter variable</p><p class="math-container">\[S^{strg}_{i,c} \geq S^{strg}_{i,d} - f^{unbal} \left( -d^{on}_i S^{strg}_{i,d} + c^{on}_i S^{strg}_{i,d} \right) \forall c,d \in C
S^{strg}_{i,c} \leq S^{strg}_{i,d} + f^{unbal} \left( -d^{on}_i S^{strg}_{i,d} + c^{on}_i S^{strg}_{i,d} \right) \forall c,d \in C\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint.jl#L617-L633">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_storage_traditional_on_off-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{Int64}, Real, Real, Real, Real, Real, Real}" href="#PowerModelsONM.constraint_mc_storage_traditional_on_off-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Vector{Int64}, Real, Real, Real, Real, Real, Real}"><code>PowerModelsONM.constraint_mc_storage_traditional_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_storage_traditional_on_off(
    pm::AbstractUnbalancedPowerModel,
    nw::Int,
    i::Int,
    connections::Vector{Int},
    pmin::Real,
    pmax::Real,
    qmin::Real,
    qmax::Real,
    charge_ub::Real,
    discharge_ub::Real
)</code></pre><p>Traditional on/off constraint for storage</p><p class="math-container">\[\begin{align}
\sum_{\substack{c \in \Gamma}} S_{i,c} \geq z^{strg}_i S^{lb}_i \\
\sum_{\substack{c \in \Gamma}} S_{i,c} \leq z^{strg}_i S^{ub}_i
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint.jl#L466-L488">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_switch_power_open_close-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}" href="#PowerModelsONM.constraint_mc_switch_power_open_close-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}"><code>PowerModelsONM.constraint_mc_switch_power_open_close</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_switch_power_open_close(
    pm::AbstractUnbalancedPowerModel,
    nw::Int,
    i::Int,
    f_bus::Int,
    t_bus::Int,
    f_connections::Vector{Int},
    t_connections::Vector{Int}
)</code></pre><p>generic switch power open/closed constraint</p><p class="math-container">\[\begin{align}
&amp; S^{sw}_{i,c} \leq S^{swu}_{i,c} z^{sw}_i\ \forall i \in S,\forall c \in C \\
&amp; S^{sw}_{i,c} \geq -S^{swu}_{i,c} z^{sw}_i\ \forall i \in S,\forall c \in C
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint.jl#L323-L342">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_radial_topology-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsONM.constraint_radial_topology-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsONM.constraint_radial_topology</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_radial_topology(pm::AbstractUnbalancedPowerModel, nw::Int; relax::Bool=false)</code></pre><p>Constraint to enforce a radial topology</p><p>See 10.1109/TSG.2020.2985087</p><p class="math-container">\[\begin{align}
\mathbf{\beta} \in \mathbf{\Omega} \\
\alpha_{ij} \leq \beta_{ij},\forall(i,j) \in L \\
\sum_{\substack{(j,i_r)\in L}}f^{k}_{ji_r} - \sum_{\substack{(i_r,j)\in L}}f^{k}_{i_rj}=-1,~\forall k \in N\setminus i_r \\
\sum_{\substack{(j,k)\in L}}f^{k}_{jk} - \sum_{\substack{(k,j)\in L}}f^k_{kj} = 1,~\forall k \in N\setminus i_r \\
\sum_{\substack{(j,i)\in L}}f^k_{ji}-\sum_{\substack{(i,j)\in L}}f^k_{ij}=0,~\forall k \in N\setminus i_r,\forall i \in N\setminus {i_r,k} \\
0 \leq f^k_{ij} \leq \lambda_{ij},0 \leq f^k_{ji} \leq \lambda_{ji},\forall k \in N\setminus i_r,\forall(i,j)\in L \\
\sum_{\substack{(i,j)\in L}}\left(\lambda_{ij} + \lambda_{ji} \right ) = \left | N \right | - 1 \\
\lambda_{ij} + \lambda_{ji} = \beta_{ij},\forall(i,j)\in L \\
\lambda_{ij},\lambda_{ji}\in\left \{ 0,1 \right \},\forall(i,j)\in L
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint.jl#L188-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_storage_complementarity_mi_block_on_off-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Real, Real}" href="#PowerModelsONM.constraint_storage_complementarity_mi_block_on_off-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Real, Real}"><code>PowerModelsONM.constraint_storage_complementarity_mi_block_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_storage_complementarity_mi_block_on_off(
    pm::AbstractUnbalancedPowerModel,
    n::Int,
    i::Int,
    charge_ub::Real,
    discharge_ub::Real
)</code></pre><p>Nonlinear storage complementarity mi constraint for block mld problem.</p><p>math``` \begin{align} c^{on}<em>i * d^{on}</em>i == z^{bl}<em>b, i \in {b \in B} \
c^{on}</em>i c^{ub}<em>i \geq c</em>i \
d^{on}<em>i d^{ub}</em>i \geq d_i \end{align} ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint.jl#L551-L569">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_storage_complementarity_mi_traditional_on_off-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Real, Real}" href="#PowerModelsONM.constraint_storage_complementarity_mi_traditional_on_off-Tuple{AbstractUnbalancedPowerModel, Int64, Int64, Real, Real}"><code>PowerModelsONM.constraint_storage_complementarity_mi_traditional_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_storage_complementarity_mi_traditional_on_off(
    pm::AbstractUnbalancedPowerModel,
    n::Int,
    i::Int,
    charge_ub::Real,
    discharge_ub::Real
)</code></pre><p>Nonlinear storage complementarity mi constraint for traditional mld problem.</p><p>math``` \begin{align} c^{on}<em>i d^{on}</em>i = z^{strg}<em>i \
c^{on}</em>i c^{ub}<em>i \geq c</em>i \
d^{on}<em>i d^{ub}</em>i \geq d_i \end{align} ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint.jl#L584-L602">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_switch_close_action_limit-Tuple{AbstractUnbalancedPowerModel, Int64, Int64}" href="#PowerModelsONM.constraint_switch_close_action_limit-Tuple{AbstractUnbalancedPowerModel, Int64, Int64}"><code>PowerModelsONM.constraint_switch_close_action_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_switch_close_action_limit(pm::AbstractUnbalancedPowerModel, nw_1::Int, nw_2::Int)</code></pre><p>Constraint for maximum allowed switch close actions between time steps, as defined by <code>ref(pm, nw, :switch_close_actions_ub)</code></p><p class="math-container">\[\begin{align}
\Delta^{\gamma}_i, ~\forall i \in S &amp; \\
\gamma^{t}_i, ~\forall i \in S, ~\forall t \in T  &amp; \\
\gamma^{t_1,t_2}_i, ~\forall i \in S, ~\forall (t_1,t_2) \in T  &amp; \\
s.t.  &amp; \\
&amp; \gamma^{t_1,t_2}_i \geq 0 \\
&amp; \gamma^{t_1,t_2}_i \geq \gamma^{t_2}_i + \gamma^{t_1}_i - 1 \\
&amp; \gamma^{t_1,t_2}_i \leq \gamma{t_1}_i \\
&amp; \gamma^{t_1,t_2}_i \leq \gamma{t_2}_i \\
&amp; \Delta^{\gamma}_i \geq \gamma^{t_2}+i - \gamma^{t_1,t_2}_i \\
&amp; \Delta^{\gamma}_i \geq \gamma^{t_2}+i + \gamma^{t_1,t_2}_i \\
&amp; \sum_{\substack{i \in S}} \Delta^{\gamma}_i \leq N_{\gamma=1}^{ub}
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint.jl#L33-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_switch_close_action_limit-Tuple{AbstractUnbalancedPowerModel, Int64}" href="#PowerModelsONM.constraint_switch_close_action_limit-Tuple{AbstractUnbalancedPowerModel, Int64}"><code>PowerModelsONM.constraint_switch_close_action_limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_switch_close_action_limit(pm::AbstractUnbalancedPowerModel, nw::Int)</code></pre><p>Constraint for maximum allowed switch close actions in a single time step, as defined by <code>ref(pm, nw, :switch_close_actions_ub)</code></p><p class="math-container">\[\begin{align}
\Delta^{\gamma}_i,~\forall i \in S &amp; \\
s.t. &amp; \\
&amp; \Delta^{\gamma}_i \geq \gamma \left( 1 - \gamma_0 \right) \\
&amp; \Delta^{\gamma}_i \geq -\gamma \left( 1 - \gamma_0 \right) \\
&amp; \sum_{\substack{i \in S}} \Delta^{\gamma}_i \leq N_{\gamma=1}^{ub}
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/constraint.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_bus_voltage_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACPModel, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsONM.constraint_mc_bus_voltage_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACPModel, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsONM.constraint_mc_bus_voltage_block_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/acp.jl#L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_bus_voltage_magnitude_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACPModel, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsONM.constraint_mc_bus_voltage_magnitude_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACPModel, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsONM.constraint_mc_bus_voltage_magnitude_block_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_bus_voltage_magnitude_block_on_off(pm::PMD.AbstractUnbalancedACPModel, nw::Int, i::Int, vmin::Vector{&lt;:Real}, vmax::Vector{&lt;:Real})</code></pre><p>on/off bus voltage magnitude block constraint for relaxed formulations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/acp.jl#L165-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_bus_voltage_magnitude_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACPModel, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsONM.constraint_mc_bus_voltage_magnitude_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACPModel, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsONM.constraint_mc_bus_voltage_magnitude_traditional_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_bus_voltage_magnitude_traditional_on_off(pm::PMD.AbstractUnbalancedACPModel, nw::Int, i::Int, vmin::Vector{&lt;:Real}, vmax::Vector{&lt;:Real})</code></pre><p>on/off bus voltage magnitude traditional constraint for relaxed formulations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/acp.jl#L184-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_bus_voltage_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACPModel, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsONM.constraint_mc_bus_voltage_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACPModel, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsONM.constraint_mc_bus_voltage_traditional_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/acp.jl#L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_power_balance_shed_block-Tuple{PowerModelsDistribution.AbstractUnbalancedACPModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsONM.constraint_mc_power_balance_shed_block-Tuple{PowerModelsDistribution.AbstractUnbalancedACPModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsONM.constraint_mc_power_balance_shed_block</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_power_balance_shed_block(pm::PMD.AbstractUnbalancedACPModel, nw::Int, i::Int,
    terminals::Vector{Int}, grounded::Vector{Bool}, bus_arcs::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}},
    bus_arcs_sw::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_trans::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}},
    bus_gens::Vector{Tuple{Int,Vector{Int}}}, bus_storage::Vector{Tuple{Int,Vector{Int}}},
    bus_loads::Vector{Tuple{Int,Vector{Int}}}, bus_shunts::Vector{Tuple{Int,Vector{Int}}}
)</code></pre><p>KCL for block load shed problem with transformers (ACPU Form)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/acp.jl#L51-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_storage_losses_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACPModel, Int64, Int64, Int64, Vector{Int64}, Real, Real, Real, Real}" href="#PowerModelsONM.constraint_mc_storage_losses_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACPModel, Int64, Int64, Int64, Vector{Int64}, Real, Real, Real, Real}"><code>PowerModelsONM.constraint_mc_storage_losses_block_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_storage_losses_block_on_off(pm::PMD.AbstractUnbalancedACPModel, nw::Int, i::Int, bus::Int, connections::Vector{Int}, r::Real, x::Real, p_loss::Real, q_loss::Real)</code></pre><p>Non-linear storage loss constraint</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/acp.jl#L292-L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_storage_losses_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACPModel, Int64, Int64, Int64, Vector{Int64}, Real, Real, Real, Real}" href="#PowerModelsONM.constraint_mc_storage_losses_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACPModel, Int64, Int64, Int64, Vector{Int64}, Real, Real, Real, Real}"><code>PowerModelsONM.constraint_mc_storage_losses_traditional_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_storage_losses_traditional_on_off(pm::PMD.AbstractUnbalancedACPModel, nw::Int, i::Int, bus::Int, connections::Vector{Int}, r::Real, x::Real, p_loss::Real, q_loss::Real)</code></pre><p>Non-linear storage loss constraint</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/acp.jl#L321-L325">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_switch_voltage_open_close-Tuple{PowerModelsDistribution.AbstractUnbalancedACPModel, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}" href="#PowerModelsONM.constraint_mc_switch_voltage_open_close-Tuple{PowerModelsDistribution.AbstractUnbalancedACPModel, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}"><code>PowerModelsONM.constraint_mc_switch_voltage_open_close</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_switch_state_voltage_open_closed(pm::PMD.AbstractUnbalancedACPModel, nw::Int, i::Int, f_bus::Int, t_bus::Int, f_connections::Vector{Int}, t_connections::Vector{Int})</code></pre><p>Linear switch power on/off constraint for ACPU form.</p><p class="math-container">\[\begin{align}
&amp; |V^{fr}_{i,c}| - |V^{to}_{i,c}| \leq \left ( v^u_{i,c} - v^l_{i,c} \right ) \left ( 1 - z^{sw}_i \right )\ \forall i \in S,\forall c \in C \\
&amp; |V^{fr}_{i,c}| - |V^{to}_{i,c}| \geq -\left ( v^u_{i,c} - v^l_{i,c} \right ) \left ( 1 - z^{sw}_i \right )\ \forall i \in S,\forall c \in C \\

\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/acp.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_transformer_power_yy_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACPModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}" href="#PowerModelsONM.constraint_mc_transformer_power_yy_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACPModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}"><code>PowerModelsONM.constraint_mc_transformer_power_yy_block_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_transformer_power_yy_on_off(
    pm::PMD.AbstractUnbalancedACPModel,
    nw::Int,
    trans_id::Int,
    f_bus::Int,
    t_bus::Int,
    f_idx::Tuple{Int,Int,Int},
    t_idx::Tuple{Int,Int,Int},
    f_connections::Vector{Int},
    t_connections::Vector{Int},
    pol::Int,
    tm_set::Vector{&lt;:Real},
    tm_fixed::Vector{Bool},
    tm_scale::Real
)</code></pre><p>Links to and from power and voltages in a wye-wye transformer, assumes tm_fixed is true</p><p class="math-container">\[w_fr_i=(pol_i*tm_scale*tm_i)^2w_to_i\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/acp.jl#L213-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_bus_voltage_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACRModel, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsONM.constraint_mc_bus_voltage_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACRModel, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsONM.constraint_mc_bus_voltage_block_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/acr.jl#L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_bus_voltage_magnitude_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACRModel, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsONM.constraint_mc_bus_voltage_magnitude_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACRModel, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsONM.constraint_mc_bus_voltage_magnitude_block_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_bus_voltage_magnitude_block_on_off(pm::PMD.AbstractUnbalancedACRModel, nw::Int, i::Int, vmin::Vector{&lt;:Real}, vmax::Vector{&lt;:Real})</code></pre><p>on/off block bus voltage magnitude squared constraint for ac-rect form</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/acr.jl#L120-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_bus_voltage_magnitude_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACRModel, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsONM.constraint_mc_bus_voltage_magnitude_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACRModel, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsONM.constraint_mc_bus_voltage_magnitude_traditional_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_bus_voltage_magnitude_traditional_on_off(pm::PMD.AbstractUnbalancedACRModel, nw::Int, i::Int, vmin::Vector{&lt;:Real}, vmax::Vector{&lt;:Real})</code></pre><p>on/off block bus voltage magnitude squared constraint for ac-rect form</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/acr.jl#L141-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_bus_voltage_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACRModel, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsONM.constraint_mc_bus_voltage_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACRModel, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsONM.constraint_mc_bus_voltage_traditional_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/acr.jl#L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_inverter_theta_ref-Tuple{PowerModelsDistribution.AbstractUnbalancedACRModel, Int64, Int64, Vector{&lt;:Real}}" href="#PowerModelsONM.constraint_mc_inverter_theta_ref-Tuple{PowerModelsDistribution.AbstractUnbalancedACRModel, Int64, Int64, Vector{&lt;:Real}}"><code>PowerModelsONM.constraint_mc_inverter_theta_ref</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_inverter_theta_ref(pm::PMD.AbstractUnbalancedACRModel, nw::Int, i::Int, va_ref::Vector{&lt;:Real})</code></pre><p>Creates phase angle constraints at reference buses for the ACR formulation</p><p>math<code>\begin{align} \Im(V) = \tan(V_a^{ref}) \Re(V) \end{align}</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/acr.jl#L307-L317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_power_balance_shed_block-Tuple{PowerModelsDistribution.AbstractUnbalancedACRModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsONM.constraint_mc_power_balance_shed_block-Tuple{PowerModelsDistribution.AbstractUnbalancedACRModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsONM.constraint_mc_power_balance_shed_block</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_power_balance_shed_block(pm::PMD.AbstractUnbalancedACRModel, nw::Int, i::Int,
    terminals::Vector{Int}, grounded::Vector{Bool}, bus_arcs::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}},
    bus_arcs_sw::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_trans::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}},
    bus_gens::Vector{Tuple{Int,Vector{Int}}}, bus_storage::Vector{Tuple{Int,Vector{Int}}},
    bus_loads::Vector{Tuple{Int,Vector{Int}}}, bus_shunts::Vector{Tuple{Int,Vector{Int}}}
)</code></pre><p>KCL for block load shed problem with transformers (ac-rect form)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/acr.jl#L44-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_storage_losses_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACRModel, Int64, Int64, Int64, Vector{Int64}, Real, Real, Real, Real}" href="#PowerModelsONM.constraint_mc_storage_losses_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACRModel, Int64, Int64, Int64, Vector{Int64}, Real, Real, Real, Real}"><code>PowerModelsONM.constraint_mc_storage_losses_block_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_storage_losses_block_on_off(pm::PMD.AbstractUnbalancedACRModel, nw::Int, i::Int, bus::Int, connections::Vector{Int}, r::Real, x::Real, p_loss::Real, q_loss::Real)</code></pre><p>Nonlinear storage losses constraint for ac-rect form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/acr.jl#L247-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_storage_losses_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACRModel, Int64, Int64, Int64, Vector{Int64}, Real, Real, Real, Real}" href="#PowerModelsONM.constraint_mc_storage_losses_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACRModel, Int64, Int64, Int64, Vector{Int64}, Real, Real, Real, Real}"><code>PowerModelsONM.constraint_mc_storage_losses_traditional_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_storage_losses_traditional_on_off(pm::PMD.AbstractUnbalancedACRModel, nw::Int, i::Int, bus::Int, connections::Vector{Int}, r::Real, x::Real, p_loss::Real, q_loss::Real)</code></pre><p>Nonlinear storage losses constraint for ac-rect form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/acr.jl#L277-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_switch_voltage_open_close-Tuple{PowerModelsDistribution.AbstractUnbalancedACRModel, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}" href="#PowerModelsONM.constraint_mc_switch_voltage_open_close-Tuple{PowerModelsDistribution.AbstractUnbalancedACRModel, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}"><code>PowerModelsONM.constraint_mc_switch_voltage_open_close</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_switch_voltage_open_close(pm::PMD.AbstractUnbalancedACRModel, nw::Int, i::Int, f_bus::Int, t_bus::Int, f_connections::Vector{Int}, t_connections::Vector{Int})</code></pre><p>nonlinear switch power on/off constraint for ac-rect form</p><p class="math-container">\[\begin{align}
&amp; \\
&amp;
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/acr.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_transformer_power_yy_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}" href="#PowerModelsONM.constraint_mc_transformer_power_yy_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedACRModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}"><code>PowerModelsONM.constraint_mc_transformer_power_yy_block_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_transformer_power_yy_block_on_off(
    pm::PMD.AbstractUnbalancedACRModel,
    nw::Int,
    trans_id::Int,
    f_bus::Int,
    t_bus::Int,
    f_idx::Tuple{Int,Int,Int},
    t_idx::Tuple{Int,Int,Int},
    f_connections::Vector{Int},
    t_connections::Vector{Int},
    pol::Int,
    tm_set::Vector{&lt;:Real},
    tm_fixed::Vector{Bool},
    tm_scale::Real
)</code></pre><p>Links to and from power and voltages in a wye-wye transformer, assumes tm_fixed is true</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/acr.jl#L172-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_bus_voltage_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsONM.constraint_mc_bus_voltage_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsONM.constraint_mc_bus_voltage_block_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><p>do nothing, no voltage variables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/apo.jl#L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_bus_voltage_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsONM.constraint_mc_bus_voltage_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsONM.constraint_mc_bus_voltage_traditional_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><p>do nothing, no voltage variables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/apo.jl#L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_generator_power_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Vector{&lt;:Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsONM.constraint_mc_generator_power_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Vector{&lt;:Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsONM.constraint_mc_generator_power_block_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_generator_power_block_on_off(pm::PMD.AbstractUnbalancedNFAModel, nw::Int, i::Int, connections::Vector{Int}, pmin::Vector{&lt;:Real}, pmax::Vector{&lt;:Real}, ::Vector{&lt;:Real}, ::Vector{&lt;:Real})</code></pre><p>on/off block constraint for generators for NFA model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/apo.jl#L49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_generator_power_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Vector{&lt;:Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsONM.constraint_mc_generator_power_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Vector{&lt;:Int64}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsONM.constraint_mc_generator_power_traditional_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_generator_power_traditional_on_off(pm::PMD.AbstractUnbalancedNFAModel, nw::Int, i::Int, connections::Vector{Int}, pmin::Vector{&lt;:Real}, pmax::Vector{&lt;:Real}, ::Vector{&lt;:Real}, ::Vector{&lt;:Real})</code></pre><p>on/off traditional constraint for generators for NFAU form</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/apo.jl#L66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_inverter_theta_ref-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64}" href="#PowerModelsONM.constraint_mc_inverter_theta_ref-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64}"><code>PowerModelsONM.constraint_mc_inverter_theta_ref</code></a> — <span class="docstring-category">Method</span></header><section><div><p>nothing to do, no voltage angle variables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/apo.jl#L340">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_power_balance_shed_block-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsONM.constraint_mc_power_balance_shed_block-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsONM.constraint_mc_power_balance_shed_block</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_power_balance_shed_block(pm::PMD.AbstractUnbalancedNFAModel, nw::Int, i::Int,
    terminals::Vector{Int}, grounded::Vector{Bool}, bus_arcs::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}},
    bus_arcs_sw::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_trans::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}},
    bus_gens::Vector{Tuple{Int,Vector{Int}}}, bus_storage::Vector{Tuple{Int,Vector{Int}}},
    bus_loads::Vector{Tuple{Int,Vector{Int}}}, bus_shunts::Vector{Tuple{Int,Vector{Int}}}
)</code></pre><p>KCL for block load shed problem with transformers (NFAU Form)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/apo.jl#L83-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_power_balance_shed_traditional-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsONM.constraint_mc_power_balance_shed_traditional-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsONM.constraint_mc_power_balance_shed_traditional</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_power_balance_shed_traditional(pm::PMD.AbstractUnbalancedNFAModel, nw::Int, i::Int,
    terminals::Vector{Int}, grounded::Vector{Bool}, bus_arcs::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}},
    bus_arcs_sw::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_trans::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}},
    bus_gens::Vector{Tuple{Int,Vector{Int}}}, bus_storage::Vector{Tuple{Int,Vector{Int}}},
    bus_loads::Vector{Tuple{Int,Vector{Int}}}, bus_shunts::Vector{Tuple{Int,Vector{Int}}}
)</code></pre><p>KCL for traditional load shed problem with transformers (NFAU Form)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/apo.jl#L141-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_storage_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Vector{Int64}, Real, Real, Real, Real, Real, Real}" href="#PowerModelsONM.constraint_mc_storage_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Vector{Int64}, Real, Real, Real, Real, Real, Real}"><code>PowerModelsONM.constraint_mc_storage_block_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_storage_block_on_off(pm::PMD.AbstractUnbalancedNFAModel, nw::Int, i::Int, connections::Vector{Int}, pmin::Real, pmax::Real, ::Real, ::Real, ::Real, ::Real)</code></pre><p>block on/off constraint for storage in NFAU Form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/apo.jl#L200-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_storage_losses_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Int64, Vector{Int64}, Real, Real, Real, Real}" href="#PowerModelsONM.constraint_mc_storage_losses_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Int64, Vector{Int64}, Real, Real, Real, Real}"><code>PowerModelsONM.constraint_mc_storage_losses_block_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_storage_losses_block_on_off(pm::PMD.AbstractUnbalancedNFAModel, nw::Int, i::Int, bus::Int, connections::Vector{Int}, ::Real, ::Real, ::Real, ::Real)</code></pre><p>Neglects all losses (lossless model), NFAU Form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/apo.jl#L230-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_storage_losses_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Int64, Vector{Int64}, Real, Real, Real, Real}" href="#PowerModelsONM.constraint_mc_storage_losses_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Int64, Vector{Int64}, Real, Real, Real, Real}"><code>PowerModelsONM.constraint_mc_storage_losses_traditional_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_storage_losses_traditional_on_off(pm::PMD.AbstractUnbalancedNFAModel, nw::Int, i::Int, bus::Int, connections::Vector{Int}, ::Real, ::Real, ::Real, ::Real)</code></pre><p>Neglects all losses (lossless model), NFAU Form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/apo.jl#L246-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_storage_phase_unbalance_grid_following-Tuple{PowerModelsDistribution.AbstractUnbalancedActivePowerModel, Int64, Int64, Vector{Int64}, Real}" href="#PowerModelsONM.constraint_mc_storage_phase_unbalance_grid_following-Tuple{PowerModelsDistribution.AbstractUnbalancedActivePowerModel, Int64, Int64, Vector{Int64}, Real}"><code>PowerModelsONM.constraint_mc_storage_phase_unbalance_grid_following</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_storage_phase_unbalance_grid_following(
    pm::AbstractUnbalancedPowerModel,
    nw::Int,
    i::Int,
    connections::Vector{Int},
    unbalance_factor::Real
)</code></pre><p>Enforces that storage inputs/outputs are (approximately) balanced across each phase, by some <code>unbalance_factor</code> on grid-following inverters only. Requires z_inverter variable. Variant for Active Power Only models.</p><p class="math-container">\[S^{strg}_{i,c} \geq S^{strg}_{i,d} - f^{unbal} \left( -d^{on}_i S^{strg}_{i,d} + c^{on}_i S^{strg}_{i,d} \right) \forall c,d \in C\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/apo.jl#L346-L361">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_storage_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Vector{Int64}, Real, Real, Real, Real, Real, Real}" href="#PowerModelsONM.constraint_mc_storage_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Vector{Int64}, Real, Real, Real, Real, Real, Real}"><code>PowerModelsONM.constraint_mc_storage_traditional_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_storage_traditional_on_off(pm::PMD.AbstractUnbalancedNFAModel, nw::Int, i::Int, connections::Vector{Int}, pmin::Real, pmax::Real, ::Real, ::Real, ::Real, ::Real)</code></pre><p>traditional on/off constraint for storage in NFAU Form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/apo.jl#L215-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_switch_power_open_close-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}" href="#PowerModelsONM.constraint_mc_switch_power_open_close-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}"><code>PowerModelsONM.constraint_mc_switch_power_open_close</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_switch_power_open_close(pm::PMD.AbstractUnbalancedNFAModel, nw::Int, i::Int, f_bus::Int, t_bus::Int, f_connections::Vector{Int}, t_connections::Vector{Int})</code></pre><p>Linear switch power on/off constraint for Active Power Only Models. If <code>relax</code>, an <a href="https://jump.dev/JuMP.jl/stable/manual/constraints/#Indicator-constraints">indicator constraint</a> is used.</p><p class="math-container">\[\begin{align}
&amp; P^{sw}_{i,c} \leq P^{swu}_{i,c} z^{sw}_i\ \forall i \in P,\forall c \in C \\
&amp; P^{sw}_{i,c} \geq -P^{swu}_{i,c} z^{sw}_i\ \forall i \in P,\forall c \in C
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/apo.jl#L10-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_switch_voltage_open_close-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}" href="#PowerModelsONM.constraint_mc_switch_voltage_open_close-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}"><code>PowerModelsONM.constraint_mc_switch_voltage_open_close</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_switch_voltage_open_close(pm::PMD.AbstractUnbalancedNFAModel, nw::Int, i::Int, f_bus::Int, t_bus::Int, f_connections::Vector{Int}, t_connections::Vector{Int})</code></pre><p>No voltage variables, do nothing</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/apo.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_transformer_power_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64}" href="#PowerModelsONM.constraint_mc_transformer_power_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64}"><code>PowerModelsONM.constraint_mc_transformer_power_block_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_transformer_power_block_on_off(pm::PMD.AbstractUnbalancedNFAModel, i::Int; nw::Int=nw_id_default, fix_taps::Bool=false)</code></pre><p>transformer active power only constraint pf=-pt</p><p class="math-container">\[p_f[fc] == -pt[tc]\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/apo.jl#L263-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_transformer_power_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64}" href="#PowerModelsONM.constraint_mc_transformer_power_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64}"><code>PowerModelsONM.constraint_mc_transformer_power_traditional_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/apo.jl#L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_storage_complementarity_mi_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Real, Real}" href="#PowerModelsONM.constraint_storage_complementarity_mi_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Real, Real}"><code>PowerModelsONM.constraint_storage_complementarity_mi_block_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_storage_complementarity_mi_block_on_off(pm::Union{PMD.LPUBFDiagModel,PMD.AbstractUnbalancedNFAModel}, n::Int, i::Int, charge_ub::Real, discharge_ub::Real)</code></pre><p>linear storage complementarity mi constraint for block mld problem</p><p>math<code>sc_{on} + sd_{on} == z_{block}</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/apo.jl#L288-L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_storage_complementarity_mi_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Real, Real}" href="#PowerModelsONM.constraint_storage_complementarity_mi_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedNFAModel, Int64, Int64, Real, Real}"><code>PowerModelsONM.constraint_storage_complementarity_mi_traditional_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_storage_complementarity_mi_traditional_on_off(
    pm::Union{PMD.LPUBFDiagModel,PMD.AbstractUnbalancedNFAModel},
    n::Int,
    i::Int,
    charge_ub::Real,
    discharge_ub::Real
)</code></pre><p>linear storage complementarity mi constraint for traditional mld problem</p><p>math<code>sc_{on} + sd_{on} == z_{block}</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/apo.jl#L311-L325">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_inverter_theta_ref-Tuple{PowerModelsDistribution.LPUBFDiagModel, Int64, Int64, Vector{&lt;:Real}}" href="#PowerModelsONM.constraint_mc_inverter_theta_ref-Tuple{PowerModelsDistribution.LPUBFDiagModel, Int64, Int64, Vector{&lt;:Real}}"><code>PowerModelsONM.constraint_mc_inverter_theta_ref</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_inverter_theta_ref(pm::PMD.LPUBFDiagModel, nw::Int, i::Int, ::Vector{&lt;:Real})</code></pre><p>Constrains a bus with a connected grid-forming inverter to have a reference bus constraint</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/lindistflow.jl#L518-L522">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_load_power-Tuple{PowerModelsDistribution.LPUBFDiagModel, Int64, Int64}" href="#PowerModelsONM.constraint_mc_load_power-Tuple{PowerModelsDistribution.LPUBFDiagModel, Int64, Int64}"><code>PowerModelsONM.constraint_mc_load_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_load_power(pm::PMD.LPUBFDiagModel, load_id::Int, scen::Int; nw::Int=nw_id_default, report::Bool=true)</code></pre><p>Load models for LPUBFDiagModel (similar to PMD.constraint<em>mc</em>load_power) for robust mld problem. The constraints are different for each scenario.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/lindistflow.jl#L543-L547">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_power_balance_shed_block-Tuple{PowerModelsDistribution.LPUBFDiagModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsONM.constraint_mc_power_balance_shed_block-Tuple{PowerModelsDistribution.LPUBFDiagModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsONM.constraint_mc_power_balance_shed_block</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_power_balance_shed_block(pm::PMD.LPUBFDiagModel, nw::Int, i::Int,
    terminals::Vector{Int}, grounded::Vector{Bool}, bus_arcs::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}},
    bus_arcs_sw::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_trans::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}},
    bus_gens::Vector{Tuple{Int,Vector{Int}}}, bus_storage::Vector{Tuple{Int,Vector{Int}}},
    bus_loads::Vector{Tuple{Int,Vector{Int}}}, bus_shunts::Vector{Tuple{Int,Vector{Int}}}
)</code></pre><p>KCL for block load shed problem with transformers (LinDistFlow Form)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/lindistflow.jl#L37-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_power_balance_shed_traditional-Tuple{PowerModelsDistribution.LPUBFDiagModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}" href="#PowerModelsONM.constraint_mc_power_balance_shed_traditional-Tuple{PowerModelsDistribution.LPUBFDiagModel, Int64, Int64, Vector{Int64}, Vector{Bool}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Tuple{Int64, Int64, Int64}, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}, Vector{Tuple{Int64, Vector{Int64}}}}"><code>PowerModelsONM.constraint_mc_power_balance_shed_traditional</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_power_balance_shed_traditional(pm::PMD.LPUBFDiagModel, nw::Int, i::Int, terminals::Vector{Int}, grounded::Vector{Bool}, bus_arcs::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_sw::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_arcs_trans::Vector{Tuple{Tuple{Int,Int,Int},Vector{Int}}}, bus_gens::Vector{Tuple{Int,Vector{Int}}}, bus_storage::Vector{Tuple{Int,Vector{Int}}}, bus_loads::Vector{Tuple{Int,Vector{Int}}}, bus_shunts::Vector{Tuple{Int,Vector{Int}}})</code></pre><p>KCL for traditional load shed problem with transformers (LinDistFlow Form)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/lindistflow.jl#L151-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_storage_losses_block_on_off-Tuple{PowerModelsDistribution.LPUBFDiagModel, Int64, Int64, Int64, Vector{Int64}, Real, Real, Real, Real}" href="#PowerModelsONM.constraint_mc_storage_losses_block_on_off-Tuple{PowerModelsDistribution.LPUBFDiagModel, Int64, Int64, Int64, Vector{Int64}, Real, Real, Real, Real}"><code>PowerModelsONM.constraint_mc_storage_losses_block_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_storage_losses_block_on_off(pm::PMD.LPUBFDiagModel, nw::Int, i::Int, bus::Int, connections::Vector{Int}, r::Real, x::Real, p_loss::Real, q_loss::Real)</code></pre><p>Neglects the active and reactive loss terms associated with the squared current magnitude.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/lindistflow.jl#L415-L419">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_storage_losses_traditional_on_off-Tuple{PowerModelsDistribution.LPUBFDiagModel, Int64, Int64, Int64, Vector{Int64}, Real, Real, Real, Real}" href="#PowerModelsONM.constraint_mc_storage_losses_traditional_on_off-Tuple{PowerModelsDistribution.LPUBFDiagModel, Int64, Int64, Int64, Vector{Int64}, Real, Real, Real, Real}"><code>PowerModelsONM.constraint_mc_storage_losses_traditional_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_storage_losses_traditional_on_off(pm::PMD.LPUBFDiagModel, nw::Int, i::Int, bus::Int, connections::Vector{Int}, r::Real, x::Real, p_loss::Real, q_loss::Real)</code></pre><p>Neglects the active and reactive loss terms associated with the squared current magnitude.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/lindistflow.jl#L446-L450">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_switch_voltage_open_close-Tuple{PowerModelsDistribution.LPUBFDiagModel, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}" href="#PowerModelsONM.constraint_mc_switch_voltage_open_close-Tuple{PowerModelsDistribution.LPUBFDiagModel, Int64, Int64, Int64, Int64, Vector{Int64}, Vector{Int64}}"><code>PowerModelsONM.constraint_mc_switch_voltage_open_close</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_switch_voltage_open_close(pm::PMD.LPUBFDiagModel, nw::Int, i::Int, f_bus::Int, t_bus::Int, f_connections::Vector{Int}, t_connections::Vector{Int})</code></pre><p>Linear switch power on/off constraint for LPUBFDiagModel.</p><p class="math-container">\[\begin{align}
&amp; w^{fr}_{i,c} - w^{to}_{i,c} \leq \left ( v^u_{i,c} \right )^2 \left ( 1 - z^{sw}_i \right )\ \forall i \in S,\forall c \in C \\
&amp; w^{fr}_{i,c} - w^{to}_{i,c} \geq -\left ( v^u_{i,c}\right )^2 \left ( 1 - z^{sw}_i \right )\ \forall i \in S,\forall c \in C
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/lindistflow.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_transformer_power_yy_block_on_off-Tuple{PowerModelsDistribution.LPUBFDiagModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}" href="#PowerModelsONM.constraint_mc_transformer_power_yy_block_on_off-Tuple{PowerModelsDistribution.LPUBFDiagModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}"><code>PowerModelsONM.constraint_mc_transformer_power_yy_block_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_transformer_power_yy_block_on_off(
    pm::PMD.LPUBFDiagModel,
    nw::Int,
    trans_id::Int,
    f_bus::Int,
    t_bus::Int,
    f_idx::Tuple{Int,Int,Int},
    t_idx::Tuple{Int,Int,Int},
    f_connections::Vector{Int},
    t_connections::Vector{Int},
    pol::Int,
    tm_set::Vector{&lt;:Real},
    tm_fixed::Vector{Bool},
    tm_scale::Real
)</code></pre><p>Links to and from power and voltages in a wye-wye transformer, assumes tm_fixed is true</p><p class="math-container">\[w_fr_i=(pol_i*tm_scale*tm_i)^2w_to_i\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/lindistflow.jl#L262-L284">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_transformer_power_yy_traditional_on_off-Tuple{PowerModelsDistribution.LPUBFDiagModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}" href="#PowerModelsONM.constraint_mc_transformer_power_yy_traditional_on_off-Tuple{PowerModelsDistribution.LPUBFDiagModel, Int64, Int64, Int64, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Vector{Int64}, Vector{Int64}, Int64, Vector{&lt;:Real}, Vector{Bool}, Real}"><code>PowerModelsONM.constraint_mc_transformer_power_yy_traditional_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_transformer_power_yy_traditional_on_off(pm::PMD.LPUBFDiagModel, nw::Int, trans_id::Int, f_bus::Int, t_bus::Int, f_idx::Tuple{Int,Int,Int}, t_idx::Tuple{Int,Int,Int}, f_connections::Vector{Int}, t_connections::Vector{Int}, pol::Int, tm_set::Vector{&lt;:Real}, tm_fixed::Vector{Bool}, tm_scale::Real)

Links to and from power and voltages in a wye-wye transformer, assumes tm_fixed is true</code></pre><p class="math-container">\[w_fr_i=(pol_i*tm_scale*tm_i)^2w_to_i\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/lindistflow.jl#L345-L353">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_storage_complementarity_mi_block_on_off-Tuple{PowerModelsDistribution.LPUBFDiagModel, Int64, Int64, Real, Real}" href="#PowerModelsONM.constraint_storage_complementarity_mi_block_on_off-Tuple{PowerModelsDistribution.LPUBFDiagModel, Int64, Int64, Real, Real}"><code>PowerModelsONM.constraint_storage_complementarity_mi_block_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_storage_complementarity_mi_block_on_off(pm::PMD.LPUBFDiagModel, n::Int, i::Int, charge_ub::Real, discharge_ub::Real)</code></pre><p>linear storage complementarity mi constraint for block mld problem</p><p>math<code>sc_{on} + sd_{on} == z_{block}</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/lindistflow.jl#L472-L480">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_storage_complementarity_mi_traditional_on_off-Tuple{PowerModelsDistribution.LPUBFDiagModel, Int64, Int64, Real, Real}" href="#PowerModelsONM.constraint_storage_complementarity_mi_traditional_on_off-Tuple{PowerModelsDistribution.LPUBFDiagModel, Int64, Int64, Real, Real}"><code>PowerModelsONM.constraint_storage_complementarity_mi_traditional_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_storage_complementarity_mi_traditional_on_off(pm::PMD.LPUBFDiagModel, n::Int, i::Int, charge_ub::Real, discharge_ub::Real)</code></pre><p>linear storage complementarity mi constraint for traditional mld problem</p><p>math<code>sc_{on} + sd_{on} == z_{block}</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/lindistflow.jl#L495-L503">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_bus_voltage_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedWModels, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsONM.constraint_mc_bus_voltage_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedWModels, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsONM.constraint_mc_bus_voltage_block_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_bus_voltage_block_on_off(pm::PMD.AbstractUnbalancedWModels, nw::Int, i::Int, vmin::Vector{&lt;:Real}, vmax::Vector{&lt;:Real})</code></pre><p>Redirects to <code>constraint_mc_bus_voltage_magnitude_sqr_block_on_off</code> for <code>AbstractUnbalancedWModels</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/shared.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_bus_voltage_magnitude_sqr_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedWModels, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsONM.constraint_mc_bus_voltage_magnitude_sqr_block_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedWModels, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsONM.constraint_mc_bus_voltage_magnitude_sqr_block_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_bus_voltage_magnitude_sqr_block_on_off(
    pm::PMD.AbstractUnbalancedWModels,
    nw::Int,
    i::Int,
    vmin::Vector{&lt;:Real},
    vmax::Vector{&lt;:Real}
)</code></pre><p>on/off block bus voltage magnitude squared constraint for W models</p><p class="math-container">\[\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/shared.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_bus_voltage_magnitude_sqr_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedWModels, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsONM.constraint_mc_bus_voltage_magnitude_sqr_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedWModels, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsONM.constraint_mc_bus_voltage_magnitude_sqr_traditional_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_bus_voltage_magnitude_sqr_traditional_on_off(
    pm::PMD.AbstractUnbalancedWModels,
    nw::Int,
    i::Int,
    vmin::Vector{&lt;:Real},
    vmax::Vector{&lt;:Real}
)</code></pre><p>on/off traditional bus voltage magnitude squared constraint for W models</p><p class="math-container">\[\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/shared.jl#L29-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_bus_voltage_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedWModels, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#PowerModelsONM.constraint_mc_bus_voltage_traditional_on_off-Tuple{PowerModelsDistribution.AbstractUnbalancedWModels, Int64, Int64, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>PowerModelsONM.constraint_mc_bus_voltage_traditional_on_off</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_bus_voltage_traditional_on_off(pm::PMD.AbstractUnbalancedWModels, nw::Int, i::Int, vmin::Vector{&lt;:Real}, vmax::Vector{&lt;:Real})</code></pre><p>Redirects to <code>constraint_mc_bus_voltage_magnitude_sqr_traditional_on_off</code> for <code>AbstractUnbalancedWModels</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/shared.jl#L65-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.constraint_mc_inverter_theta_ref-Tuple{PowerModelsDistribution.AbstractUnbalancedPolarModels, Int64, Int64, Vector{&lt;:Real}}" href="#PowerModelsONM.constraint_mc_inverter_theta_ref-Tuple{PowerModelsDistribution.AbstractUnbalancedPolarModels, Int64, Int64, Vector{&lt;:Real}}"><code>PowerModelsONM.constraint_mc_inverter_theta_ref</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_mc_inverter_theta_ref(pm::PMD.AbstractUnbalancedPolarModels, nw::Int, i::Int, va_ref::Vector{&lt;:Real})</code></pre><p>Phase angle constraints at reference buses for the Unbalanced Polar models</p><p>math<code>\begin{align*} V_a - V^{ref}_a \leq 60^{\circ} * (1-\sum{z_{inv}}) V_a - V^{ref}_a \geq -60^{\circ} * (1-\sum{z_{inv}}) \end{align*}</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/form/shared.jl#L73-L84">source</a></section></article><h2 id="Objectives"><a class="docs-heading-anchor" href="#Objectives">Objectives</a><a id="Objectives-1"></a><a class="docs-heading-anchor-permalink" href="#Objectives" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.objective_mc_min_storage_utilization-Tuple{AbstractUnbalancedPowerModel}" href="#PowerModelsONM.objective_mc_min_storage_utilization-Tuple{AbstractUnbalancedPowerModel}"><code>PowerModelsONM.objective_mc_min_storage_utilization</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">objective_mc_min_storage_utilization(pm::AbstractUnbalancedPowerModel)</code></pre><p>Minimizes the amount of storage that gets utilized in favor of using all available generation first</p><p class="math-container">\[\begin{align*}
\mbox{minimize: } &amp; \\
&amp; \sum_{\substack{e \in E,t \in T}} \epsilon^{ub}_{e} - \epsilon_{e,t} \\
\end{align*}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/objective.jl#L307-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.objective_min_shed_load_block-Tuple{AbstractUnbalancedPowerModel}" href="#PowerModelsONM.objective_min_shed_load_block-Tuple{AbstractUnbalancedPowerModel}"><code>PowerModelsONM.objective_min_shed_load_block</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">objective_min_shed_load_block(pm::AbstractUnbalancedPowerModel)</code></pre><p>Minimum block load shed objective for rolling horizon problem. Note that the difference between this and <a href="variable_constraint.html#PowerModelsONM.objective_min_shed_load_block_rolling_horizon-Tuple{AbstractUnbalancedPowerModel}"><code>objective_min_shed_load_block_rolling_horizon</code></a> is that the sum over the switches in line 2 of the objective is optional, as determined by user inputs in the model, i.e., <code>enable_switch_state_open_cost</code> (default: false), and <code>disable-switch-state-change-cost</code> (default: false).</p><p>```math \begin{align<em>} \mbox{minimize: } &amp; \
&amp; \sum<em>{\substack{b \in B,t \in T}} W^{bl}</em>{b,t} \left(1 - z^{bl}<em>{b,t} \right) \
&amp; + \sum</em>{\substack{s \in S,t \in T}} \left[ W^{sw}<em>{s,t} \left(1 - \gamma</em>{s,t} \right )) +  W^{\Delta^{\gamma}}<em>{s,t}\Delta^{\gamma}</em>{s,t}\right ]\
&amp; + \sum<em>{\substack{e \in E,t \in T}} \epsilon^{ub}</em>{e} - \epsilon<em>{e,t} \
&amp; + \sum</em>{\substack{g \in G,t \in T}} f<em>1 P</em>{g,t} + f_0 \end{align</em>}```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/objective.jl#L153-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.objective_min_shed_load_block_rolling_horizon-Tuple{AbstractUnbalancedPowerModel}" href="#PowerModelsONM.objective_min_shed_load_block_rolling_horizon-Tuple{AbstractUnbalancedPowerModel}"><code>PowerModelsONM.objective_min_shed_load_block_rolling_horizon</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">objective_min_shed_load_block_rolling_horizon(pm::AbstractUnbalancedPowerModel)</code></pre><p>Minimum block load shed objective for rolling horizon problem. Note that the difference between this and <a href="variable_constraint.html#PowerModelsONM.objective_min_shed_load_block-Tuple{AbstractUnbalancedPowerModel}"><code>objective_min_shed_load_block</code></a> is that the sum over the switches in line 2 of the objective is non-optional.</p><p>```math \begin{align<em>} \mbox{minimize: } &amp; \
&amp; \sum<em>{\substack{b \in B,t \in T}} W^{bl}</em>{b,t} \left(1 - z^{bl}<em>{b,t} \right) \
&amp; + \sum</em>{\substack{s \in S,t \in T}} \left[ W^{sw}<em>{s,t} \left(1 - \gamma</em>{s,t} \right )) +  W^{\Delta^{\gamma}}<em>{s,t}\Delta^{\gamma}</em>{s,t}\right ]\
&amp; + \sum<em>{\substack{e \in E,t \in T}} \epsilon^{ub}</em>{e} - \epsilon<em>{e,t} \
&amp; + \sum</em>{\substack{g \in G,t \in T}} f<em>1 P</em>{g,t} + f_0 \end{align</em>}```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/objective.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.objective_min_shed_load_traditional-Tuple{AbstractUnbalancedPowerModel}" href="#PowerModelsONM.objective_min_shed_load_traditional-Tuple{AbstractUnbalancedPowerModel}"><code>PowerModelsONM.objective_min_shed_load_traditional</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">objective_min_shed_load_traditional(pm::AbstractUnbalancedPowerModel)</code></pre><p>Minimum block load shed objective for rolling horizon problem. Note that the difference between this and <a href="variable_constraint.html#PowerModelsONM.objective_min_shed_load_traditional_rolling_horizon-Tuple{AbstractUnbalancedPowerModel}"><code>objective_min_shed_load_traditional_rolling_horizon</code></a> is that the sum over the switches in line 2 of the objective is optional, as determined by user inputs in the model, i.e., <code>enable_switch_state_open_cost</code> (default: false), and <code>disable-switch-state-change-cost</code> (default: false).</p><p class="math-container">\[\begin{align*}
\mbox{minimize: } &amp; \\
&amp; \sum_{\substack{l \in L,t \in T}} W^{d}_{l,t} \left(1 - z^{d}_{l,t} \right) \\
&amp; + \sum_{\substack{s \in S,t \in T}} \left[ W^{sw}_{s,t} \left(1 - \gamma_{s,t} \right )) +  W^{\Delta^{\gamma}}_{s,t}\Delta^{\gamma}_{s,t}\right ]\\
&amp; + \sum_{\substack{e \in E,t \in T}} \epsilon^{ub}_{e} - \epsilon_{e,t} \\
&amp; + \sum_{\substack{g \in G,t \in T}} f_1 P_{g,t} + f_0
\end{align*}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/objective.jl#L229-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.objective_min_shed_load_traditional_rolling_horizon-Tuple{AbstractUnbalancedPowerModel}" href="#PowerModelsONM.objective_min_shed_load_traditional_rolling_horizon-Tuple{AbstractUnbalancedPowerModel}"><code>PowerModelsONM.objective_min_shed_load_traditional_rolling_horizon</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">objective_min_shed_load_traditional_rolling_horizon(pm::AbstractUnbalancedPowerModel)</code></pre><p>Minimum block load shed objective for rolling horizon problem. Note that the difference between this and <a href="variable_constraint.html#PowerModelsONM.objective_min_shed_load_traditional-Tuple{AbstractUnbalancedPowerModel}"><code>objective_min_shed_load_traditional</code></a> is that the sum over the switches in line 2 of the objective is non-optional.</p><p class="math-container">\[\begin{align*}
\mbox{minimize: } &amp; \\
&amp; \sum_{\substack{l \in L,t \in T}} W^{d}_{l,t} \left(1 - z^{d}_{l,t} \right) \\
&amp; + \sum_{\substack{s \in S,t \in T}} \left[ W^{sw}_{s,t} \left(1 - \gamma_{s,t} \right )) +  W^{\Delta^{\gamma}}_{s,t}\Delta^{\gamma}_{s,t}\right ]\\
&amp; + \sum_{\substack{e \in E,t \in T}} \epsilon^{ub}_{e} - \epsilon_{e,t} \\
&amp; + \sum_{\substack{g \in G,t \in T}} f_1 P_{g,t} + f_0
\end{align*}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/objective.jl#L76-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.objective_robust_min_shed_load_block_rolling_horizon-Tuple{AbstractUnbalancedPowerModel, Dict{Int64, JuMP.AffExpr}, Int64}" href="#PowerModelsONM.objective_robust_min_shed_load_block_rolling_horizon-Tuple{AbstractUnbalancedPowerModel, Dict{Int64, JuMP.AffExpr}, Int64}"><code>PowerModelsONM.objective_robust_min_shed_load_block_rolling_horizon</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">objective_robust_min_shed_load_block_rolling_horizon(pm::AbstractUnbalancedPowerModel, scenarios::Vector{Int})</code></pre><p>Minimum block load shed objective (similar to objective<em>min</em>shed<em>load</em>block<em>rolling</em>horizon) for robust partitioning problem considering uncertainty</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/objective.jl#L384-L388">source</a></section></article><h2 id="Ref-extensions"><a class="docs-heading-anchor" href="#Ref-extensions">Ref extensions</a><a id="Ref-extensions-1"></a><a class="docs-heading-anchor-permalink" href="#Ref-extensions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.ref_add_load_blocks!-Tuple{Dict{Symbol}, Dict{String}}" href="#PowerModelsONM.ref_add_load_blocks!-Tuple{Dict{Symbol}, Dict{String}}"><code>PowerModelsONM.ref_add_load_blocks!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ref_add_load_blocks!(ref::Dict{Symbol,&lt;:Any}, data::Dict{String,&lt;:Any})</code></pre><p>Ref extension to add load blocks to ref for all time steps</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/ref.jl#L115-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModelsONM.ref_add_options!-Tuple{Dict{Symbol}, Dict{String}}" href="#PowerModelsONM.ref_add_options!-Tuple{Dict{Symbol}, Dict{String}}"><code>PowerModelsONM.ref_add_options!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ref_add_options!(ref::Dict{Symbol,&lt;:Any}, data::Dict{String,&lt;:Any})</code></pre><p>Ref extension to add options to ref for all time steps</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModelsONM.jl/blob/f5a5ccfbd1e2a43550a3a486af055256e9919624/src/core/ref.jl#L125-L129">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="stats.html">« Solution Statistics</a><a class="docs-footer-nextpage" href="types.html">Types »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 31 January 2023 19:17">Tuesday 31 January 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
